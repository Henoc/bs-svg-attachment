// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List         = require("bs-platform/lib/js/list.js");
var $$Array      = require("bs-platform/lib/js/array.js");
var Block        = require("bs-platform/lib/js/block.js");
var Caml_array   = require("bs-platform/lib/js/caml_array.js");
var Pervasives   = require("bs-platform/lib/js/pervasives.js");
var Caml_format  = require("bs-platform/lib/js/caml_format.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");

function next(regex, s) {
  var resultOpt = regex.exec(s);
  if (resultOpt !== null) {
    return Js_primitive.null_undefined_to_opt(Caml_array.caml_array_get(resultOpt, 0));
  } else {
    return /* None */0;
  }
}

function getAllFloats(s) {
  var floatRegex = (/[+-]?[0-9]+(\.[0-9]*)?([eE][+-]?[0-9]+)?/g);
  var loop = function (s, _acc) {
    while(true) {
      var acc = _acc;
      var match = next(floatRegex, s);
      if (match) {
        _acc = /* :: */[
          match[0],
          acc
        ];
        continue ;
        
      } else {
        return acc;
      }
    };
  };
  return List.map(Caml_format.caml_float_of_string, List.rev(loop(s, /* [] */0)));
}

function getAllInts(s) {
  var intRegex = (/[+-]?\d+/g);
  var loop = function (s, _acc) {
    while(true) {
      var acc = _acc;
      var match = next(intRegex, s);
      if (match) {
        _acc = /* :: */[
          match[0],
          acc
        ];
        continue ;
        
      } else {
        return acc;
      }
    };
  };
  return List.map(Caml_format.caml_int_of_string, List.rev(loop(s, /* [] */0)));
}

function parseRgb(s) {
  var ints = $$Array.of_list(getAllInts(s));
  return /* Rgb */Block.__(1, [/* record */[
              /* r */Caml_array.caml_array_get(ints, 0),
              /* g */Caml_array.caml_array_get(ints, 1),
              /* b */Caml_array.caml_array_get(ints, 2)
            ]]);
}

function parseRgba(s) {
  var floats = $$Array.of_list(getAllFloats(s));
  return /* Rgba */Block.__(0, [/* record */[
              /* r */Caml_array.caml_array_get(floats, 0) | 0,
              /* g */Caml_array.caml_array_get(floats, 1) | 0,
              /* b */Caml_array.caml_array_get(floats, 2) | 0,
              /* a */Caml_array.caml_array_get(floats, 3)
            ]]);
}

function genColor(color) {
  if (typeof color === "number") {
    return "none";
  } else if (color.tag) {
    var rgb = color[0];
    return "rgb(" + (Pervasives.string_of_int(rgb[/* r */0]) + ("," + (Pervasives.string_of_int(rgb[/* g */1]) + ("," + (Pervasives.string_of_int(rgb[/* b */2]) + ")")))));
  } else {
    var rgba = color[0];
    return "rgba(" + (Pervasives.string_of_int(rgba[/* r */0]) + ("," + (Pervasives.string_of_int(rgba[/* g */1]) + ("," + (Pervasives.string_of_int(rgba[/* b */2]) + ("," + (Pervasives.string_of_float(rgba[/* a */3]) + ")")))))));
  }
}

function parsePoints(s) {
  var floats = getAllFloats(s);
  var loop = function (_floats, _acc) {
    while(true) {
      var acc = _acc;
      var floats = _floats;
      if (floats) {
        var match = floats[1];
        if (match) {
          _acc = /* :: */[
            /* float array */[
              floats[0],
              match[0]
            ],
            acc
          ];
          _floats = match[1];
          continue ;
          
        } else {
          return acc;
        }
      } else {
        return acc;
      }
    };
  };
  return List.rev(loop(floats, /* [] */0));
}

function genPoints(points) {
  var toStr = function (vec2) {
    return Pervasives.string_of_float(vec2[/* x */0]) + (" " + Pervasives.string_of_float(vec2[/* y */1]));
  };
  var _points = List.tl(points);
  var _acc = toStr(List.hd(points));
  while(true) {
    var acc = _acc;
    var points$1 = _points;
    if (points$1) {
      _acc = acc + (", " + toStr(points$1[0]));
      _points = points$1[1];
      continue ;
      
    } else {
      return acc;
    }
  };
}

function parseD(s) {
  var loop2 = function (regex, _acc) {
    while(true) {
      var acc = _acc;
      var match = next(regex, s);
      if (match) {
        var match$1 = next(regex, s);
        if (match$1) {
          _acc = /* :: */[
            /* float array */[
              Caml_format.caml_float_of_string(match[0]),
              Caml_format.caml_float_of_string(match$1[0])
            ],
            acc
          ];
          continue ;
          
        } else {
          return acc;
        }
      } else {
        return acc;
      }
    };
  };
  var loop = function (regex, _acc) {
    while(true) {
      var acc = _acc;
      var match = next(regex, s);
      if (match) {
        var sepFloatRegex = (/^[,\s]+[+-]?[0-9]+(\.[0-9]*)?([eE][+-]?[0-9]+)?/g);
        var points = loop2(sepFloatRegex, /* [] */0);
        _acc = /* :: */[
          /* record */[
            /* operator */match[0],
            /* points */points
          ],
          acc
        ];
        continue ;
        
      } else {
        return acc;
      }
    };
  };
  var dOperator = (/[mMlLhHvVaAqQtTcCsSzZ]/g);
  return List.rev(loop(dOperator, /* [] */0));
}

function genD(operators) {
  var toStr = function (op) {
    return op[/* operator */0] + (" " + genPoints(op[/* points */1]));
  };
  var _ops = List.tl(operators);
  var _acc = toStr(List.hd(operators));
  while(true) {
    var acc = _acc;
    var ops = _ops;
    if (ops) {
      _acc = acc + (", " + toStr(ops[0]));
      _ops = ops[1];
      continue ;
      
    } else {
      return acc;
    }
  };
}

exports.next         = next;
exports.getAllFloats = getAllFloats;
exports.getAllInts   = getAllInts;
exports.parseRgb     = parseRgb;
exports.parseRgba    = parseRgba;
exports.genColor     = genColor;
exports.parsePoints  = parsePoints;
exports.genPoints    = genPoints;
exports.parseD       = parseD;
exports.genD         = genD;
/* No side effect */
