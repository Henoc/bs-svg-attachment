// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List         = require("bs-platform/lib/js/list.js");
var Vec2         = require("./vec2.bs.js");
var Block        = require("bs-platform/lib/js/block.js");
var Curry        = require("bs-platform/lib/js/curry.js");
var Option       = require("bs-batteries/lib/js/src/option.js");
var Natives      = require("./natives.bs.js");
var Parsers      = require("./parsers.bs.js");
var Pervasives   = require("bs-platform/lib/js/pervasives.js");
var Caml_format  = require("bs-platform/lib/js/caml_format.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");

function getAttr(name, elem) {
  return Js_primitive.null_to_opt(elem.getAttribute(name));
}

function setAttr(name, value, elem) {
  elem.setAttribute(name, value);
  return /* () */0;
}

function changeAttr(name, valueTranslator, elem) {
  var prev = elem.getAttribute(name);
  var match = Option.map(valueTranslator, prev === null ? /* None */0 : [prev]);
  if (match) {
    elem.setAttribute(name, match[0]);
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function deleteAttr(name, elem) {
  elem.setAttribute(name, ( null ));
  return /* () */0;
}

function move(delta, elem) {
  var tx = function (prev) {
    return Pervasives.string_of_float(Caml_format.caml_float_of_string(prev) + delta[/* x */0]);
  };
  var ty = function (prev) {
    return Pervasives.string_of_float(Caml_format.caml_float_of_string(prev) + delta[/* y */1]);
  };
  var match = elem.tagName;
  var exit = 0;
  switch (match) {
    case "circle" : 
    case "ellipse" : 
        exit = 1;
        break;
    case "line" : 
        changeAttr("x1", tx, elem);
        changeAttr("y1", ty, elem);
        changeAttr("x2", tx, elem);
        return changeAttr("y2", ty, elem);
    case "path" : 
        var d = List.map((function (op) {
                return /* record */[
                        /* operator */op[/* operator */0],
                        /* points */List.map((function (p) {
                                return Vec2.$plus$caret(p, delta);
                              }), op[/* points */1])
                      ];
              }), Option.$$default(/* [] */0, Option.map(Parsers.parseD, Js_primitive.null_to_opt(elem.getAttribute("d")))));
        return setAttr("d", Parsers.genD(d), elem);
    case "polygon" : 
    case "polyline" : 
        exit = 3;
        break;
    case "image" : 
    case "rect" : 
    case "text" : 
    case "use" : 
        exit = 2;
        break;
    default:
      return /* () */0;
  }
  switch (exit) {
    case 1 : 
        changeAttr("cx", tx, elem);
        return changeAttr("cy", ty, elem);
    case 2 : 
        changeAttr("x", tx, elem);
        return changeAttr("y", ty, elem);
    case 3 : 
        var points = List.map((function (p) {
                return Vec2.$plus$caret(p, delta);
              }), Option.$$default(/* [] */0, Option.map(Parsers.parsePoints, Js_primitive.null_to_opt(elem.getAttribute("points")))));
        return setAttr("points", Parsers.genPoints(points), elem);
    
  }
}

function getBBox(elem) {
  return Curry._1(Natives.getBoundingClientRect, elem);
}

function getRootLeftTop(rootElem) {
  var rootBox = Curry._1(Natives.getBoundingClientRect, rootElem);
  return /* float array */[
          rootBox.left,
          rootBox.top
        ];
}

function getRootRightBottom(rootElem) {
  var rootBox = Curry._1(Natives.getBoundingClientRect, rootElem);
  return /* float array */[
          rootBox.right,
          rootBox.bottom
        ];
}

function getRootCenter(rootElem) {
  var rootBox = Curry._1(Natives.getBoundingClientRect, rootElem);
  return /* float array */[
          (rootBox.left + rootBox.right) / 2.0,
          (rootBox.top + rootBox.bottom) / 2.0
        ];
}

function getLeftTop(root, elem) {
  var box = Curry._1(Natives.getBoundingClientRect, elem);
  var ground = getRootLeftTop(root);
  return Vec2.$neg$caret(/* float array */[
              box.left,
              box.top
            ], ground);
}

function setLeftTop(vec2, root, elem) {
  var prev = getLeftTop(root, elem);
  var delta = Vec2.$neg$caret(vec2, prev);
  return move(delta, elem);
}

function getRightBottom(root, elem) {
  var box = Curry._1(Natives.getBoundingClientRect, elem);
  var ground = getRootLeftTop(root);
  return Vec2.$neg$caret(/* float array */[
              box.right,
              box.bottom
            ], ground);
}

function getCenter(root, elem) {
  var box = Curry._1(Natives.getBoundingClientRect, elem);
  var ground = getRootLeftTop(root);
  return Vec2.$neg$caret(/* float array */[
              (box.left + box.right) / 2.0,
              (box.top + box.bottom) / 2.0
            ], ground);
}

function setCenter(vec2, root, elem) {
  var delta = Vec2.$neg$caret(vec2, getCenter(root, elem));
  return move(delta, elem);
}

function zoom(ratio, root, elem) {
  var center = getCenter(root, elem);
  var mulK = function (name, k) {
    return changeAttr(name, (function (prevStr) {
                  var prev = Caml_format.caml_float_of_string(prevStr);
                  return Pervasives.string_of_float(prev * k);
                }), elem);
  };
  var match = elem.tagName;
  var exit = 0;
  switch (match) {
    case "circle" : 
        return mulK("r", ratio[/* x */0]);
    case "ellipse" : 
        mulK("rx", ratio[/* x */0]);
        return mulK("ry", ratio[/* y */1]);
    case "line" : 
        mulK("x2", ratio[/* x */0]);
        return mulK("y2", ratio[/* y */1]);
    case "path" : 
        var d = List.map((function (op) {
                return /* record */[
                        /* operator */op[/* operator */0],
                        /* points */List.map((function (p) {
                                return Vec2.$star$caret(p, ratio);
                              }), op[/* points */1])
                      ];
              }), Option.$$default(/* [] */0, Option.map(Parsers.parseD, Js_primitive.null_to_opt(elem.getAttribute("d")))));
        return setAttr("d", Parsers.genD(d), elem);
    case "polygon" : 
    case "polyline" : 
        exit = 2;
        break;
    case "text" : 
        return mulK("font-size", ratio[/* x */0]);
    case "rect" : 
    case "use" : 
        exit = 1;
        break;
    default:
      return setCenter(center, root, elem);
  }
  switch (exit) {
    case 1 : 
        mulK("width", ratio[/* x */0]);
        return mulK("height", ratio[/* y */1]);
    case 2 : 
        var points = List.map((function (p) {
                return Vec2.$star$caret(p, ratio);
              }), Option.$$default(/* [] */0, Option.map(Parsers.parsePoints, Js_primitive.null_to_opt(elem.getAttribute("points")))));
        return setAttr("points", Parsers.genPoints(points), elem);
    
  }
}

function getSize(elem) {
  var box = Curry._1(Natives.getBoundingClientRect, elem);
  return /* float array */[
          box.width,
          box.height
        ];
}

function setSize(vec2, elem) {
  var partial_arg = Vec2.$slash$caret(vec2, getSize(elem));
  return (function (param) {
      return zoom(partial_arg, elem, param);
    });
}

function getFillColor(elem) {
  var style = window.getComputedStyle(elem);
  if (style.fill === "") {
    return /* None */0;
  } else {
    var match = Parsers.parseRgb(style.fill);
    if (typeof match === "number") {
      return /* None */0;
    } else if (match.tag) {
      var rgb = match[0];
      return /* Rgba */Block.__(0, [/* record */[
                  /* r */rgb[/* r */0],
                  /* g */rgb[/* g */1],
                  /* b */rgb[/* b */2],
                  /* a */Caml_format.caml_float_of_string(style.fillOpacity)
                ]]);
    } else {
      return /* None */0;
    }
  }
}

function setFillColor(color, elem) {
  var style = elem.style;
  if (typeof color === "number") {
    style.fill = (null);
    return style.fillOpacity = (null);
  } else if (color.tag) {
    return style.fill = Parsers.genColor(color);
  } else {
    style.fill = Parsers.genColor(color);
    return style.fillOpacity = Pervasives.string_of_float(color[0][/* a */3]);
  }
}

function getStrokeColor(elem) {
  var style = window.getComputedStyle(elem);
  if (style.stroke === "") {
    return /* None */0;
  } else {
    var match = Parsers.parseRgb(style.stroke);
    if (typeof match === "number") {
      return /* None */0;
    } else if (match.tag) {
      var rgb = match[0];
      return /* Rgba */Block.__(0, [/* record */[
                  /* r */rgb[/* r */0],
                  /* g */rgb[/* g */1],
                  /* b */rgb[/* b */2],
                  /* a */Caml_format.caml_float_of_string(style.strokeOpacity)
                ]]);
    } else {
      return /* None */0;
    }
  }
}

function setStrokeColor(color, elem) {
  var style = elem.style;
  if (typeof color === "number") {
    style.stroke = (null);
    return style.strokeOpacity = (null);
  } else if (color.tag) {
    return style.stroke = Parsers.genColor(color);
  } else {
    return style.strokeOpacity = Pervasives.string_of_float(color[0][/* a */3]);
  }
}

function getStyle(prim) {
  return prim.style;
}

exports.getAttr            = getAttr;
exports.setAttr            = setAttr;
exports.changeAttr         = changeAttr;
exports.deleteAttr         = deleteAttr;
exports.move               = move;
exports.getBBox            = getBBox;
exports.getRootLeftTop     = getRootLeftTop;
exports.getRootRightBottom = getRootRightBottom;
exports.getRootCenter      = getRootCenter;
exports.getLeftTop         = getLeftTop;
exports.setLeftTop         = setLeftTop;
exports.getRightBottom     = getRightBottom;
exports.getCenter          = getCenter;
exports.setCenter          = setCenter;
exports.zoom               = zoom;
exports.getSize            = getSize;
exports.setSize            = setSize;
exports.getFillColor       = getFillColor;
exports.setFillColor       = setFillColor;
exports.getStrokeColor     = getStrokeColor;
exports.setStrokeColor     = setStrokeColor;
exports.getStyle           = getStyle;
/* Natives Not a pure module */
