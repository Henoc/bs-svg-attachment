(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';


var getBoundingClientRect = ( x => x.getBoundingClientRect() );

exports.getBoundingClientRect = getBoundingClientRect;
/* getBoundingClientRect Not a pure module */

},{}],2:[function(require,module,exports){
// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List         = require("bs-platform/lib/js/list.js");
var $$Array      = require("bs-platform/lib/js/array.js");
var Block        = require("bs-platform/lib/js/block.js");
var Caml_array   = require("bs-platform/lib/js/caml_array.js");
var Pervasives   = require("bs-platform/lib/js/pervasives.js");
var Caml_format  = require("bs-platform/lib/js/caml_format.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");

function next(regex, s) {
  var resultOpt = regex.exec(s);
  if (resultOpt !== null) {
    return Js_primitive.null_undefined_to_opt(Caml_array.caml_array_get(resultOpt, 0));
  } else {
    return /* None */0;
  }
}

function getAllFloats(s) {
  var floatRegex = (/[+-]?[0-9]+(\.[0-9]*)?([eE][+-]?[0-9]+)?/g);
  var loop = function (s, _acc) {
    while(true) {
      var acc = _acc;
      var match = next(floatRegex, s);
      if (match) {
        _acc = /* :: */[
          match[0],
          acc
        ];
        continue ;
        
      } else {
        return acc;
      }
    };
  };
  return List.map(Caml_format.caml_float_of_string, List.rev(loop(s, /* [] */0)));
}

function getAllInts(s) {
  var intRegex = (/[+-]?\d+/g);
  var loop = function (s, _acc) {
    while(true) {
      var acc = _acc;
      var match = next(intRegex, s);
      if (match) {
        _acc = /* :: */[
          match[0],
          acc
        ];
        continue ;
        
      } else {
        return acc;
      }
    };
  };
  return List.map(Caml_format.caml_int_of_string, List.rev(loop(s, /* [] */0)));
}

function parseRgb(s) {
  var ints = $$Array.of_list(getAllInts(s));
  return /* Rgb */Block.__(1, [/* record */[
              /* r */Caml_array.caml_array_get(ints, 0),
              /* g */Caml_array.caml_array_get(ints, 1),
              /* b */Caml_array.caml_array_get(ints, 2)
            ]]);
}

function parseRgba(s) {
  var floats = $$Array.of_list(getAllFloats(s));
  return /* Rgba */Block.__(0, [/* record */[
              /* r */Caml_array.caml_array_get(floats, 0) | 0,
              /* g */Caml_array.caml_array_get(floats, 1) | 0,
              /* b */Caml_array.caml_array_get(floats, 2) | 0,
              /* a */Caml_array.caml_array_get(floats, 3)
            ]]);
}

function genColor(color) {
  if (typeof color === "number") {
    return "none";
  } else if (color.tag) {
    var rgb = color[0];
    return "rgb(" + (Pervasives.string_of_int(rgb[/* r */0]) + ("," + (Pervasives.string_of_int(rgb[/* g */1]) + ("," + (Pervasives.string_of_int(rgb[/* b */2]) + ")")))));
  } else {
    var rgba = color[0];
    return "rgba(" + (Pervasives.string_of_int(rgba[/* r */0]) + ("," + (Pervasives.string_of_int(rgba[/* g */1]) + ("," + (Pervasives.string_of_int(rgba[/* b */2]) + ("," + (Pervasives.string_of_float(rgba[/* a */3]) + ")")))))));
  }
}

function parsePoints(s) {
  var floats = getAllFloats(s);
  var loop = function (_floats, _acc) {
    while(true) {
      var acc = _acc;
      var floats = _floats;
      if (floats) {
        var match = floats[1];
        if (match) {
          _acc = /* :: */[
            /* float array */[
              floats[0],
              match[0]
            ],
            acc
          ];
          _floats = match[1];
          continue ;
          
        } else {
          return acc;
        }
      } else {
        return acc;
      }
    };
  };
  return List.rev(loop(floats, /* [] */0));
}

function genPoints(points) {
  var toStr = function (vec2) {
    return Pervasives.string_of_float(vec2[/* x */0]) + (" " + Pervasives.string_of_float(vec2[/* y */1]));
  };
  var _points = List.tl(points);
  var _acc = toStr(List.hd(points));
  while(true) {
    var acc = _acc;
    var points$1 = _points;
    if (points$1) {
      _acc = acc + (", " + toStr(points$1[0]));
      _points = points$1[1];
      continue ;
      
    } else {
      return acc;
    }
  };
}

function parseD(s) {
  var loop2 = function (regex, _acc) {
    while(true) {
      var acc = _acc;
      var match = next(regex, s);
      if (match) {
        var match$1 = next(regex, s);
        if (match$1) {
          _acc = /* :: */[
            /* float array */[
              Caml_format.caml_float_of_string(match[0]),
              Caml_format.caml_float_of_string(match$1[0])
            ],
            acc
          ];
          continue ;
          
        } else {
          return acc;
        }
      } else {
        return acc;
      }
    };
  };
  var loop = function (regex, _acc) {
    while(true) {
      var acc = _acc;
      var match = next(regex, s);
      if (match) {
        var sepFloatRegex = (/^[,\s]+[+-]?[0-9]+(\.[0-9]*)?([eE][+-]?[0-9]+)?/g);
        var points = loop2(sepFloatRegex, /* [] */0);
        _acc = /* :: */[
          /* record */[
            /* operator */match[0],
            /* points */points
          ],
          acc
        ];
        continue ;
        
      } else {
        return acc;
      }
    };
  };
  var dOperator = (/[mMlLhHvVaAqQtTcCsSzZ]/g);
  return List.rev(loop(dOperator, /* [] */0));
}

function genD(operators) {
  var toStr = function (op) {
    return op[/* operator */0] + (" " + genPoints(op[/* points */1]));
  };
  var _ops = List.tl(operators);
  var _acc = toStr(List.hd(operators));
  while(true) {
    var acc = _acc;
    var ops = _ops;
    if (ops) {
      _acc = acc + (", " + toStr(ops[0]));
      _ops = ops[1];
      continue ;
      
    } else {
      return acc;
    }
  };
}

exports.next         = next;
exports.getAllFloats = getAllFloats;
exports.getAllInts   = getAllInts;
exports.parseRgb     = parseRgb;
exports.parseRgba    = parseRgba;
exports.genColor     = genColor;
exports.parsePoints  = parsePoints;
exports.genPoints    = genPoints;
exports.parseD       = parseD;
exports.genD         = genD;
/* No side effect */

},{"bs-platform/lib/js/array.js":9,"bs-platform/lib/js/block.js":11,"bs-platform/lib/js/caml_array.js":12,"bs-platform/lib/js/caml_format.js":15,"bs-platform/lib/js/js_primitive.js":32,"bs-platform/lib/js/list.js":33,"bs-platform/lib/js/pervasives.js":36}],3:[function(require,module,exports){
// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List         = require("bs-platform/lib/js/list.js");
var Vec2         = require("./vec2.bs.js");
var Block        = require("bs-platform/lib/js/block.js");
var Curry        = require("bs-platform/lib/js/curry.js");
var Option       = require("bs-batteries/lib/js/src/option.js");
var Natives      = require("./natives.bs.js");
var Parsers      = require("./parsers.bs.js");
var Pervasives   = require("bs-platform/lib/js/pervasives.js");
var Caml_format  = require("bs-platform/lib/js/caml_format.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");

function getAttr(name, t) {
  return Js_primitive.null_to_opt(t[/* elem */1].getAttribute(name));
}

function setAttr(name, value, t) {
  t[/* elem */1].setAttribute(name, value);
  return /* () */0;
}

function changeAttr(name, valueTranslator, t) {
  var prev = getAttr(name, t);
  var match = Option.map(valueTranslator, prev);
  if (match) {
    t[/* elem */1].setAttribute(name, match[0]);
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function deleteAttr(name, t) {
  t[/* elem */1].setAttribute(name, ( null ));
  return /* () */0;
}

function move(delta, t) {
  var tx = function (prev) {
    return Pervasives.string_of_float(Caml_format.caml_float_of_string(prev) + delta[/* x */0]);
  };
  var ty = function (prev) {
    return Pervasives.string_of_float(Caml_format.caml_float_of_string(prev) + delta[/* y */1]);
  };
  var match = t[/* elem */1].tagName;
  var exit = 0;
  switch (match) {
    case "circle" : 
    case "ellipse" : 
        exit = 1;
        break;
    case "line" : 
        changeAttr("x1", tx, t);
        changeAttr("y1", ty, t);
        changeAttr("x2", tx, t);
        return changeAttr("y2", ty, t);
    case "path" : 
        var d = List.map((function (op) {
                return /* record */[
                        /* operator */op[/* operator */0],
                        /* points */List.map((function (p) {
                                return Vec2.$plus$caret(p, delta);
                              }), op[/* points */1])
                      ];
              }), Option.$$default(/* [] */0, Option.map(Parsers.parseD, getAttr("d", t))));
        return setAttr("d", Parsers.genD(d), t);
    case "polygon" : 
    case "polyline" : 
        exit = 3;
        break;
    case "image" : 
    case "rect" : 
    case "text" : 
    case "use" : 
        exit = 2;
        break;
    default:
      return /* () */0;
  }
  switch (exit) {
    case 1 : 
        changeAttr("cx", tx, t);
        return changeAttr("cy", ty, t);
    case 2 : 
        changeAttr("x", tx, t);
        return changeAttr("y", ty, t);
    case 3 : 
        var points = List.map((function (p) {
                return Vec2.$plus$caret(p, delta);
              }), Option.$$default(/* [] */0, Option.map(Parsers.parsePoints, getAttr("points", t))));
        return setAttr("points", Parsers.genPoints(points), t);
    
  }
}

function getBBox(t) {
  return Curry._1(Natives.getBoundingClientRect, t[/* elem */1]);
}

function getRootLeftTop(t) {
  var rootBox = Curry._1(Natives.getBoundingClientRect, t[/* rootElem */0]);
  return /* float array */[
          rootBox.left,
          rootBox.top
        ];
}

function getRootRightBottom(t) {
  var rootBox = Curry._1(Natives.getBoundingClientRect, t[/* rootElem */0]);
  return /* float array */[
          rootBox.right,
          rootBox.bottom
        ];
}

function getRootCenter(t) {
  var rootBox = Curry._1(Natives.getBoundingClientRect, t[/* rootElem */0]);
  return /* float array */[
          (rootBox.left + rootBox.right) / 2.0,
          (rootBox.top + rootBox.bottom) / 2.0
        ];
}

function getLeftTop(t) {
  var box = Curry._1(Natives.getBoundingClientRect, t[/* elem */1]);
  var ground = getRootLeftTop(t);
  return Vec2.$neg$caret(/* float array */[
              box.left,
              box.top
            ], ground);
}

function setLeftTop(vec2, t) {
  var prev = getLeftTop(t);
  var delta = Vec2.$neg$caret(vec2, prev);
  return move(delta, t);
}

function getRightBottom(t) {
  var box = Curry._1(Natives.getBoundingClientRect, t[/* elem */1]);
  var ground = getRootLeftTop(t);
  return Vec2.$neg$caret(/* float array */[
              box.right,
              box.bottom
            ], ground);
}

function getCenter(t) {
  var box = Curry._1(Natives.getBoundingClientRect, t[/* elem */1]);
  var ground = getRootLeftTop(t);
  return Vec2.$neg$caret(/* float array */[
              (box.left + box.right) / 2.0,
              (box.top + box.bottom) / 2.0
            ], ground);
}

function setCenter(vec2, t) {
  var delta = Vec2.$neg$caret(vec2, getCenter(t));
  return move(delta, t);
}

function zoom(ratio, t) {
  var center = getCenter(t);
  var mulK = function (name, k) {
    return changeAttr(name, (function (prevStr) {
                  var prev = Caml_format.caml_float_of_string(prevStr);
                  return Pervasives.string_of_float(prev * k);
                }), t);
  };
  var match = t[/* elem */1].tagName;
  var exit = 0;
  switch (match) {
    case "circle" : 
        return mulK("r", ratio[/* x */0]);
    case "ellipse" : 
        mulK("rx", ratio[/* x */0]);
        return mulK("ry", ratio[/* y */1]);
    case "line" : 
        mulK("x2", ratio[/* x */0]);
        return mulK("y2", ratio[/* y */1]);
    case "path" : 
        var d = List.map((function (op) {
                return /* record */[
                        /* operator */op[/* operator */0],
                        /* points */List.map((function (p) {
                                return Vec2.$star$caret(p, ratio);
                              }), op[/* points */1])
                      ];
              }), Option.$$default(/* [] */0, Option.map(Parsers.parseD, getAttr("d", t))));
        return setAttr("d", Parsers.genD(d), t);
    case "polygon" : 
    case "polyline" : 
        exit = 2;
        break;
    case "text" : 
        return mulK("font-size", ratio[/* x */0]);
    case "rect" : 
    case "use" : 
        exit = 1;
        break;
    default:
      return setCenter(center, t);
  }
  switch (exit) {
    case 1 : 
        mulK("width", ratio[/* x */0]);
        return mulK("height", ratio[/* y */1]);
    case 2 : 
        var points = List.map((function (p) {
                return Vec2.$star$caret(p, ratio);
              }), Option.$$default(/* [] */0, Option.map(Parsers.parsePoints, getAttr("points", t))));
        return setAttr("points", Parsers.genPoints(points), t);
    
  }
}

function getSize(t) {
  var box = Curry._1(Natives.getBoundingClientRect, t[/* elem */1]);
  return /* float array */[
          box.width,
          box.height
        ];
}

function setSize(vec2, t) {
  return zoom(Vec2.$slash$caret(vec2, getSize(t)), t);
}

function getFillColor(t) {
  var style = window.getComputedStyle(t[/* elem */1]);
  if (style.fill === "") {
    return /* None */0;
  } else {
    var match = Parsers.parseRgb(style.fill);
    if (typeof match === "number") {
      return /* None */0;
    } else if (match.tag) {
      var rgb = match[0];
      return /* Rgba */Block.__(0, [/* record */[
                  /* r */rgb[/* r */0],
                  /* g */rgb[/* g */1],
                  /* b */rgb[/* b */2],
                  /* a */Caml_format.caml_float_of_string(style.fillOpacity)
                ]]);
    } else {
      return /* None */0;
    }
  }
}

function setFillColor(color, t) {
  var style = t.getStyle;
  if (typeof color === "number") {
    style.fill = (null);
    return style.fillOpacity = (null);
  } else if (color.tag) {
    return style.fill = Parsers.genColor(color);
  } else {
    return style.fillOpacity = Pervasives.string_of_float(color[0][/* a */3]);
  }
}

function getStrokeColor(t) {
  var style = window.getComputedStyle(t[/* elem */1]);
  if (style.stroke === "") {
    return /* None */0;
  } else {
    var match = Parsers.parseRgb(style.stroke);
    if (typeof match === "number") {
      return /* None */0;
    } else if (match.tag) {
      var rgb = match[0];
      return /* Rgba */Block.__(0, [/* record */[
                  /* r */rgb[/* r */0],
                  /* g */rgb[/* g */1],
                  /* b */rgb[/* b */2],
                  /* a */Caml_format.caml_float_of_string(style.strokeOpacity)
                ]]);
    } else {
      return /* None */0;
    }
  }
}

function setStrokeColor(color, t) {
  var style = t.getStyle;
  if (typeof color === "number") {
    style.stroke = (null);
    return style.strokeOpacity = (null);
  } else if (color.tag) {
    return style.stroke = Parsers.genColor(color);
  } else {
    return style.strokeOpacity = Pervasives.string_of_float(color[0][/* a */3]);
  }
}

function getStyle(prim) {
  return prim.getStyle;
}

exports.getAttr            = getAttr;
exports.setAttr            = setAttr;
exports.changeAttr         = changeAttr;
exports.deleteAttr         = deleteAttr;
exports.move               = move;
exports.getBBox            = getBBox;
exports.getRootLeftTop     = getRootLeftTop;
exports.getRootRightBottom = getRootRightBottom;
exports.getRootCenter      = getRootCenter;
exports.getLeftTop         = getLeftTop;
exports.setLeftTop         = setLeftTop;
exports.getRightBottom     = getRightBottom;
exports.getCenter          = getCenter;
exports.setCenter          = setCenter;
exports.zoom               = zoom;
exports.getSize            = getSize;
exports.setSize            = setSize;
exports.getFillColor       = getFillColor;
exports.setFillColor       = setFillColor;
exports.getStrokeColor     = getStrokeColor;
exports.setStrokeColor     = setStrokeColor;
exports.getStyle           = getStyle;
/* Natives Not a pure module */

},{"./natives.bs.js":1,"./parsers.bs.js":2,"./vec2.bs.js":4,"bs-batteries/lib/js/src/option.js":8,"bs-platform/lib/js/block.js":11,"bs-platform/lib/js/caml_format.js":15,"bs-platform/lib/js/curry.js":30,"bs-platform/lib/js/js_primitive.js":32,"bs-platform/lib/js/list.js":33,"bs-platform/lib/js/pervasives.js":36}],4:[function(require,module,exports){
// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';


function $plus$caret(a, b) {
  return /* float array */[
          a[/* x */0] + b[/* x */0],
          a[/* y */1] + b[/* y */1]
        ];
}

function $neg$caret(a, b) {
  return /* float array */[
          a[/* x */0] - b[/* x */0],
          a[/* y */1] - b[/* y */1]
        ];
}

function $star$caret(a, b) {
  return /* float array */[
          a[/* x */0] * b[/* x */0],
          a[/* y */1] * b[/* y */1]
        ];
}

function $slash$caret(a, b) {
  return /* float array */[
          a[/* x */0] / b[/* x */0],
          a[/* y */1] / b[/* y */1]
        ];
}

exports.$plus$caret  = $plus$caret;
exports.$neg$caret   = $neg$caret;
exports.$star$caret  = $star$caret;
exports.$slash$caret = $slash$caret;
/* No side effect */

},{}],5:[function(require,module,exports){
// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var Pervasives      = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var AssertionError = Caml_exceptions.create("Mocha.AssertionError");

function shouldTrue(label, value) {
  if (value) {
    return 0;
  } else {
    throw [
          AssertionError,
          "at " + label
        ];
  }
}

function floatEq(label, value1, value2) {
  if (value1 !== value2) {
    var v1str = Pervasives.string_of_float(value1);
    var v2str = Pervasives.string_of_float(value2);
    throw [
          AssertionError,
          "at " + (label + (", " + (v1str + (" not equal " + v2str))))
        ];
  } else {
    return 0;
  }
}

function intEq(label, value1, value2) {
  if (value1 !== value2) {
    var v1str = Pervasives.string_of_int(value1);
    var v2str = Pervasives.string_of_int(value2);
    throw [
          AssertionError,
          "at " + (label + (", " + (v1str + (" not equal " + v2str))))
        ];
  } else {
    return 0;
  }
}

function fail(label) {
  throw [
        AssertionError,
        "at " + label
      ];
}

exports.AssertionError = AssertionError;
exports.shouldTrue     = shouldTrue;
exports.floatEq        = floatEq;
exports.intEq          = intEq;
exports.fail           = fail;
/* No side effect */

},{"bs-platform/lib/js/caml_exceptions.js":14,"bs-platform/lib/js/pervasives.js":36}],6:[function(require,module,exports){
// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var Svg          = require("../src/svg.bs.js");
var Mocha        = require("./mocha.bs.js");
var Option       = require("bs-batteries/lib/js/src/option.js");
var ElementRe    = require("bs-webapi/lib/js/src/dom/nodes/ElementRe.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");

var svgOpt = document.getElementById("svg");

var svgroot = Option.get(svgOpt === null ? /* None */0 : [svgOpt]);

ElementRe.insertAdjacentHTML(/* AfterBegin */1, "<circle id=\"c\" cx=\"20\" cy=\"20\" r=\"10\" style=\"fill: rgb(60, 120, 5); fill-opacity: 0.5\"></circle>", svgroot);

var circle_001 = /* elem */Option.get(Js_primitive.null_to_opt(document.getElementById("c")));

var circle = /* record */[
  /* rootElem */svgroot,
  circle_001
];

it("coordinates", (function () {
        var leftTop = Svg.getLeftTop(circle);
        var center = Svg.getCenter(circle);
        var rightBottom = Svg.getRightBottom(circle);
        Mocha.floatEq("leftTop", leftTop[/* x */0], 10.0);
        Mocha.floatEq("center", center[/* x */0], 20.0);
        return Mocha.floatEq("rightBottom", rightBottom[/* x */0], 30.0);
      }));

it("color", (function () {
        var fillColor = Svg.getFillColor(circle);
        if (typeof fillColor === "number") {
          return Mocha.fail("not Rgba");
        } else if (fillColor.tag) {
          return Mocha.fail("not Rgba");
        } else {
          var rgba = fillColor[0];
          Mocha.intEq("color r", rgba[/* r */0], 60);
          Mocha.intEq("color g", rgba[/* g */1], 120);
          Mocha.intEq("color b", rgba[/* b */2], 5);
          return Mocha.floatEq("color a", rgba[/* a */3], 0.5);
        }
      }));

/* svgOpt Not a pure module */

},{"../src/svg.bs.js":3,"./mocha.bs.js":5,"bs-batteries/lib/js/src/option.js":8,"bs-platform/lib/js/js_primitive.js":32,"bs-webapi/lib/js/src/dom/nodes/ElementRe.js":41}],7:[function(require,module,exports){
// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var Char                    = require("bs-platform/lib/js/char.js");
var List                    = require("bs-platform/lib/js/list.js");
var $$Array                 = require("bs-platform/lib/js/array.js");
var Block                   = require("bs-platform/lib/js/block.js");
var Curry                   = require("bs-platform/lib/js/curry.js");
var Queue                   = require("bs-platform/lib/js/queue.js");
var Caml_obj                = require("bs-platform/lib/js/caml_obj.js");
var Caml_array              = require("bs-platform/lib/js/caml_array.js");
var Caml_int32              = require("bs-platform/lib/js/caml_int32.js");
var Pervasives              = require("bs-platform/lib/js/pervasives.js");
var ArrayLabels             = require("bs-platform/lib/js/arrayLabels.js");
var Caml_oo_curry           = require("bs-platform/lib/js/caml_oo_curry.js");
var CamlinternalOO          = require("bs-platform/lib/js/camlinternalOO.js");
var Caml_exceptions         = require("bs-platform/lib/js/caml_exceptions.js");
var CamlinternalLazy        = require("bs-platform/lib/js/camlinternalLazy.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var No_more_elements = Caml_exceptions.create("BatEnum.No_more_elements");

function make(next, count, clone) {
  return /* record */[
          /* count */count,
          /* next */next,
          /* clone */clone,
          /* fast : true */1
        ];
}

function _dummy() {
  throw [
        Caml_builtin_exceptions.assert_failure,
        [
          "batEnum.ml",
          49,
          16
        ]
      ];
}

var Infinite_enum = Caml_exceptions.create("BatEnum.Infinite_enum");

function return_no_more_elements() {
  throw No_more_elements;
}

function return_no_more_count() {
  return 0;
}

function return_infinite_count() {
  throw Infinite_enum;
}

function empty() {
  return /* record */[
          /* count */return_no_more_count,
          /* next */return_no_more_elements,
          /* clone */empty,
          /* fast : true */1
        ];
}

function close(e) {
  e[/* next */1] = return_no_more_elements;
  e[/* count */0] = return_no_more_count;
  e[/* clone */2] = empty;
  return /* () */0;
}

function force(t) {
  var clone = function ($$enum, count) {
    var $$enum$1 = [$$enum[0]];
    var count$1 = [count[0]];
    return /* record */[
            /* count */(function () {
                return count$1[0];
              }),
            /* next */(function () {
                var match = $$enum$1[0];
                if (match) {
                  count$1[0] = count$1[0] - 1 | 0;
                  $$enum$1[0] = match[1];
                  return match[0];
                } else {
                  throw No_more_elements;
                }
              }),
            /* clone */(function () {
                var $$enum$2 = [$$enum$1[0]];
                var count$2 = [count$1[0]];
                return clone($$enum$2, count$2);
              }),
            /* fast : true */1
          ];
  };
  var count = [0];
  var loop = function (_dst) {
    while(true) {
      var dst = _dst;
      var x = /* record */[
        /* hd */Curry._1(t[/* next */1], /* () */0),
        /* tl : [] */0
      ];
      count[0] = count[0] + 1 | 0;
      dst[/* tl */1] = x;
      _dst = x;
      continue ;
      
    };
  };
  var $$enum = [/* [] */0];
  try {
    $$enum[0] = /* record */[
      /* hd */Curry._1(t[/* next */1], /* () */0),
      /* tl : [] */0
    ];
    count[0] = count[0] + 1 | 0;
    loop($$enum[0]);
  }
  catch (exn){
    if (exn !== No_more_elements) {
      throw exn;
    }
    
  }
  var tc = clone($$enum, count);
  t[/* clone */2] = tc[/* clone */2];
  t[/* next */1] = tc[/* next */1];
  t[/* count */0] = tc[/* count */0];
  t[/* fast */3] = /* true */1;
  return /* () */0;
}

function $$enum(l) {
  var aux = function (l) {
    var reference = [l];
    var e = make((function () {
            var lzarg = reference[0];
            var tag = lzarg.tag | 0;
            var match = tag === 250 ? lzarg[0] : (
                tag === 246 ? CamlinternalLazy.force_lazy_block(lzarg) : lzarg
              );
            if (match) {
              reference[0] = match[1];
              return match[0];
            } else {
              throw No_more_elements;
            }
          }), _dummy, (function () {
            return aux(reference[0]);
          }));
    e[/* count */0] = (function () {
        force(e);
        return Curry._1(e[/* count */0], /* () */0);
      });
    e[/* fast */3] = /* false */0;
    return e;
  };
  return aux(l);
}

function from(f) {
  var aux = function () {
    return Block.__(246, [(function () {
                  var item;
                  try {
                    item = /* Some */[Curry._1(f, /* () */0)];
                  }
                  catch (exn){
                    if (exn === No_more_elements) {
                      item = /* None */0;
                    } else {
                      throw exn;
                    }
                  }
                  if (item) {
                    return /* Cons */[
                            item[0],
                            aux(/* () */0)
                          ];
                  } else {
                    return /* Nil */0;
                  }
                })]);
  };
  return aux(/* () */0);
}

function from$1(f) {
  var e = /* record */[
    /* count */_dummy,
    /* next */_dummy,
    /* clone */_dummy,
    /* fast : false */0
  ];
  e[/* next */1] = (function () {
      try {
        return Curry._1(f, /* () */0);
      }
      catch (exn){
        if (exn === No_more_elements) {
          close(e);
          throw No_more_elements;
        } else {
          throw exn;
        }
      }
    });
  e[/* count */0] = (function () {
      force(e);
      return Curry._1(e[/* count */0], /* () */0);
    });
  e[/* clone */2] = (function () {
      var e$prime = $$enum(from(f));
      e[/* next */1] = e$prime[/* next */1];
      e[/* clone */2] = e$prime[/* clone */2];
      e[/* count */0] = (function () {
          force(e);
          return Curry._1(e[/* count */0], /* () */0);
        });
      e[/* fast */3] = e$prime[/* fast */3];
      return Curry._1(e[/* clone */2], /* () */0);
    });
  return e;
}

function from2(next, clone) {
  var e = /* record */[
    /* count */_dummy,
    /* next */next,
    /* clone */clone,
    /* fast : false */0
  ];
  e[/* count */0] = (function () {
      force(e);
      return Curry._1(e[/* count */0], /* () */0);
    });
  return e;
}

function init(n, f) {
  if (n < 0) {
    Pervasives.invalid_arg("BatEnum.init");
  }
  var count = [n];
  var f$prime = function () {
    var match = count[0];
    if (match !== 0) {
      count[0] = count[0] - 1 | 0;
      return Curry._1(f, (n - 1 | 0) - count[0] | 0);
    } else {
      throw No_more_elements;
    }
  };
  var e = from$1(f$prime);
  e[/* fast */3] = /* true */1;
  e[/* count */0] = (function () {
      return count[0];
    });
  return e;
}

function get(t) {
  try {
    return /* Some */[Curry._1(t[/* next */1], /* () */0)];
  }
  catch (exn){
    if (exn === No_more_elements) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function get_exn(t) {
  return Curry._1(t[/* next */1], /* () */0);
}

function push(t, e) {
  var make = function (t) {
    var fnext = t[/* next */1];
    var fcount = t[/* count */0];
    var fclone = t[/* clone */2];
    var next_called = [/* false */0];
    t[/* next */1] = (function () {
        next_called[0] = /* true */1;
        t[/* next */1] = fnext;
        t[/* count */0] = fcount;
        t[/* clone */2] = fclone;
        return e;
      });
    t[/* count */0] = (function () {
        var n = Curry._1(fcount, /* () */0);
        if (next_called[0]) {
          return n;
        } else {
          return n + 1 | 0;
        }
      });
    t[/* clone */2] = (function () {
        var tc = Curry._1(fclone, /* () */0);
        if (!next_called[0]) {
          make(tc);
        }
        return tc;
      });
    return /* () */0;
  };
  return make(t);
}

function peek(t) {
  var match = get(t);
  if (match) {
    var x = match[0];
    push(t, x);
    return /* Some */[x];
  } else {
    return /* None */0;
  }
}

function take(n, e) {
  var r = /* [] */0;
  try {
    for(var i = 1; i <= n; ++i){
      r = /* :: */[
        Curry._1(e[/* next */1], /* () */0),
        r
      ];
    }
  }
  catch (exn){
    if (exn !== No_more_elements) {
      throw exn;
    }
    
  }
  var l = List.rev(r);
  var aux = function (lr, count) {
    return make((function () {
                  var match = lr[0];
                  if (match) {
                    count[0] = count[0] - 1 | 0;
                    lr[0] = match[1];
                    return match[0];
                  } else {
                    throw No_more_elements;
                  }
                }), (function () {
                  if (count[0] < 0) {
                    count[0] = List.length(lr[0]);
                  }
                  return count[0];
                }), (function () {
                  return aux([lr[0]], [count[0]]);
                }));
  };
  return aux([l], [-1]);
}

function junk(t) {
  try {
    Curry._1(t[/* next */1], /* () */0);
    return /* () */0;
  }
  catch (exn){
    if (exn === No_more_elements) {
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

function is_empty(t) {
  if (t[/* fast */3]) {
    return +(Curry._1(t[/* count */0], /* () */0) === 0);
  } else {
    return +(peek(t) === /* None */0);
  }
}

function count(t) {
  return Curry._1(t[/* count */0], /* () */0);
}

function fast_count(t) {
  return t[/* fast */3];
}

function clone(t) {
  return Curry._1(t[/* clone */2], /* () */0);
}

function iter(f, t) {
  try {
    var _param = /* () */0;
    while(true) {
      Curry._1(f, Curry._1(t[/* next */1], /* () */0));
      _param = /* () */0;
      continue ;
      
    };
  }
  catch (exn){
    if (exn === No_more_elements) {
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

function iteri(f, t) {
  try {
    var _idx = 0;
    while(true) {
      var idx = _idx;
      Curry._2(f, idx, Curry._1(t[/* next */1], /* () */0));
      _idx = idx + 1 | 0;
      continue ;
      
    };
  }
  catch (exn){
    if (exn === No_more_elements) {
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

function iter2(f, t, u) {
  var push_t = [/* None */0];
  try {
    var _param = /* () */0;
    while(true) {
      push_t[0] = /* None */0;
      var e = Curry._1(t[/* next */1], /* () */0);
      push_t[0] = /* Some */[e];
      Curry._2(f, e, Curry._1(u[/* next */1], /* () */0));
      _param = /* () */0;
      continue ;
      
    };
  }
  catch (exn){
    if (exn === No_more_elements) {
      var match = push_t[0];
      if (match) {
        return push(t, match[0]);
      } else {
        return /* () */0;
      }
    } else {
      throw exn;
    }
  }
}

function iter2i(f, t, u) {
  var push_t = [/* None */0];
  try {
    var _idx = 0;
    while(true) {
      var idx = _idx;
      push_t[0] = /* None */0;
      var e = Curry._1(t[/* next */1], /* () */0);
      push_t[0] = /* Some */[e];
      Curry._3(f, idx, e, Curry._1(u[/* next */1], /* () */0));
      _idx = idx + 1 | 0;
      continue ;
      
    };
  }
  catch (exn){
    if (exn === No_more_elements) {
      var match = push_t[0];
      if (match) {
        return push(t, match[0]);
      } else {
        return /* () */0;
      }
    } else {
      throw exn;
    }
  }
}

function fold(f, init, t) {
  var acc = [init];
  try {
    var _param = /* () */0;
    while(true) {
      acc[0] = Curry._2(f, acc[0], Curry._1(t[/* next */1], /* () */0));
      _param = /* () */0;
      continue ;
      
    };
  }
  catch (exn){
    if (exn === No_more_elements) {
      return acc[0];
    } else {
      throw exn;
    }
  }
}

function reduce(f, t) {
  var match = get(t);
  if (match) {
    return fold(f, match[0], t);
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function sum(t) {
  var match = get(t);
  if (match) {
    return fold((function (prim, prim$1) {
                  return prim + prim$1 | 0;
                }), match[0], t);
  } else {
    return 0;
  }
}

function fsum(t) {
  var match = get(t);
  if (match) {
    var sum = [match[0]];
    var c = [0];
    iter((function (x) {
            var y = x - c[0];
            var t = sum[0] + y;
            c[0] = t - sum[0] - y;
            sum[0] = t;
            return /* () */0;
          }), t);
    return sum[0];
  } else {
    return 0;
  }
}

function exists(f, t) {
  try {
    var _param = /* () */0;
    while(true) {
      if (Curry._1(f, Curry._1(t[/* next */1], /* () */0))) {
        return /* true */1;
      } else {
        _param = /* () */0;
        continue ;
        
      }
    };
  }
  catch (exn){
    if (exn === No_more_elements) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function for_all(f, t) {
  try {
    var _param = /* () */0;
    while(true) {
      if (Curry._1(f, Curry._1(t[/* next */1], /* () */0))) {
        _param = /* () */0;
        continue ;
        
      } else {
        return /* false */0;
      }
    };
  }
  catch (exn){
    if (exn === No_more_elements) {
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

function scanl(f, init, t) {
  var acc = [init];
  var gen = function () {
    acc[0] = Curry._2(f, acc[0], Curry._1(t[/* next */1], /* () */0));
    return acc[0];
  };
  var e = from$1(gen);
  push(e, init);
  return e;
}

function scan(f, t) {
  var match = get(t);
  if (match) {
    return scanl(f, match[0], t);
  } else {
    return empty(/* () */0);
  }
}

function foldi(f, init, t) {
  var acc = [init];
  try {
    var _idx = 0;
    while(true) {
      var idx = _idx;
      acc[0] = Curry._3(f, idx, Curry._1(t[/* next */1], /* () */0), acc[0]);
      _idx = idx + 1 | 0;
      continue ;
      
    };
  }
  catch (exn){
    if (exn === No_more_elements) {
      return acc[0];
    } else {
      throw exn;
    }
  }
}

function fold2(f, init, t, u) {
  var acc = [init];
  var push_t = [/* None */0];
  try {
    var _param = /* () */0;
    while(true) {
      push_t[0] = /* None */0;
      var e = Curry._1(t[/* next */1], /* () */0);
      push_t[0] = /* Some */[e];
      acc[0] = Curry._3(f, e, Curry._1(u[/* next */1], /* () */0), acc[0]);
      _param = /* () */0;
      continue ;
      
    };
  }
  catch (exn){
    if (exn === No_more_elements) {
      var match = push_t[0];
      if (match) {
        push(t, match[0]);
        return acc[0];
      } else {
        return acc[0];
      }
    } else {
      throw exn;
    }
  }
}

function fold2i(f, init, t, u) {
  var acc = [init];
  var push_t = [/* None */0];
  try {
    var _idx = 0;
    while(true) {
      var idx = _idx;
      push_t[0] = /* None */0;
      var e = Curry._1(t[/* next */1], /* () */0);
      push_t[0] = /* Some */[e];
      acc[0] = Curry._4(f, idx, e, Curry._1(u[/* next */1], /* () */0), acc[0]);
      _idx = idx + 1 | 0;
      continue ;
      
    };
  }
  catch (exn){
    if (exn === No_more_elements) {
      var match = push_t[0];
      if (match) {
        push(t, match[0]);
        return acc[0];
      } else {
        return acc[0];
      }
    } else {
      throw exn;
    }
  }
}

function find(f, t) {
  try {
    var _param = /* () */0;
    while(true) {
      var x = Curry._1(t[/* next */1], /* () */0);
      if (Curry._1(f, x)) {
        return x;
      } else {
        _param = /* () */0;
        continue ;
        
      }
    };
  }
  catch (exn){
    if (exn === No_more_elements) {
      throw Caml_builtin_exceptions.not_found;
    } else {
      throw exn;
    }
  }
}

function find_map(f, t) {
  try {
    var _param = /* () */0;
    while(true) {
      var match = Curry._1(f, Curry._1(t[/* next */1], /* () */0));
      if (match) {
        return match[0];
      } else {
        _param = /* () */0;
        continue ;
        
      }
    };
  }
  catch (exn){
    if (exn === No_more_elements) {
      throw Caml_builtin_exceptions.not_found;
    } else {
      throw exn;
    }
  }
}

function map(f, t) {
  return /* record */[
          /* count */t[/* count */0],
          /* next */(function () {
              return Curry._1(f, Curry._1(t[/* next */1], /* () */0));
            }),
          /* clone */(function () {
              return map(f, Curry._1(t[/* clone */2], /* () */0));
            }),
          /* fast */t[/* fast */3]
        ];
}

function mapi(f, t) {
  var idx = [-1];
  return /* record */[
          /* count */t[/* count */0],
          /* next */(function () {
              idx[0] = idx[0] + 1 | 0;
              return Curry._2(f, idx[0], Curry._1(t[/* next */1], /* () */0));
            }),
          /* clone */(function () {
              return mapi(f, Curry._1(t[/* clone */2], /* () */0));
            }),
          /* fast */t[/* fast */3]
        ];
}

function filter(f, t) {
  var next = function (_param) {
    while(true) {
      var x = Curry._1(t[/* next */1], /* () */0);
      if (Curry._1(f, x)) {
        return x;
      } else {
        _param = /* () */0;
        continue ;
        
      }
    };
  };
  return from2(next, (function () {
                return filter(f, Curry._1(t[/* clone */2], /* () */0));
              }));
}

function filter_map(f, t) {
  var next = function (_param) {
    while(true) {
      var match = Curry._1(f, Curry._1(t[/* next */1], /* () */0));
      if (match) {
        return match[0];
      } else {
        _param = /* () */0;
        continue ;
        
      }
    };
  };
  return from2(next, (function () {
                return filter_map(f, Curry._1(t[/* clone */2], /* () */0));
              }));
}

function append(ta, tb) {
  var t = /* record */[
    /* count */(function () {
        return Curry._1(ta[/* count */0], /* () */0) + Curry._1(tb[/* count */0], /* () */0) | 0;
      }),
    /* next */_dummy,
    /* clone */(function () {
        return append(Curry._1(ta[/* clone */2], /* () */0), Curry._1(tb[/* clone */2], /* () */0));
      }),
    /* fast */ta[/* fast */3] && tb[/* fast */3]
  ];
  t[/* next */1] = (function () {
      try {
        return Curry._1(ta[/* next */1], /* () */0);
      }
      catch (exn){
        if (exn === No_more_elements) {
          t[/* next */1] = (function () {
              return Curry._1(tb[/* next */1], /* () */0);
            });
          t[/* count */0] = (function () {
              return Curry._1(tb[/* count */0], /* () */0);
            });
          t[/* clone */2] = (function () {
              return Curry._1(tb[/* clone */2], /* () */0);
            });
          t[/* fast */3] = tb[/* fast */3];
          return Curry._1(t[/* next */1], /* () */0);
        } else {
          throw exn;
        }
      }
    });
  return t;
}

function prefix_action(f, t) {
  var full_action = function (e) {
    e[/* count */0] = (function () {
        return Curry._1(t[/* count */0], /* () */0);
      });
    e[/* next */1] = (function () {
        return Curry._1(t[/* next */1], /* () */0);
      });
    e[/* clone */2] = (function () {
        return Curry._1(t[/* clone */2], /* () */0);
      });
    return Curry._1(f, /* () */0);
  };
  var t$prime = [];
  Caml_obj.caml_update_dummy(t$prime, /* record */[
        /* count */(function () {
            full_action(t$prime);
            return Curry._1(t[/* count */0], /* () */0);
          }),
        /* next */(function () {
            full_action(t$prime);
            return Curry._1(t[/* next */1], /* () */0);
          }),
        /* clone */(function () {
            full_action(t$prime);
            return Curry._1(t[/* clone */2], /* () */0);
          }),
        /* fast */t[/* fast */3]
      ]);
  return t$prime;
}

function suffix_action_without_raise(f, t) {
  return /* record */[
          /* count */t[/* count */0],
          /* next */(function () {
              try {
                return Curry._1(t[/* next */1], /* () */0);
              }
              catch (exn){
                if (exn === No_more_elements) {
                  return Curry._1(f, /* () */0);
                } else {
                  throw exn;
                }
              }
            }),
          /* clone */(function () {
              return Curry._1(t[/* clone */2], /* () */0);
            }),
          /* fast */t[/* fast */3]
        ];
}

function suffix_action(f, t) {
  var f$prime = function () {
    Curry._1(f, /* () */0);
    close(t);
    throw No_more_elements;
  };
  return suffix_action_without_raise(f$prime, t);
}

function concat(t) {
  var tn = [empty(/* () */0)];
  var next = function (_param) {
    while(true) {
      try {
        return Curry._1(tn[0][/* next */1], /* () */0);
      }
      catch (exn){
        if (exn === No_more_elements) {
          tn[0] = Curry._1(t[/* next */1], /* () */0);
          _param = /* () */0;
          continue ;
          
        } else {
          throw exn;
        }
      }
    };
  };
  var clone = function () {
    return append(Curry._1(tn[0][/* clone */2], /* () */0), concat(Curry._1(t[/* clone */2], /* () */0)));
  };
  return from2(next, clone);
}

function singleton(x) {
  return init(1, (function () {
                return x;
              }));
}

function switchn(n, f, e) {
  var queues = ArrayLabels.init(n, (function () {
          return Queue.create(/* () */0);
        }));
  return ArrayLabels.init(n, (function (i) {
                return from$1((function (param) {
                              var i$1 = i;
                              var my_queue = Caml_array.caml_array_get(queues, i$1);
                              if (Queue.is_empty(my_queue)) {
                                var _param = /* () */0;
                                while(true) {
                                  var next_item = Curry._1(e[/* next */1], /* () */0);
                                  var position = Curry._1(f, next_item);
                                  if (i$1 === position) {
                                    return next_item;
                                  } else {
                                    Queue.push(next_item, Caml_array.caml_array_get(queues, position));
                                    _param = /* () */0;
                                    continue ;
                                    
                                  }
                                };
                              } else {
                                return Queue.take(my_queue);
                              }
                            }));
              }));
}

function $$switch(f, e) {
  var a = switchn(2, (function (x) {
          if (Curry._1(f, x)) {
            return 0;
          } else {
            return 1;
          }
        }), e);
  return /* tuple */[
          Caml_array.caml_array_get(a, 0),
          Caml_array.caml_array_get(a, 1)
        ];
}

function seq(init, f, cond) {
  var acc = [init];
  return from$1((function () {
                if (Curry._1(cond, acc[0])) {
                  var result = acc[0];
                  acc[0] = Curry._1(f, acc[0]);
                  return result;
                } else {
                  throw No_more_elements;
                }
              }));
}

function repeat(times, x) {
  if (times) {
    return init(times[0], (function () {
                  return x;
                }));
  } else {
    var aux = [];
    Caml_obj.caml_update_dummy(aux, /* record */[
          /* count */return_infinite_count,
          /* next */(function () {
              return x;
            }),
          /* clone */(function () {
              return aux;
            }),
          /* fast : true */1
        ]);
    return aux;
  }
}

function cycle(times, x) {
  return concat(times ? init(times[0], (function () {
                      return Curry._1(x[/* clone */2], /* () */0);
                    })) : from$1((function () {
                      return Curry._1(x[/* clone */2], /* () */0);
                    })));
}

function range(until, x) {
  var cond;
  if (until) {
    var n = until[0];
    cond = (function (m) {
        return +(m <= n);
      });
  } else {
    cond = (function () {
        return /* true */1;
      });
  }
  return seq(x, (function (param) {
                return 1 + param | 0;
              }), cond);
}

function drop(n, e) {
  for(var i = 1; i <= n; ++i){
    junk(e);
  }
  return /* () */0;
}

function skip(n, e) {
  drop(n, e);
  return e;
}

function drop_while(p, e) {
  var aux = function (_param) {
    while(true) {
      var match = get(e);
      if (match) {
        var x = match[0];
        if (Curry._1(p, x)) {
          _param = /* () */0;
          continue ;
          
        } else {
          return push(e, x);
        }
      } else {
        return /* () */0;
      }
    };
  };
  return prefix_action(aux, e);
}

function take_while(f, t) {
  return from$1((function () {
                var x = Curry._1(t[/* next */1], /* () */0);
                if (Curry._1(f, x)) {
                  return x;
                } else {
                  push(t, x);
                  throw No_more_elements;
                }
              }));
}

function span(f, t) {
  var queue = Queue.create(/* () */0);
  var read_from_queue = [/* false */0];
  var head = function () {
    if (read_from_queue[0]) {
      try {
        return Queue.take(queue);
      }
      catch (exn){
        if (exn === Queue.Empty) {
          throw No_more_elements;
        } else {
          throw exn;
        }
      }
    } else {
      var x = Curry._1(t[/* next */1], /* () */0);
      if (Curry._1(f, x)) {
        return x;
      } else {
        push(t, x);
        throw No_more_elements;
      }
    }
  };
  var tail = function () {
    if (read_from_queue[0]) {
      return Curry._1(t[/* next */1], /* () */0);
    } else {
      read_from_queue[0] = /* true */1;
      var _param = /* () */0;
      while(true) {
        var match = get(t);
        if (match) {
          var x = match[0];
          if (Curry._1(f, x)) {
            Queue.push(x, queue);
            _param = /* () */0;
            continue ;
            
          } else {
            return x;
          }
        } else {
          throw No_more_elements;
        }
      };
    }
  };
  return /* tuple */[
          from$1(head),
          from$1(tail)
        ];
}

function while_do(cont, f, e) {
  var match = span(cont, e);
  return append(Curry._1(f, match[0]), match[1]);
}

function $$break(test, e) {
  return span((function (x) {
                return 1 - Curry._1(test, x);
              }), e);
}

function dup(t) {
  return /* tuple */[
          t,
          Curry._1(t[/* clone */2], /* () */0)
        ];
}

function combine(param) {
  var y = param[1];
  var x = param[0];
  if (x[/* fast */3] && y[/* fast */3]) {
    var aux = function (param) {
      var y = param[1];
      var x = param[0];
      return /* record */[
              /* count */(function () {
                  var x$1 = x;
                  var y$1 = y;
                  var count = function (x) {
                    try {
                      return /* Some */[Curry._1(x[/* count */0], /* () */0)];
                    }
                    catch (exn){
                      if (exn === Infinite_enum) {
                        return /* None */0;
                      } else {
                        throw exn;
                      }
                    }
                  };
                  var match = count(x$1);
                  var match$1 = count(y$1);
                  if (match) {
                    var c1 = match[0];
                    if (match$1) {
                      return Pervasives.min(c1, match$1[0]);
                    } else {
                      return c1;
                    }
                  } else if (match$1) {
                    return match$1[0];
                  } else {
                    throw Infinite_enum;
                  }
                }),
              /* next */(function () {
                  return /* tuple */[
                          Curry._1(x[/* next */1], /* () */0),
                          Curry._1(y[/* next */1], /* () */0)
                        ];
                }),
              /* clone */(function () {
                  return aux(/* tuple */[
                              Curry._1(x[/* clone */2], /* () */0),
                              Curry._1(y[/* clone */2], /* () */0)
                            ]);
                }),
              /* fast : true */1
            ];
    };
    return aux(/* tuple */[
                x,
                y
              ]);
  } else {
    return from$1((function () {
                  return /* tuple */[
                          Curry._1(x[/* next */1], /* () */0),
                          Curry._1(y[/* next */1], /* () */0)
                        ];
                }));
  }
}

function uncombine(e) {
  var advance = [/* first */10319920];
  var queue_snd = Queue.create(/* () */0);
  var queue_fst = Queue.create(/* () */0);
  var first = function () {
    var match = advance[0];
    if (match >= 10319920) {
      var match$1 = Curry._1(e[/* next */1], /* () */0);
      Queue.push(match$1[1], queue_snd);
      return match$1[0];
    } else {
      try {
        return Queue.pop(queue_fst);
      }
      catch (exn){
        if (exn === Queue.Empty) {
          var match$2 = Curry._1(e[/* next */1], /* () */0);
          Queue.push(match$2[1], queue_snd);
          advance[0] = /* first */10319920;
          return match$2[0];
        } else {
          throw exn;
        }
      }
    }
  };
  var second = function () {
    var match = advance[0];
    if (match >= 10319920) {
      try {
        return Queue.pop(queue_snd);
      }
      catch (exn){
        if (exn === Queue.Empty) {
          var match$1 = Curry._1(e[/* next */1], /* () */0);
          Queue.push(match$1[0], queue_fst);
          advance[0] = /* second */-465055884;
          return match$1[1];
        } else {
          throw exn;
        }
      }
    } else {
      var match$2 = Curry._1(e[/* next */1], /* () */0);
      Queue.push(match$2[0], queue_fst);
      return match$2[1];
    }
  };
  return /* tuple */[
          from$1(first),
          from$1(second)
        ];
}

function group_aux(test, eq, e) {
  var prev_group = [empty(/* () */0)];
  var f = function () {
    force(prev_group[0]);
    var last_test = [/* None */0];
    var grp = take_while((function (x) {
            var t = Curry._1(test, x);
            var match = last_test[0];
            var ok = match ? Curry._2(eq, match[0], t) : /* true */1;
            if (ok) {
              last_test[0] = /* Some */[t];
            }
            return ok;
          }), e);
    if (is_empty(grp)) {
      throw No_more_elements;
    }
    prev_group[0] = grp;
    return grp;
  };
  var clone = function () {
    return Pervasives.failwith("Grouped enumerations cannot be cloned safely");
  };
  return from2(f, clone);
}

function group(test, e) {
  return group_aux(test, Caml_obj.caml_equal, e);
}

function group_by(eq, e) {
  return group_aux((function (x) {
                return x;
              }), eq, e);
}

function clump(clump_size, add, get, e) {
  return from$1((function () {
                var match = peek(e);
                if (match) {
                  Curry._1(add, match[0]);
                  junk(e);
                  try {
                    for(var i = 2; i <= clump_size; ++i){
                      Curry._1(add, Curry._1(e[/* next */1], /* () */0));
                    }
                  }
                  catch (exn){
                    if (exn !== No_more_elements) {
                      throw exn;
                    }
                    
                  }
                  return Curry._1(get, /* () */0);
                } else {
                  throw No_more_elements;
                }
              }));
}

function cartesian_product(e1, e2) {
  var _make = function (state) {
    return /* record */[
            /* count */(function (param) {
                var state$1 = state;
                var n1 = Curry._1(state$1[/* e1 */0][/* count */0], /* () */0);
                var n2 = Curry._1(state$1[/* e2 */1][/* count */0], /* () */0);
                var n = (Caml_int32.imul(n1, n2) + Caml_int32.imul(n1, List.length(state$1[/* all2 */3])) | 0) + Caml_int32.imul(n2, List.length(state$1[/* all1 */2])) | 0;
                var match = state$1[/* cur */4];
                if (typeof match === "number") {
                  if (match >= 3) {
                    return 0;
                  } else {
                    return n;
                  }
                } else {
                  return n + List.length(match[1]) | 0;
                }
              }),
            /* next */(function (param) {
                var state$1 = state;
                var _param = param;
                while(true) {
                  var match = state$1[/* cur */4];
                  var exit = 0;
                  if (typeof match === "number") {
                    switch (match) {
                      case 0 : 
                          var x1;
                          try {
                            x1 = /* Some */[Curry._1(state$1[/* e1 */0][/* next */1], /* () */0)];
                          }
                          catch (exn){
                            if (exn === No_more_elements) {
                              x1 = /* None */0;
                            } else {
                              throw exn;
                            }
                          }
                          if (x1) {
                            var x = x1[0];
                            state$1[/* all1 */2] = /* :: */[
                              x,
                              state$1[/* all1 */2]
                            ];
                            state$1[/* cur */4] = /* ProdLeft */Block.__(0, [
                                x,
                                state$1[/* all2 */3]
                              ]);
                          } else {
                            state$1[/* cur */4] = /* GetRightOrStop */2;
                          }
                          _param = /* () */0;
                          continue ;
                          case 1 : 
                      case 2 : 
                          exit = 1;
                          break;
                      case 3 : 
                          throw No_more_elements;
                      
                    }
                  } else if (match.tag) {
                    var match$1 = match[1];
                    var y = match[0];
                    if (match$1) {
                      state$1[/* cur */4] = /* ProdRight */Block.__(1, [
                          y,
                          match$1[1]
                        ]);
                      return /* tuple */[
                              match$1[0],
                              y
                            ];
                    } else {
                      state$1[/* cur */4] = /* GetLeft */0;
                      _param = /* () */0;
                      continue ;
                      
                    }
                  } else {
                    var match$2 = match[1];
                    var x$1 = match[0];
                    if (match$2) {
                      state$1[/* cur */4] = /* ProdLeft */Block.__(0, [
                          x$1,
                          match$2[1]
                        ]);
                      return /* tuple */[
                              x$1,
                              match$2[0]
                            ];
                    } else {
                      state$1[/* cur */4] = /* GetRight */1;
                      _param = /* () */0;
                      continue ;
                      
                    }
                  }
                  if (exit === 1) {
                    var x2;
                    try {
                      x2 = /* Some */[Curry._1(state$1[/* e2 */1][/* next */1], /* () */0)];
                    }
                    catch (exn$1){
                      if (exn$1 === No_more_elements) {
                        x2 = /* None */0;
                      } else {
                        throw exn$1;
                      }
                    }
                    var match$3 = state$1[/* cur */4];
                    if (x2) {
                      var y$1 = x2[0];
                      state$1[/* all2 */3] = /* :: */[
                        y$1,
                        state$1[/* all2 */3]
                      ];
                      state$1[/* cur */4] = /* ProdRight */Block.__(1, [
                          y$1,
                          state$1[/* all1 */2]
                        ]);
                    } else {
                      var exit$1 = 0;
                      if (typeof match$3 === "number") {
                        if (match$3 !== 0) {
                          switch (match$3 - 1 | 0) {
                            case 0 : 
                                state$1[/* cur */4] = /* GetLeft */0;
                                break;
                            case 1 : 
                                state$1[/* cur */4] = /* Stop */3;
                                throw No_more_elements;
                            case 2 : 
                                exit$1 = 2;
                                break;
                            
                          }
                        } else {
                          exit$1 = 2;
                        }
                      } else {
                        exit$1 = 2;
                      }
                      if (exit$1 === 2) {
                        throw [
                              Caml_builtin_exceptions.assert_failure,
                              [
                                "batEnum.ml",
                                1057,
                                21
                              ]
                            ];
                      }
                      
                    }
                    _param = /* () */0;
                    continue ;
                    
                  }
                  
                };
              }),
            /* clone */(function (param) {
                var state$1 = state;
                return _make(/* record */[
                            /* e1 */Curry._1(state$1[/* e1 */0][/* clone */2], /* () */0),
                            /* e2 */Curry._1(state$1[/* e2 */1][/* clone */2], /* () */0),
                            /* all1 */state$1[/* all1 */2],
                            /* all2 */state$1[/* all2 */3],
                            /* cur */state$1[/* cur */4]
                          ]);
              }),
            /* fast */state[/* e1 */0][/* fast */3] && state[/* e2 */1][/* fast */3]
          ];
  };
  return _make(/* record */[
              /* e1 */e1,
              /* e2 */e2,
              /* all1 : [] */0,
              /* all2 : [] */0,
              /* cur : GetLeft */0
            ]);
}

function from_while(f) {
  return from$1((function () {
                var match = Curry._1(f, /* () */0);
                if (match) {
                  return match[0];
                } else {
                  throw No_more_elements;
                }
              }));
}

function from_loop(data, next) {
  var r = [data];
  return from$1((function () {
                var match = Curry._1(next, r[0]);
                r[0] = match[1];
                return match[0];
              }));
}

function unfold(data, next) {
  return from_loop(data, (function (data) {
                var match = Curry._1(next, data);
                if (match) {
                  return match[0];
                } else {
                  throw No_more_elements;
                }
              }));
}

function arg_min(f, $$enum) {
  var match = get($$enum);
  if (match) {
    var v = match[0];
    var match_000 = [v];
    var match_001 = [Curry._1(f, v)];
    var $$eval = match_001;
    var item = match_000;
    iter((function (v) {
            var fv = Curry._1(f, v);
            if (Caml_obj.caml_lessthan(fv, $$eval[0])) {
              item[0] = v;
              $$eval[0] = fv;
              return /* () */0;
            } else {
              return 0;
            }
          }), $$enum);
    return item[0];
  } else {
    return Pervasives.invalid_arg("arg_min: Empty enum");
  }
}

function arg_max(f, $$enum) {
  var match = get($$enum);
  if (match) {
    var v = match[0];
    var match_000 = [v];
    var match_001 = [Curry._1(f, v)];
    var $$eval = match_001;
    var item = match_000;
    iter((function (v) {
            var fv = Curry._1(f, v);
            if (Caml_obj.caml_greaterthan(fv, $$eval[0])) {
              item[0] = v;
              $$eval[0] = fv;
              return /* () */0;
            } else {
              return 0;
            }
          }), $$enum);
    return item[0];
  } else {
    return Pervasives.invalid_arg("arg_max: Empty enum");
  }
}

function $neg$neg(x, y) {
  return range(/* Some */[y], x);
}

function $neg$neg$dot(param, b) {
  var step = param[1];
  var a = param[0];
  var n = ((b - a) / step | 0) + 1 | 0;
  if (n < 0) {
    return empty(/* () */0);
  } else {
    return init(n, (function (i) {
                  return i * step + a;
                }));
  }
}

function $neg$neg$caret(x, y) {
  return range(/* Some */[y - 1 | 0], x);
}

function $neg$neg$neg(x, y) {
  if (x <= y) {
    return range(/* Some */[y], x);
  } else {
    return seq(x, (function (param) {
                  return -1 + param | 0;
                }), (function (param) {
                  return Caml_obj.caml_lessequal(y, param);
                }));
  }
}

function $neg$neg$tilde(a, b) {
  return map(Char.chr, range(/* Some */[b], a));
}

function $slash$slash(e, f) {
  return filter(f, e);
}

function $slash$at(e, f) {
  return map(f, e);
}

function $slash$slash$at(e, f) {
  return filter_map(f, e);
}

function append_from(a, b) {
  var t = from$1((function () {
          return Curry._1(a[/* next */1], /* () */0);
        }));
  var f = function () {
    var result = Curry._1(b[/* next */1], /* () */0);
    t[/* next */1] = (function () {
        return Curry._1(b[/* next */1], /* () */0);
      });
    return result;
  };
  return suffix_action_without_raise(f, t);
}

function merge(test, a, b) {
  if (is_empty(a)) {
    return b;
  } else if (is_empty(b)) {
    return a;
  } else {
    var next_a = [Curry._1(a[/* next */1], /* () */0)];
    var next_b = [Curry._1(b[/* next */1], /* () */0)];
    var aux = function () {
      var match;
      if (Curry._2(test, next_a[0], next_b[0])) {
        try {
          match = /* tuple */[
            next_a[0],
            Curry._1(a[/* next */1], /* () */0),
            next_b[0]
          ];
        }
        catch (exn){
          if (exn === No_more_elements) {
            push(b, next_b[0]);
            push(b, next_a[0]);
            throw No_more_elements;
          } else {
            throw exn;
          }
        }
      } else {
        try {
          match = /* tuple */[
            next_b[0],
            next_a[0],
            Curry._1(b[/* next */1], /* () */0)
          ];
        }
        catch (exn$1){
          if (exn$1 === No_more_elements) {
            push(a, next_a[0]);
            push(a, next_b[0]);
            throw No_more_elements;
          } else {
            throw exn$1;
          }
        }
      }
      next_a[0] = match[1];
      next_b[0] = match[2];
      return match[0];
    };
    return append_from(append_from(from$1(aux), a), b);
  }
}

function interleave(enums) {
  var enums_len = enums.length;
  if (enums_len <= 0) {
    return empty(/* () */0);
  } else {
    var available = Caml_array.caml_make_vect(enums_len, /* true */1);
    var next_idx = $$Array.init(enums_len, (function (param) {
            return 1 + param | 0;
          }));
    Caml_array.caml_array_set(next_idx, next_idx.length - 1 | 0, 0);
    var next_elem = function (idx) {
      var match = get(Caml_array.caml_array_get(enums, idx));
      if (match) {
        return /* tuple */[
                match[0],
                Caml_array.caml_array_get(next_idx, idx)
              ];
      } else {
        Caml_array.caml_array_set(available, idx, /* false */0);
        var _k = idx;
        while(true) {
          var k = _k;
          var l = Caml_array.caml_array_get(next_idx, k);
          if (l === idx) {
            throw No_more_elements;
          } else if (Caml_array.caml_array_get(available, l)) {
            Caml_array.caml_array_set(next_idx, idx, l);
            return next_elem(l);
          } else {
            _k = l;
            continue ;
            
          }
        };
      }
    };
    return from_loop(0, next_elem);
  }
}

function slazy(f) {
  var constructor = Block.__(246, [(function () {
          return Curry._1(f, /* () */0);
        })]);
  return make((function () {
                var tag = constructor.tag | 0;
                return Curry._1((
                              tag === 250 ? constructor[0] : (
                                  tag === 246 ? CamlinternalLazy.force_lazy_block(constructor) : constructor
                                )
                            )[/* next */1], /* () */0);
              }), (function () {
                var tag = constructor.tag | 0;
                return Curry._1((
                              tag === 250 ? constructor[0] : (
                                  tag === 246 ? CamlinternalLazy.force_lazy_block(constructor) : constructor
                                )
                            )[/* count */0], /* () */0);
              }), (function () {
                var tag = constructor.tag | 0;
                return Curry._1((
                              tag === 250 ? constructor[0] : (
                                  tag === 246 ? CamlinternalLazy.force_lazy_block(constructor) : constructor
                                )
                            )[/* clone */2], /* () */0);
              }));
}

function lsing(f) {
  return init(1, (function () {
                return Curry._1(f, /* () */0);
              }));
}

function lcons(f, e) {
  return append(init(1, (function () {
                    return Curry._1(f, /* () */0);
                  })), e);
}

function lapp(f, e) {
  return append(slazy(f), e);
}

function icons(f, e) {
  return append(init(1, (function () {
                    return f;
                  })), e);
}

function hard_count(t) {
  if (t[/* fast */3]) {
    var result = Curry._1(t[/* count */0], /* () */0);
    close(t);
    return result;
  } else {
    var length = 0;
    try {
      while(true) {
        Curry._1(t[/* next */1], /* () */0);
        length = length + 1 | 0;
      };
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "batEnum.ml",
              1326,
              59
            ]
          ];
    }
    catch (exn){
      if (exn === No_more_elements) {
        return length;
      } else {
        throw exn;
      }
    }
  }
}

function compare(cmp, t, u) {
  var _param = /* () */0;
  while(true) {
    var match = get(t);
    var match$1 = get(u);
    if (match) {
      if (match$1) {
        var n = Curry._2(cmp, match[0], match$1[0]);
        if (n !== 0) {
          return n;
        } else {
          _param = /* () */0;
          continue ;
          
        }
      } else {
        return 1;
      }
    } else if (match$1) {
      return -1;
    } else {
      return 0;
    }
  };
}

function equal(eq, t, u) {
  var _param = /* () */0;
  while(true) {
    var match = get(t);
    var match$1 = get(u);
    if (match) {
      if (match$1) {
        if (Curry._2(eq, match[0], match$1[0])) {
          _param = /* () */0;
          continue ;
          
        } else {
          return /* false */0;
        }
      } else {
        return /* false */0;
      }
    } else if (match$1) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  };
}

var class_tables = [
  0,
  0,
  0
];

function to_object(t) {
  if (!class_tables[0]) {
    var $$class = CamlinternalOO.create_table([
          "clone",
          "next",
          "count"
        ]);
    var env = CamlinternalOO.new_variable($$class, "");
    var ids = CamlinternalOO.get_method_labels($$class, [
          "next",
          "count",
          "clone"
        ]);
    var next = ids[0];
    var count = ids[1];
    var clone = ids[2];
    CamlinternalOO.set_methods($$class, /* array */[
          next,
          (function (self$1) {
              return Curry._1(self$1[env][0][/* next */1], /* () */0);
            }),
          count,
          (function (self$1) {
              return Curry._1(self$1[env][0][/* count */0], /* () */0);
            }),
          clone,
          (function (self$1) {
              return to_object(Curry._1(self$1[env][0][/* clone */2], /* () */0));
            })
        ]);
    var env_init = function (env$1) {
      var self = CamlinternalOO.create_object_opt(0, $$class);
      self[env] = env$1;
      return self;
    };
    CamlinternalOO.init_class($$class);
    class_tables[0] = env_init;
  }
  return Curry._1(class_tables[0], [t]);
}

function of_object(o) {
  return make((function () {
                return Caml_oo_curry.js1(-922581773, 3, o);
              }), (function () {
                return Caml_oo_curry.js1(-899463985, 2, o);
              }), (function () {
                return of_object(Caml_oo_curry.js1(-933031075, 1, o));
              }));
}

function concat_map(f, t) {
  var tn = [empty(/* () */0)];
  var next = function (_param) {
    while(true) {
      try {
        return Curry._1(tn[0][/* next */1], /* () */0);
      }
      catch (exn){
        if (exn === No_more_elements) {
          tn[0] = Curry._1(f, Curry._1(t[/* next */1], /* () */0));
          _param = /* () */0;
          continue ;
          
        } else {
          throw exn;
        }
      }
    };
  };
  var clone = function () {
    return append(Curry._1(tn[0][/* clone */2], /* () */0), concat_map(f, Curry._1(t[/* clone */2], /* () */0)));
  };
  return from2(next, clone);
}

function find$1(f, e) {
  try {
    return /* Some */[find(f, e)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

var Exceptionless = /* module */[/* find */find$1];

var iter$1 = iter;

var iter2$1 = iter2;

var iteri$1 = iteri;

var iter2i$1 = iter2i;

var for_all$1 = for_all;

var exists$1 = exists;

var fold$1 = fold;

var fold2$1 = fold2;

var foldi$1 = foldi;

var fold2i$1 = fold2i;

var find$2 = find;

var map$1 = map;

var mapi$1 = mapi;

var filter$1 = filter;

var filter_map$1 = filter_map;

var init$1 = init;

function $$switch$1(f) {
  return (function (param) {
      return $$switch(f, param);
    });
}

function take_while$1(f) {
  return (function (param) {
      return take_while(f, param);
    });
}

function drop_while$1(f) {
  return (function (param) {
      return drop_while(f, param);
    });
}

var from$2 = from$1;

var from_loop$1 = from_loop;

var from_while$1 = from_while;

var seq$1 = seq;

var unfold$1 = unfold;

function compare$1($staropt$star, t, u) {
  var cmp = $staropt$star ? $staropt$star[0] : Caml_obj.caml_compare;
  return compare(cmp, t, u);
}

var find$3 = find$1;

var LExceptionless = /* module */[/* find */find$3];

function $$return(x) {
  return init(1, (function () {
                return x;
              }));
}

function bind(m, f) {
  return concat(map(f, m));
}

var Monad = /* module */[
  /* return */$$return,
  /* bind */bind
];

var kahan_sum = fsum;

var flatten = concat;

var delay = slazy;

function $$enum$1(prim) {
  return prim;
}

function of_enum(prim) {
  return prim;
}

var partition = $$switch;

var Infix = [
  $neg$neg,
  $neg$neg$caret,
  $neg$neg$dot,
  $neg$neg$neg,
  $neg$neg$tilde,
  $slash$slash,
  $slash$at,
  map,
  $slash$slash$at,
  filter_map
];

var $at$slash = map;

var $at$slash$slash = filter_map;

var Labels = [
  iter$1,
  iter2$1,
  exists$1,
  for_all$1,
  fold$1,
  fold2$1,
  iteri$1,
  iter2i$1,
  foldi$1,
  fold2i$1,
  find$2,
  take_while$1,
  drop_while$1,
  map$1,
  mapi$1,
  filter$1,
  filter_map$1,
  from$2,
  from_while$1,
  from_loop$1,
  seq$1,
  unfold$1,
  init$1,
  $$switch$1,
  compare$1,
  LExceptionless
];

var iapp = append;

var ising = singleton;

exports.iter              = iter;
exports.iter2             = iter2;
exports.exists            = exists;
exports.for_all           = for_all;
exports.fold              = fold;
exports.reduce            = reduce;
exports.sum               = sum;
exports.fsum              = fsum;
exports.kahan_sum         = kahan_sum;
exports.fold2             = fold2;
exports.scanl             = scanl;
exports.scan              = scan;
exports.iteri             = iteri;
exports.iter2i            = iter2i;
exports.foldi             = foldi;
exports.fold2i            = fold2i;
exports.find              = find;
exports.find_map          = find_map;
exports.is_empty          = is_empty;
exports.peek              = peek;
exports.get               = get;
exports.get_exn           = get_exn;
exports.push              = push;
exports.junk              = junk;
exports.clone             = clone;
exports.force             = force;
exports.take              = take;
exports.drop              = drop;
exports.skip              = skip;
exports.take_while        = take_while;
exports.drop_while        = drop_while;
exports.span              = span;
exports.$$break           = $$break;
exports.group             = group;
exports.group_by          = group_by;
exports.clump             = clump;
exports.cartesian_product = cartesian_product;
exports.map               = map;
exports.mapi              = mapi;
exports.filter            = filter;
exports.filter_map        = filter_map;
exports.append            = append;
exports.prefix_action     = prefix_action;
exports.suffix_action     = suffix_action;
exports.concat            = concat;
exports.flatten           = flatten;
exports.concat_map        = concat_map;
exports.No_more_elements  = No_more_elements;
exports.Infinite_enum     = Infinite_enum;
exports.empty             = empty;
exports.make              = make;
exports.from              = from$1;
exports.from_while        = from_while;
exports.from_loop         = from_loop;
exports.seq               = seq;
exports.unfold            = unfold;
exports.init              = init;
exports.singleton         = singleton;
exports.repeat            = repeat;
exports.cycle             = cycle;
exports.delay             = delay;
exports.to_object         = to_object;
exports.of_object         = of_object;
exports.$$enum            = $$enum$1;
exports.of_enum           = of_enum;
exports.count             = count;
exports.fast_count        = fast_count;
exports.hard_count        = hard_count;
exports.range             = range;
exports.dup               = dup;
exports.combine           = combine;
exports.uncombine         = uncombine;
exports.merge             = merge;
exports.interleave        = interleave;
exports.$$switch          = $$switch;
exports.partition         = partition;
exports.arg_min           = arg_min;
exports.arg_max           = arg_max;
exports.while_do          = while_do;
exports.Infix             = Infix;
exports.$neg$neg          = $neg$neg;
exports.$neg$neg$caret    = $neg$neg$caret;
exports.$neg$neg$dot      = $neg$neg$dot;
exports.$neg$neg$neg      = $neg$neg$neg;
exports.$neg$neg$tilde    = $neg$neg$tilde;
exports.$slash$slash      = $slash$slash;
exports.$slash$at         = $slash$at;
exports.$at$slash         = $at$slash;
exports.$slash$slash$at   = $slash$slash$at;
exports.$at$slash$slash   = $at$slash$slash;
exports.Monad             = Monad;
exports.compare           = compare;
exports.equal             = equal;
exports.Exceptionless     = Exceptionless;
exports.Labels            = Labels;
exports.iapp              = iapp;
exports.icons             = icons;
exports.ising             = ising;
exports.lapp              = lapp;
exports.lcons             = lcons;
exports.lsing             = lsing;
exports.slazy             = slazy;
/* No side effect */

},{"bs-platform/lib/js/array.js":9,"bs-platform/lib/js/arrayLabels.js":10,"bs-platform/lib/js/block.js":11,"bs-platform/lib/js/caml_array.js":12,"bs-platform/lib/js/caml_builtin_exceptions.js":13,"bs-platform/lib/js/caml_exceptions.js":14,"bs-platform/lib/js/caml_int32.js":16,"bs-platform/lib/js/caml_obj.js":20,"bs-platform/lib/js/caml_oo_curry.js":22,"bs-platform/lib/js/camlinternalLazy.js":27,"bs-platform/lib/js/camlinternalOO.js":28,"bs-platform/lib/js/char.js":29,"bs-platform/lib/js/curry.js":30,"bs-platform/lib/js/list.js":33,"bs-platform/lib/js/pervasives.js":36,"bs-platform/lib/js/queue.js":37}],8:[function(require,module,exports){
// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var Curry                   = require("bs-platform/lib/js/curry.js");
var BatEnum                 = require("./batEnum.js");
var Caml_obj                = require("bs-platform/lib/js/caml_obj.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function some(x) {
  return /* Some */[x];
}

function may(f, param) {
  if (param) {
    return Curry._1(f, param[0]);
  } else {
    return /* () */0;
  }
}

function map(f, param) {
  if (param) {
    return /* Some */[Curry._1(f, param[0])];
  } else {
    return /* None */0;
  }
}

function apply(param) {
  if (param) {
    return param[0];
  } else {
    return (function (x) {
        return x;
      });
  }
}

function filter(f, param) {
  if (param) {
    var x = param[0];
    if (Curry._1(f, x)) {
      return /* Some */[x];
    } else {
      return /* None */0;
    }
  } else {
    return /* None */0;
  }
}

function $$default(v, param) {
  if (param) {
    return param[0];
  } else {
    return v;
  }
}

function default_delayed(l, param) {
  if (param) {
    return param[0];
  } else {
    return Curry._1(l, /* () */0);
  }
}

function is_some(param) {
  if (param) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function is_none(param) {
  if (param) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function get_exn(s, e) {
  if (s) {
    return s[0];
  } else {
    throw e;
  }
}

function get(s) {
  return get_exn(s, [
              Caml_builtin_exceptions.invalid_argument,
              "Option.get"
            ]);
}

function map_default(f, v, param) {
  if (param) {
    return Curry._1(f, param[0]);
  } else {
    return v;
  }
}

function map_default_delayed(f, l, param) {
  if (param) {
    return Curry._1(f, param[0]);
  } else {
    return Curry._1(l, /* () */0);
  }
}

function compare($staropt$star, a, b) {
  var cmp = $staropt$star ? $staropt$star[0] : Caml_obj.caml_compare;
  if (a) {
    if (b) {
      return Curry._2(cmp, a[0], b[0]);
    } else {
      return 1;
    }
  } else if (b) {
    return -1;
  } else {
    return 0;
  }
}

function eq($staropt$star, x, y) {
  var eq$1 = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  if (x) {
    if (y) {
      return Curry._2(eq$1, x[0], y[0]);
    } else {
      return /* false */0;
    }
  } else if (y) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function $$enum(param) {
  if (param) {
    return BatEnum.singleton(param[0]);
  } else {
    return BatEnum.from((function () {
                  throw BatEnum.No_more_elements;
                }));
  }
}

function $$return(x) {
  return /* Some */[x];
}

function bind(m, f) {
  if (m) {
    return Curry._1(f, m[0]);
  } else {
    return /* None */0;
  }
}

var Monad = /* module */[
  /* return */$$return,
  /* bind */bind
];

var may$1 = may;

var map$1 = map;

var map_default$1 = map_default;

var Labels = /* module */[
  /* may */may$1,
  /* map */map$1,
  /* map_default */map_default$1
];

function $pipe$unknown(x, def) {
  return $$default(def, x);
}

var Infix = /* module */[
  /* |? */$pipe$unknown,
  /* >>= */bind
];

var of_enum = BatEnum.get;

exports.some                = some;
exports.may                 = may;
exports.map                 = map;
exports.bind                = bind;
exports.apply               = apply;
exports.filter              = filter;
exports.$$default           = $$default;
exports.default             = $$default;
exports.__esModule          = true;
exports.$pipe$unknown       = $pipe$unknown;
exports.default_delayed     = default_delayed;
exports.map_default         = map_default;
exports.map_default_delayed = map_default_delayed;
exports.is_none             = is_none;
exports.is_some             = is_some;
exports.get                 = get;
exports.get_exn             = get_exn;
exports.compare             = compare;
exports.eq                  = eq;
exports.$$enum              = $$enum;
exports.of_enum             = of_enum;
exports.Monad               = Monad;
exports.Labels              = Labels;
exports.Infix               = Infix;
/* No side effect */

},{"./batEnum.js":7,"bs-platform/lib/js/caml_builtin_exceptions.js":13,"bs-platform/lib/js/caml_obj.js":20,"bs-platform/lib/js/curry.js":30}],9:[function(require,module,exports){
'use strict';

var Curry                   = require("./curry.js");
var Js_exn                  = require("./js_exn.js");
var Caml_array              = require("./caml_array.js");
var Caml_exceptions         = require("./caml_exceptions.js");
var Caml_builtin_exceptions = require("./caml_builtin_exceptions.js");

function init(l, f) {
  if (l) {
    if (l < 0) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Array.init"
          ];
    } else {
      var res = Caml_array.caml_make_vect(l, Curry._1(f, 0));
      for(var i = 1 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
        res[i] = Curry._1(f, i);
      }
      return res;
    }
  } else {
    return /* array */[];
  }
}

function make_matrix(sx, sy, init) {
  var res = Caml_array.caml_make_vect(sx, /* array */[]);
  for(var x = 0 ,x_finish = sx - 1 | 0; x <= x_finish; ++x){
    res[x] = Caml_array.caml_make_vect(sy, init);
  }
  return res;
}

function copy(a) {
  var l = a.length;
  if (l) {
    return Caml_array.caml_array_sub(a, 0, l);
  } else {
    return /* array */[];
  }
}

function append(a1, a2) {
  var l1 = a1.length;
  if (l1) {
    if (a2.length) {
      return a1.concat(a2);
    } else {
      return Caml_array.caml_array_sub(a1, 0, l1);
    }
  } else {
    return copy(a2);
  }
}

function sub(a, ofs, len) {
  if (len < 0 || ofs > (a.length - len | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Array.sub"
        ];
  } else {
    return Caml_array.caml_array_sub(a, ofs, len);
  }
}

function fill(a, ofs, len, v) {
  if (ofs < 0 || len < 0 || ofs > (a.length - len | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Array.fill"
        ];
  } else {
    for(var i = ofs ,i_finish = (ofs + len | 0) - 1 | 0; i <= i_finish; ++i){
      a[i] = v;
    }
    return /* () */0;
  }
}

function blit(a1, ofs1, a2, ofs2, len) {
  if (len < 0 || ofs1 < 0 || ofs1 > (a1.length - len | 0) || ofs2 < 0 || ofs2 > (a2.length - len | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Array.blit"
        ];
  } else {
    return Caml_array.caml_array_blit(a1, ofs1, a2, ofs2, len);
  }
}

function iter(f, a) {
  for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
    Curry._1(f, a[i]);
  }
  return /* () */0;
}

function map(f, a) {
  var l = a.length;
  if (l) {
    var r = Caml_array.caml_make_vect(l, Curry._1(f, a[0]));
    for(var i = 1 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
      r[i] = Curry._1(f, a[i]);
    }
    return r;
  } else {
    return /* array */[];
  }
}

function iteri(f, a) {
  for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
    Curry._2(f, i, a[i]);
  }
  return /* () */0;
}

function mapi(f, a) {
  var l = a.length;
  if (l) {
    var r = Caml_array.caml_make_vect(l, Curry._2(f, 0, a[0]));
    for(var i = 1 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
      r[i] = Curry._2(f, i, a[i]);
    }
    return r;
  } else {
    return /* array */[];
  }
}

function to_list(a) {
  var _i = a.length - 1 | 0;
  var _res = /* [] */0;
  while(true) {
    var res = _res;
    var i = _i;
    if (i < 0) {
      return res;
    } else {
      _res = /* :: */[
        a[i],
        res
      ];
      _i = i - 1 | 0;
      continue ;
      
    }
  };
}

function list_length(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (param) {
      _param = param[1];
      _accu = accu + 1 | 0;
      continue ;
      
    } else {
      return accu;
    }
  };
}

function of_list(l) {
  if (l) {
    var a = Caml_array.caml_make_vect(list_length(0, l), l[0]);
    var _i = 1;
    var _param = l[1];
    while(true) {
      var param = _param;
      var i = _i;
      if (param) {
        a[i] = param[0];
        _param = param[1];
        _i = i + 1 | 0;
        continue ;
        
      } else {
        return a;
      }
    };
  } else {
    return /* array */[];
  }
}

function fold_left(f, x, a) {
  var r = x;
  for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
    r = Curry._2(f, r, a[i]);
  }
  return r;
}

function fold_right(f, a, x) {
  var r = x;
  for(var i = a.length - 1 | 0; i >= 0; --i){
    r = Curry._2(f, a[i], r);
  }
  return r;
}

var Bottom = Caml_exceptions.create("Array.Bottom");

function sort(cmp, a) {
  var maxson = function (l, i) {
    var i31 = ((i + i | 0) + i | 0) + 1 | 0;
    var x = i31;
    if ((i31 + 2 | 0) < l) {
      if (Curry._2(cmp, Caml_array.caml_array_get(a, i31), Caml_array.caml_array_get(a, i31 + 1 | 0)) < 0) {
        x = i31 + 1 | 0;
      }
      if (Curry._2(cmp, Caml_array.caml_array_get(a, x), Caml_array.caml_array_get(a, i31 + 2 | 0)) < 0) {
        x = i31 + 2 | 0;
      }
      return x;
    } else if ((i31 + 1 | 0) < l && Curry._2(cmp, Caml_array.caml_array_get(a, i31), Caml_array.caml_array_get(a, i31 + 1 | 0)) < 0) {
      return i31 + 1 | 0;
    } else if (i31 < l) {
      return i31;
    } else {
      throw [
            Bottom,
            i
          ];
    }
  };
  var trickle = function (l, i, e) {
    try {
      var l$1 = l;
      var _i = i;
      var e$1 = e;
      while(true) {
        var i$1 = _i;
        var j = maxson(l$1, i$1);
        if (Curry._2(cmp, Caml_array.caml_array_get(a, j), e$1) > 0) {
          Caml_array.caml_array_set(a, i$1, Caml_array.caml_array_get(a, j));
          _i = j;
          continue ;
          
        } else {
          return Caml_array.caml_array_set(a, i$1, e$1);
        }
      };
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Bottom) {
        return Caml_array.caml_array_set(a, exn[1], e);
      } else {
        throw exn;
      }
    }
  };
  var bubble = function (l, i) {
    try {
      var l$1 = l;
      var _i = i;
      while(true) {
        var i$1 = _i;
        var j = maxson(l$1, i$1);
        Caml_array.caml_array_set(a, i$1, Caml_array.caml_array_get(a, j));
        _i = j;
        continue ;
        
      };
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Bottom) {
        return exn[1];
      } else {
        throw exn;
      }
    }
  };
  var trickleup = function (_i, e) {
    while(true) {
      var i = _i;
      var father = (i - 1 | 0) / 3 | 0;
      if (i === father) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "array.ml",
                168,
                4
              ]
            ];
      }
      if (Curry._2(cmp, Caml_array.caml_array_get(a, father), e) < 0) {
        Caml_array.caml_array_set(a, i, Caml_array.caml_array_get(a, father));
        if (father > 0) {
          _i = father;
          continue ;
          
        } else {
          return Caml_array.caml_array_set(a, 0, e);
        }
      } else {
        return Caml_array.caml_array_set(a, i, e);
      }
    };
  };
  var l = a.length;
  for(var i = ((l + 1 | 0) / 3 | 0) - 1 | 0; i >= 0; --i){
    trickle(l, i, Caml_array.caml_array_get(a, i));
  }
  for(var i$1 = l - 1 | 0; i$1 >= 2; --i$1){
    var e = Caml_array.caml_array_get(a, i$1);
    Caml_array.caml_array_set(a, i$1, Caml_array.caml_array_get(a, 0));
    trickleup(bubble(i$1, 0), e);
  }
  if (l > 1) {
    var e$1 = Caml_array.caml_array_get(a, 1);
    Caml_array.caml_array_set(a, 1, Caml_array.caml_array_get(a, 0));
    return Caml_array.caml_array_set(a, 0, e$1);
  } else {
    return 0;
  }
}

function stable_sort(cmp, a) {
  var merge = function (src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
    var src1r = src1ofs + src1len | 0;
    var src2r = src2ofs + src2len | 0;
    var _i1 = src1ofs;
    var _s1 = Caml_array.caml_array_get(a, src1ofs);
    var _i2 = src2ofs;
    var _s2 = Caml_array.caml_array_get(src2, src2ofs);
    var _d = dstofs;
    while(true) {
      var d = _d;
      var s2 = _s2;
      var i2 = _i2;
      var s1 = _s1;
      var i1 = _i1;
      if (Curry._2(cmp, s1, s2) <= 0) {
        Caml_array.caml_array_set(dst, d, s1);
        var i1$1 = i1 + 1 | 0;
        if (i1$1 < src1r) {
          _d = d + 1 | 0;
          _s1 = Caml_array.caml_array_get(a, i1$1);
          _i1 = i1$1;
          continue ;
          
        } else {
          return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
        }
      } else {
        Caml_array.caml_array_set(dst, d, s2);
        var i2$1 = i2 + 1 | 0;
        if (i2$1 < src2r) {
          _d = d + 1 | 0;
          _s2 = Caml_array.caml_array_get(src2, i2$1);
          _i2 = i2$1;
          continue ;
          
        } else {
          return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
        }
      }
    };
  };
  var isortto = function (srcofs, dst, dstofs, len) {
    for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
      var e = Caml_array.caml_array_get(a, srcofs + i | 0);
      var j = (dstofs + i | 0) - 1 | 0;
      while(j >= dstofs && Curry._2(cmp, Caml_array.caml_array_get(dst, j), e) > 0) {
        Caml_array.caml_array_set(dst, j + 1 | 0, Caml_array.caml_array_get(dst, j));
        j = j - 1 | 0;
      };
      Caml_array.caml_array_set(dst, j + 1 | 0, e);
    }
    return /* () */0;
  };
  var sortto = function (srcofs, dst, dstofs, len) {
    if (len <= 5) {
      return isortto(srcofs, dst, dstofs, len);
    } else {
      var l1 = len / 2 | 0;
      var l2 = len - l1 | 0;
      sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
      sortto(srcofs, a, srcofs + l2 | 0, l1);
      return merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
    }
  };
  var l = a.length;
  if (l <= 5) {
    return isortto(0, a, 0, l);
  } else {
    var l1 = l / 2 | 0;
    var l2 = l - l1 | 0;
    var t = Caml_array.caml_make_vect(l2, Caml_array.caml_array_get(a, 0));
    sortto(l1, t, 0, l2);
    sortto(0, a, l2, l1);
    return merge(l2, l1, t, 0, l2, a, 0);
  }
}

var create_matrix = make_matrix;

var concat = Caml_array.caml_array_concat;

var fast_sort = stable_sort;

exports.init          = init;
exports.make_matrix   = make_matrix;
exports.create_matrix = create_matrix;
exports.append        = append;
exports.concat        = concat;
exports.sub           = sub;
exports.copy          = copy;
exports.fill          = fill;
exports.blit          = blit;
exports.to_list       = to_list;
exports.of_list       = of_list;
exports.iter          = iter;
exports.map           = map;
exports.iteri         = iteri;
exports.mapi          = mapi;
exports.fold_left     = fold_left;
exports.fold_right    = fold_right;
exports.sort          = sort;
exports.stable_sort   = stable_sort;
exports.fast_sort     = fast_sort;
/* No side effect */

},{"./caml_array.js":12,"./caml_builtin_exceptions.js":13,"./caml_exceptions.js":14,"./curry.js":30,"./js_exn.js":31}],10:[function(require,module,exports){
'use strict';

var $$Array = require("./array.js");

var init = $$Array.init;

var make_matrix = $$Array.make_matrix;

var create_matrix = $$Array.create_matrix;

var append = $$Array.append;

var concat = $$Array.concat;

var sub = $$Array.sub;

var copy = $$Array.copy;

var fill = $$Array.fill;

var blit = $$Array.blit;

var to_list = $$Array.to_list;

var of_list = $$Array.of_list;

var iter = $$Array.iter;

var map = $$Array.map;

var iteri = $$Array.iteri;

var mapi = $$Array.mapi;

var fold_left = $$Array.fold_left;

var fold_right = $$Array.fold_right;

var sort = $$Array.sort;

var stable_sort = $$Array.stable_sort;

var fast_sort = $$Array.fast_sort;

exports.init          = init;
exports.make_matrix   = make_matrix;
exports.create_matrix = create_matrix;
exports.append        = append;
exports.concat        = concat;
exports.sub           = sub;
exports.copy          = copy;
exports.fill          = fill;
exports.blit          = blit;
exports.to_list       = to_list;
exports.of_list       = of_list;
exports.iter          = iter;
exports.map           = map;
exports.iteri         = iteri;
exports.mapi          = mapi;
exports.fold_left     = fold_left;
exports.fold_right    = fold_right;
exports.sort          = sort;
exports.stable_sort   = stable_sort;
exports.fast_sort     = fast_sort;
/* No side effect */

},{"./array.js":9}],11:[function(require,module,exports){
'use strict';


function __(tag, block) {
  block.tag = tag;
  return block;
}

exports.__ = __;
/* No side effect */

},{}],12:[function(require,module,exports){
'use strict';

var Caml_builtin_exceptions = require("./caml_builtin_exceptions.js");

function caml_array_sub(x, offset, len) {
  var result = new Array(len);
  var j = 0;
  var i = offset;
  while(j < len) {
    result[j] = x[i];
    j = j + 1 | 0;
    i = i + 1 | 0;
  };
  return result;
}

function len(_acc, _l) {
  while(true) {
    var l = _l;
    var acc = _acc;
    if (l) {
      _l = l[1];
      _acc = l[0].length + acc | 0;
      continue ;
      
    } else {
      return acc;
    }
  };
}

function fill(arr, _i, _l) {
  while(true) {
    var l = _l;
    var i = _i;
    if (l) {
      var x = l[0];
      var l$1 = x.length;
      var k = i;
      var j = 0;
      while(j < l$1) {
        arr[k] = x[j];
        k = k + 1 | 0;
        j = j + 1 | 0;
      };
      _l = l[1];
      _i = k;
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function caml_array_concat(l) {
  var v = len(0, l);
  var result = new Array(v);
  fill(result, 0, l);
  return result;
}

function caml_array_set(xs, index, newval) {
  if (index < 0 || index >= xs.length) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "index out of bounds"
        ];
  } else {
    xs[index] = newval;
    return /* () */0;
  }
}

function caml_array_get(xs, index) {
  if (index < 0 || index >= xs.length) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "index out of bounds"
        ];
  } else {
    return xs[index];
  }
}

function caml_make_vect(len, init) {
  var b = new Array(len);
  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
    b[i] = init;
  }
  return b;
}

function caml_array_blit(a1, i1, a2, i2, len) {
  if (i2 <= i1) {
    for(var j = 0 ,j_finish = len - 1 | 0; j <= j_finish; ++j){
      a2[j + i2 | 0] = a1[j + i1 | 0];
    }
    return /* () */0;
  } else {
    for(var j$1 = len - 1 | 0; j$1 >= 0; --j$1){
      a2[j$1 + i2 | 0] = a1[j$1 + i1 | 0];
    }
    return /* () */0;
  }
}

exports.caml_array_sub    = caml_array_sub;
exports.caml_array_concat = caml_array_concat;
exports.caml_make_vect    = caml_make_vect;
exports.caml_array_blit   = caml_array_blit;
exports.caml_array_get    = caml_array_get;
exports.caml_array_set    = caml_array_set;
/* No side effect */

},{"./caml_builtin_exceptions.js":13}],13:[function(require,module,exports){
'use strict';


var out_of_memory = /* tuple */[
  "Out_of_memory",
  0
];

var sys_error = /* tuple */[
  "Sys_error",
  -1
];

var failure = /* tuple */[
  "Failure",
  -2
];

var invalid_argument = /* tuple */[
  "Invalid_argument",
  -3
];

var end_of_file = /* tuple */[
  "End_of_file",
  -4
];

var division_by_zero = /* tuple */[
  "Division_by_zero",
  -5
];

var not_found = /* tuple */[
  "Not_found",
  -6
];

var match_failure = /* tuple */[
  "Match_failure",
  -7
];

var stack_overflow = /* tuple */[
  "Stack_overflow",
  -8
];

var sys_blocked_io = /* tuple */[
  "Sys_blocked_io",
  -9
];

var assert_failure = /* tuple */[
  "Assert_failure",
  -10
];

var undefined_recursive_module = /* tuple */[
  "Undefined_recursive_module",
  -11
];

out_of_memory.tag = 248;

sys_error.tag = 248;

failure.tag = 248;

invalid_argument.tag = 248;

end_of_file.tag = 248;

division_by_zero.tag = 248;

not_found.tag = 248;

match_failure.tag = 248;

stack_overflow.tag = 248;

sys_blocked_io.tag = 248;

assert_failure.tag = 248;

undefined_recursive_module.tag = 248;

exports.out_of_memory              = out_of_memory;
exports.sys_error                  = sys_error;
exports.failure                    = failure;
exports.invalid_argument           = invalid_argument;
exports.end_of_file                = end_of_file;
exports.division_by_zero           = division_by_zero;
exports.not_found                  = not_found;
exports.match_failure              = match_failure;
exports.stack_overflow             = stack_overflow;
exports.sys_blocked_io             = sys_blocked_io;
exports.assert_failure             = assert_failure;
exports.undefined_recursive_module = undefined_recursive_module;
/*  Not a pure module */

},{}],14:[function(require,module,exports){
'use strict';


var id = [0];

function caml_set_oo_id(b) {
  b[1] = id[0];
  id[0] += 1;
  return b;
}

function get_id() {
  id[0] += 1;
  return id[0];
}

function create(str) {
  var v_001 = get_id(/* () */0);
  var v = /* tuple */[
    str,
    v_001
  ];
  v.tag = 248;
  return v;
}

function isCamlExceptionOrOpenVariant(e) {
  if (e === undefined) {
    return /* false */0;
  } else if (e.tag === 248) {
    return /* true */1;
  } else {
    var slot = e[0];
    if (slot !== undefined) {
      return +(slot.tag === 248);
    } else {
      return /* false */0;
    }
  }
}

exports.caml_set_oo_id               = caml_set_oo_id;
exports.get_id                       = get_id;
exports.create                       = create;
exports.isCamlExceptionOrOpenVariant = isCamlExceptionOrOpenVariant;
/* No side effect */

},{}],15:[function(require,module,exports){
'use strict';

var Curry                   = require("./curry.js");
var Caml_int32              = require("./caml_int32.js");
var Caml_int64              = require("./caml_int64.js");
var Caml_utils              = require("./caml_utils.js");
var Caml_builtin_exceptions = require("./caml_builtin_exceptions.js");

function caml_failwith(s) {
  throw [
        Caml_builtin_exceptions.failure,
        s
      ];
}

function parse_digit(c) {
  if (c >= 65) {
    if (c >= 97) {
      if (c >= 123) {
        return -1;
      } else {
        return c - 87 | 0;
      }
    } else if (c >= 91) {
      return -1;
    } else {
      return c - 55 | 0;
    }
  } else if (c > 57 || c < 48) {
    return -1;
  } else {
    return c - /* "0" */48 | 0;
  }
}

function int_of_string_base(param) {
  switch (param) {
    case 0 : 
        return 8;
    case 1 : 
        return 16;
    case 2 : 
        return 10;
    case 3 : 
        return 2;
    
  }
}

function parse_sign_and_base(s) {
  var sign = 1;
  var base = /* Dec */2;
  var i = 0;
  if (s[i] === "-") {
    sign = -1;
    i = i + 1 | 0;
  }
  var match = s.charCodeAt(i);
  var match$1 = s.charCodeAt(i + 1 | 0);
  if (match === 48) {
    if (match$1 >= 89) {
      if (match$1 !== 98) {
        if (match$1 !== 111) {
          if (match$1 === 120) {
            base = /* Hex */1;
            i = i + 2 | 0;
          }
          
        } else {
          base = /* Oct */0;
          i = i + 2 | 0;
        }
      } else {
        base = /* Bin */3;
        i = i + 2 | 0;
      }
    } else if (match$1 !== 66) {
      if (match$1 !== 79) {
        if (match$1 >= 88) {
          base = /* Hex */1;
          i = i + 2 | 0;
        }
        
      } else {
        base = /* Oct */0;
        i = i + 2 | 0;
      }
    } else {
      base = /* Bin */3;
      i = i + 2 | 0;
    }
  }
  return /* tuple */[
          i,
          sign,
          base
        ];
}

function caml_int_of_string(s) {
  var match = parse_sign_and_base(s);
  var i = match[0];
  var base = int_of_string_base(match[2]);
  var threshold = 4294967295;
  var len = s.length;
  var c = i < len ? s.charCodeAt(i) : /* "\000" */0;
  var d = parse_digit(c);
  if (d < 0 || d >= base) {
    throw [
          Caml_builtin_exceptions.failure,
          "int_of_string"
        ];
  }
  var aux = function (_acc, _k) {
    while(true) {
      var k = _k;
      var acc = _acc;
      if (k === len) {
        return acc;
      } else {
        var a = s.charCodeAt(k);
        if (a === /* "_" */95) {
          _k = k + 1 | 0;
          continue ;
          
        } else {
          var v = parse_digit(a);
          if (v < 0 || v >= base) {
            throw [
                  Caml_builtin_exceptions.failure,
                  "int_of_string"
                ];
          } else {
            var acc$1 = base * acc + v;
            if (acc$1 > threshold) {
              throw [
                    Caml_builtin_exceptions.failure,
                    "int_of_string"
                  ];
            } else {
              _k = k + 1 | 0;
              _acc = acc$1;
              continue ;
              
            }
          }
        }
      }
    };
  };
  var res = match[1] * aux(d, i + 1 | 0);
  var or_res = res | 0;
  if (base === 10 && res !== or_res) {
    throw [
          Caml_builtin_exceptions.failure,
          "int_of_string"
        ];
  }
  return or_res;
}

function caml_int64_of_string(s) {
  var match = parse_sign_and_base(s);
  var hbase = match[2];
  var i = match[0];
  var base = Caml_int64.of_int32(int_of_string_base(hbase));
  var sign = Caml_int64.of_int32(match[1]);
  var threshold;
  switch (hbase) {
    case 0 : 
        threshold = /* int64 */[
          /* hi */536870911,
          /* lo */4294967295
        ];
        break;
    case 1 : 
        threshold = /* int64 */[
          /* hi */268435455,
          /* lo */4294967295
        ];
        break;
    case 2 : 
        threshold = /* int64 */[
          /* hi */429496729,
          /* lo */2576980377
        ];
        break;
    case 3 : 
        threshold = /* int64 */[
          /* hi */2147483647,
          /* lo */4294967295
        ];
        break;
    
  }
  var len = s.length;
  var c = i < len ? s.charCodeAt(i) : /* "\000" */0;
  var d = Caml_int64.of_int32(parse_digit(c));
  if (Caml_int64.lt(d, /* int64 */[
          /* hi */0,
          /* lo */0
        ]) || Caml_int64.ge(d, base)) {
    throw [
          Caml_builtin_exceptions.failure,
          "int64_of_string"
        ];
  }
  var aux = function (_acc, _k) {
    while(true) {
      var k = _k;
      var acc = _acc;
      if (k === len) {
        return acc;
      } else {
        var a = s.charCodeAt(k);
        if (a === /* "_" */95) {
          _k = k + 1 | 0;
          continue ;
          
        } else {
          var v = Caml_int64.of_int32(parse_digit(a));
          if (Caml_int64.lt(v, /* int64 */[
                  /* hi */0,
                  /* lo */0
                ]) || Caml_int64.ge(v, base) || Caml_int64.gt(acc, threshold)) {
            throw [
                  Caml_builtin_exceptions.failure,
                  "int64_of_string"
                ];
          } else {
            var acc$1 = Caml_int64.add(Caml_int64.mul(base, acc), v);
            _k = k + 1 | 0;
            _acc = acc$1;
            continue ;
            
          }
        }
      }
    };
  };
  var res = Caml_int64.mul(sign, aux(d, i + 1 | 0));
  var or_res = Caml_int64.or_(res, /* int64 */[
        /* hi */0,
        /* lo */0
      ]);
  if (Caml_int64.eq(base, /* int64 */[
          /* hi */0,
          /* lo */10
        ]) && Caml_int64.neq(res, or_res)) {
    throw [
          Caml_builtin_exceptions.failure,
          "int64_of_string"
        ];
  }
  return or_res;
}

function int_of_base(param) {
  switch (param) {
    case 0 : 
        return 8;
    case 1 : 
        return 16;
    case 2 : 
        return 10;
    
  }
}

function lowercase(c) {
  if (c >= /* "A" */65 && c <= /* "Z" */90 || c >= /* "\192" */192 && c <= /* "\214" */214 || c >= /* "\216" */216 && c <= /* "\222" */222) {
    return c + 32 | 0;
  } else {
    return c;
  }
}

function parse_format(fmt) {
  var len = fmt.length;
  if (len > 31) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "format_int: format too long"
        ];
  }
  var f = /* record */[
    /* justify */"+",
    /* signstyle */"-",
    /* filter */" ",
    /* alternate : false */0,
    /* base : Dec */2,
    /* signedconv : false */0,
    /* width */0,
    /* uppercase : false */0,
    /* sign */1,
    /* prec */-1,
    /* conv */"f"
  ];
  var _i = 0;
  while(true) {
    var i = _i;
    if (i >= len) {
      return f;
    } else {
      var c = fmt.charCodeAt(i);
      var exit = 0;
      if (c >= 69) {
        if (c >= 88) {
          if (c >= 121) {
            exit = 1;
          } else {
            switch (c - 88 | 0) {
              case 0 : 
                  f[/* base */4] = /* Hex */1;
                  f[/* uppercase */7] = /* true */1;
                  _i = i + 1 | 0;
                  continue ;
                  case 13 : 
              case 14 : 
              case 15 : 
                  exit = 5;
                  break;
              case 12 : 
              case 17 : 
                  exit = 4;
                  break;
              case 23 : 
                  f[/* base */4] = /* Oct */0;
                  _i = i + 1 | 0;
                  continue ;
                  case 29 : 
                  f[/* base */4] = /* Dec */2;
                  _i = i + 1 | 0;
                  continue ;
                  case 1 : 
              case 2 : 
              case 3 : 
              case 4 : 
              case 5 : 
              case 6 : 
              case 7 : 
              case 8 : 
              case 9 : 
              case 10 : 
              case 11 : 
              case 16 : 
              case 18 : 
              case 19 : 
              case 20 : 
              case 21 : 
              case 22 : 
              case 24 : 
              case 25 : 
              case 26 : 
              case 27 : 
              case 28 : 
              case 30 : 
              case 31 : 
                  exit = 1;
                  break;
              case 32 : 
                  f[/* base */4] = /* Hex */1;
                  _i = i + 1 | 0;
                  continue ;
                  
            }
          }
        } else if (c >= 72) {
          exit = 1;
        } else {
          f[/* signedconv */5] = /* true */1;
          f[/* uppercase */7] = /* true */1;
          f[/* conv */10] = String.fromCharCode(lowercase(c));
          _i = i + 1 | 0;
          continue ;
          
        }
      } else {
        var switcher = c - 32 | 0;
        if (switcher > 25 || switcher < 0) {
          exit = 1;
        } else {
          switch (switcher) {
            case 3 : 
                f[/* alternate */3] = /* true */1;
                _i = i + 1 | 0;
                continue ;
                case 0 : 
            case 11 : 
                exit = 2;
                break;
            case 13 : 
                f[/* justify */0] = "-";
                _i = i + 1 | 0;
                continue ;
                case 14 : 
                f[/* prec */9] = 0;
                var j = i + 1 | 0;
                while((function(j){
                    return function () {
                      var w = fmt.charCodeAt(j) - /* "0" */48 | 0;
                      return +(w >= 0 && w <= 9);
                    }
                    }(j))()) {
                  f[/* prec */9] = (Caml_int32.imul(f[/* prec */9], 10) + fmt.charCodeAt(j) | 0) - /* "0" */48 | 0;
                  j = j + 1 | 0;
                };
                _i = j;
                continue ;
                case 1 : 
            case 2 : 
            case 4 : 
            case 5 : 
            case 6 : 
            case 7 : 
            case 8 : 
            case 9 : 
            case 10 : 
            case 12 : 
            case 15 : 
                exit = 1;
                break;
            case 16 : 
                f[/* filter */2] = "0";
                _i = i + 1 | 0;
                continue ;
                case 17 : 
            case 18 : 
            case 19 : 
            case 20 : 
            case 21 : 
            case 22 : 
            case 23 : 
            case 24 : 
            case 25 : 
                exit = 3;
                break;
            
          }
        }
      }
      switch (exit) {
        case 1 : 
            _i = i + 1 | 0;
            continue ;
            case 2 : 
            f[/* signstyle */1] = String.fromCharCode(c);
            _i = i + 1 | 0;
            continue ;
            case 3 : 
            f[/* width */6] = 0;
            var j$1 = i;
            while((function(j$1){
                return function () {
                  var w = fmt.charCodeAt(j$1) - /* "0" */48 | 0;
                  return +(w >= 0 && w <= 9);
                }
                }(j$1))()) {
              f[/* width */6] = (Caml_int32.imul(f[/* width */6], 10) + fmt.charCodeAt(j$1) | 0) - /* "0" */48 | 0;
              j$1 = j$1 + 1 | 0;
            };
            _i = j$1;
            continue ;
            case 4 : 
            f[/* signedconv */5] = /* true */1;
            f[/* base */4] = /* Dec */2;
            _i = i + 1 | 0;
            continue ;
            case 5 : 
            f[/* signedconv */5] = /* true */1;
            f[/* conv */10] = String.fromCharCode(c);
            _i = i + 1 | 0;
            continue ;
            
      }
    }
  };
}

function finish_formatting(param, rawbuffer) {
  var justify = param[/* justify */0];
  var signstyle = param[/* signstyle */1];
  var filter = param[/* filter */2];
  var alternate = param[/* alternate */3];
  var base = param[/* base */4];
  var signedconv = param[/* signedconv */5];
  var width = param[/* width */6];
  var uppercase = param[/* uppercase */7];
  var sign = param[/* sign */8];
  var len = rawbuffer.length;
  if (signedconv && (sign < 0 || signstyle !== "-")) {
    len = len + 1 | 0;
  }
  if (alternate) {
    if (base) {
      if (base === /* Hex */1) {
        len = len + 2 | 0;
      }
      
    } else {
      len = len + 1 | 0;
    }
  }
  var buffer = "";
  if (justify === "+" && filter === " ") {
    for(var i = len ,i_finish = width - 1 | 0; i <= i_finish; ++i){
      buffer = buffer + filter;
    }
  }
  if (signedconv) {
    if (sign < 0) {
      buffer = buffer + "-";
    } else if (signstyle !== "-") {
      buffer = buffer + signstyle;
    }
    
  }
  if (alternate && base === /* Oct */0) {
    buffer = buffer + "0";
  }
  if (alternate && base === /* Hex */1) {
    buffer = buffer + "0x";
  }
  if (justify === "+" && filter === "0") {
    for(var i$1 = len ,i_finish$1 = width - 1 | 0; i$1 <= i_finish$1; ++i$1){
      buffer = buffer + filter;
    }
  }
  buffer = uppercase ? buffer + rawbuffer.toUpperCase() : buffer + rawbuffer;
  if (justify === "-") {
    for(var i$2 = len ,i_finish$2 = width - 1 | 0; i$2 <= i_finish$2; ++i$2){
      buffer = buffer + " ";
    }
  }
  return buffer;
}

function caml_format_int(fmt, i) {
  if (fmt === "%d") {
    return String(i);
  } else {
    var f = parse_format(fmt);
    var f$1 = f;
    var i$1 = i;
    var i$2 = i$1 < 0 ? (
        f$1[/* signedconv */5] ? (f$1[/* sign */8] = -1, -i$1) : (i$1 >>> 0)
      ) : i$1;
    var s = i$2.toString(int_of_base(f$1[/* base */4]));
    if (f$1[/* prec */9] >= 0) {
      f$1[/* filter */2] = " ";
      var n = f$1[/* prec */9] - s.length | 0;
      if (n > 0) {
        s = Caml_utils.repeat(n, "0") + s;
      }
      
    }
    return finish_formatting(f$1, s);
  }
}

function caml_int64_format(fmt, x) {
  var f = parse_format(fmt);
  var x$1 = f[/* signedconv */5] && Caml_int64.lt(x, /* int64 */[
        /* hi */0,
        /* lo */0
      ]) ? (f[/* sign */8] = -1, Caml_int64.neg(x)) : x;
  var s = "";
  var match = f[/* base */4];
  switch (match) {
    case 0 : 
        var wbase = /* int64 */[
          /* hi */0,
          /* lo */8
        ];
        var cvtbl = "01234567";
        if (Caml_int64.lt(x$1, /* int64 */[
                /* hi */0,
                /* lo */0
              ])) {
          var y = Caml_int64.discard_sign(x$1);
          var match$1 = Caml_int64.div_mod(y, wbase);
          var quotient = Caml_int64.add(/* int64 */[
                /* hi */268435456,
                /* lo */0
              ], match$1[0]);
          var modulus = match$1[1];
          s = String.fromCharCode(cvtbl.charCodeAt(modulus[1] | 0)) + s;
          while(Caml_int64.neq(quotient, /* int64 */[
                  /* hi */0,
                  /* lo */0
                ])) {
            var match$2 = Caml_int64.div_mod(quotient, wbase);
            quotient = match$2[0];
            modulus = match$2[1];
            s = String.fromCharCode(cvtbl.charCodeAt(modulus[1] | 0)) + s;
          };
        } else {
          var match$3 = Caml_int64.div_mod(x$1, wbase);
          var quotient$1 = match$3[0];
          var modulus$1 = match$3[1];
          s = String.fromCharCode(cvtbl.charCodeAt(modulus$1[1] | 0)) + s;
          while(Caml_int64.neq(quotient$1, /* int64 */[
                  /* hi */0,
                  /* lo */0
                ])) {
            var match$4 = Caml_int64.div_mod(quotient$1, wbase);
            quotient$1 = match$4[0];
            modulus$1 = match$4[1];
            s = String.fromCharCode(cvtbl.charCodeAt(modulus$1[1] | 0)) + s;
          };
        }
        break;
    case 1 : 
        s = Caml_int64.to_hex(x$1) + s;
        break;
    case 2 : 
        var wbase$1 = /* int64 */[
          /* hi */0,
          /* lo */10
        ];
        var cvtbl$1 = "0123456789";
        if (Caml_int64.lt(x$1, /* int64 */[
                /* hi */0,
                /* lo */0
              ])) {
          var y$1 = Caml_int64.discard_sign(x$1);
          var match$5 = Caml_int64.div_mod(y$1, wbase$1);
          var match$6 = Caml_int64.div_mod(Caml_int64.add(/* int64 */[
                    /* hi */0,
                    /* lo */8
                  ], match$5[1]), wbase$1);
          var quotient$2 = Caml_int64.add(Caml_int64.add(/* int64 */[
                    /* hi */214748364,
                    /* lo */3435973836
                  ], match$5[0]), match$6[0]);
          var modulus$2 = match$6[1];
          s = String.fromCharCode(cvtbl$1.charCodeAt(modulus$2[1] | 0)) + s;
          while(Caml_int64.neq(quotient$2, /* int64 */[
                  /* hi */0,
                  /* lo */0
                ])) {
            var match$7 = Caml_int64.div_mod(quotient$2, wbase$1);
            quotient$2 = match$7[0];
            modulus$2 = match$7[1];
            s = String.fromCharCode(cvtbl$1.charCodeAt(modulus$2[1] | 0)) + s;
          };
        } else {
          var match$8 = Caml_int64.div_mod(x$1, wbase$1);
          var quotient$3 = match$8[0];
          var modulus$3 = match$8[1];
          s = String.fromCharCode(cvtbl$1.charCodeAt(modulus$3[1] | 0)) + s;
          while(Caml_int64.neq(quotient$3, /* int64 */[
                  /* hi */0,
                  /* lo */0
                ])) {
            var match$9 = Caml_int64.div_mod(quotient$3, wbase$1);
            quotient$3 = match$9[0];
            modulus$3 = match$9[1];
            s = String.fromCharCode(cvtbl$1.charCodeAt(modulus$3[1] | 0)) + s;
          };
        }
        break;
    
  }
  if (f[/* prec */9] >= 0) {
    f[/* filter */2] = " ";
    var n = f[/* prec */9] - s.length | 0;
    if (n > 0) {
      s = Caml_utils.repeat(n, "0") + s;
    }
    
  }
  return finish_formatting(f, s);
}

function caml_format_float(fmt, x) {
  var f = parse_format(fmt);
  var prec = f[/* prec */9] < 0 ? 6 : f[/* prec */9];
  var x$1 = x < 0 ? (f[/* sign */8] = -1, -x) : x;
  var s = "";
  if (isNaN(x$1)) {
    s = "nan";
    f[/* filter */2] = " ";
  } else if (isFinite(x$1)) {
    var match = f[/* conv */10];
    switch (match) {
      case "e" : 
          s = x$1.toExponential(prec);
          var i = s.length;
          if (s[i - 3 | 0] === "e") {
            s = s.slice(0, i - 1 | 0) + ("0" + s.slice(i - 1 | 0));
          }
          break;
      case "f" : 
          s = x$1.toFixed(prec);
          break;
      case "g" : 
          var prec$1 = prec !== 0 ? prec : 1;
          s = x$1.toExponential(prec$1 - 1 | 0);
          var j = s.indexOf("e");
          var exp = Number(s.slice(j + 1 | 0)) | 0;
          if (exp < -4 || x$1 >= 1e21 || x$1.toFixed().length > prec$1) {
            var i$1 = j - 1 | 0;
            while(s[i$1] === "0") {
              i$1 = i$1 - 1 | 0;
            };
            if (s[i$1] === ".") {
              i$1 = i$1 - 1 | 0;
            }
            s = s.slice(0, i$1 + 1 | 0) + s.slice(j);
            var i$2 = s.length;
            if (s[i$2 - 3 | 0] === "e") {
              s = s.slice(0, i$2 - 1 | 0) + ("0" + s.slice(i$2 - 1 | 0));
            }
            
          } else {
            var p = prec$1;
            if (exp < 0) {
              p = p - (exp + 1 | 0) | 0;
              s = x$1.toFixed(p);
            } else {
              while((function () {
                      s = x$1.toFixed(p);
                      return +(s.length > (prec$1 + 1 | 0));
                    })()) {
                p = p - 1 | 0;
              };
            }
            if (p !== 0) {
              var k = s.length - 1 | 0;
              while(s[k] === "0") {
                k = k - 1 | 0;
              };
              if (s[k] === ".") {
                k = k - 1 | 0;
              }
              s = s.slice(0, k + 1 | 0);
            }
            
          }
          break;
      default:
        
    }
  } else {
    s = "inf";
    f[/* filter */2] = " ";
  }
  return finish_formatting(f, s);
}

var float_of_string = (
  function (s, caml_failwith) {
    var res = +s;
    if ((s.length > 0) && (res === res))
        return res;
    s = s.replace(/_/g, "");
    res = +s;
    if (((s.length > 0) && (res === res)) || /^[+-]?nan$/i.test(s)) {
        return res;
    }
    ;
    if (/^ *0x[0-9a-f_]+p[+-]?[0-9_]+/i.test(s)) {
        var pidx = s.indexOf('p');
        pidx = (pidx == -1) ? s.indexOf('P') : pidx;
        var exp = +s.substring(pidx + 1);
        res = +s.substring(0, pidx);
        return res * Math.pow(2, exp);
    }
    if (/^\+?inf(inity)?$/i.test(s))
        return Infinity;
    if (/^-inf(inity)?$/i.test(s))
        return -Infinity;
    caml_failwith("float_of_string");
}

);

function caml_float_of_string(s) {
  return Curry._2(float_of_string, s, caml_failwith);
}

var caml_nativeint_format = caml_format_int;

var caml_int32_format = caml_format_int;

var caml_int32_of_string = caml_int_of_string;

var caml_nativeint_of_string = caml_int_of_string;

exports.caml_format_float        = caml_format_float;
exports.caml_format_int          = caml_format_int;
exports.caml_nativeint_format    = caml_nativeint_format;
exports.caml_int32_format        = caml_int32_format;
exports.caml_float_of_string     = caml_float_of_string;
exports.caml_int64_format        = caml_int64_format;
exports.caml_int_of_string       = caml_int_of_string;
exports.caml_int32_of_string     = caml_int32_of_string;
exports.caml_int64_of_string     = caml_int64_of_string;
exports.caml_nativeint_of_string = caml_nativeint_of_string;
/* float_of_string Not a pure module */

},{"./caml_builtin_exceptions.js":13,"./caml_int32.js":16,"./caml_int64.js":17,"./caml_utils.js":25,"./curry.js":30}],16:[function(require,module,exports){
'use strict';

var Caml_builtin_exceptions = require("./caml_builtin_exceptions.js");

function div(x, y) {
  if (y === 0) {
    throw Caml_builtin_exceptions.division_by_zero;
  } else {
    return x / y | 0;
  }
}

function mod_(x, y) {
  if (y === 0) {
    throw Caml_builtin_exceptions.division_by_zero;
  } else {
    return x % y;
  }
}

function caml_bswap16(x) {
  return ((x & 255) << 8) | ((x & 65280) >>> 8);
}

function caml_int32_bswap(x) {
  return ((x & 255) << 24) | ((x & 65280) << 8) | ((x & 16711680) >>> 8) | ((x & 4278190080) >>> 24);
}

var imul = ( Math.imul || function (x,y) {
  y |= 0; return ((((x >> 16) * y) << 16) + (x & 0xffff) * y)|0; 
}
);

var caml_nativeint_bswap = caml_int32_bswap;

exports.div                  = div;
exports.mod_                 = mod_;
exports.caml_bswap16         = caml_bswap16;
exports.caml_int32_bswap     = caml_int32_bswap;
exports.caml_nativeint_bswap = caml_nativeint_bswap;
exports.imul                 = imul;
/* imul Not a pure module */

},{"./caml_builtin_exceptions.js":13}],17:[function(require,module,exports){
'use strict';

var Caml_obj                = require("./caml_obj.js");
var Caml_int32              = require("./caml_int32.js");
var Caml_utils              = require("./caml_utils.js");
var Caml_builtin_exceptions = require("./caml_builtin_exceptions.js");

var min_int = /* record */[
  /* hi */-2147483648,
  /* lo */0
];

var max_int = /* record */[
  /* hi */134217727,
  /* lo */1
];

var one = /* record */[
  /* hi */0,
  /* lo */1
];

var zero = /* record */[
  /* hi */0,
  /* lo */0
];

var neg_one = /* record */[
  /* hi */-1,
  /* lo */4294967295
];

function neg_signed(x) {
  return +((x & 2147483648) !== 0);
}

function add(param, param$1) {
  var other_low_ = param$1[/* lo */1];
  var this_low_ = param[/* lo */1];
  var lo = this_low_ + other_low_ & 4294967295;
  var overflow = neg_signed(this_low_) && (neg_signed(other_low_) || !neg_signed(lo)) || neg_signed(other_low_) && !neg_signed(lo) ? 1 : 0;
  var hi = param[/* hi */0] + param$1[/* hi */0] + overflow & 4294967295;
  return /* record */[
          /* hi */hi,
          /* lo */(lo >>> 0)
        ];
}

function not(param) {
  var hi = param[/* hi */0] ^ -1;
  var lo = param[/* lo */1] ^ -1;
  return /* record */[
          /* hi */hi,
          /* lo */(lo >>> 0)
        ];
}

function eq(x, y) {
  if (x[/* hi */0] === y[/* hi */0]) {
    return +(x[/* lo */1] === y[/* lo */1]);
  } else {
    return /* false */0;
  }
}

function neg(x) {
  if (eq(x, min_int)) {
    return min_int;
  } else {
    return add(not(x), one);
  }
}

function sub(x, y) {
  return add(x, neg(y));
}

function lsl_(x, numBits) {
  if (numBits) {
    var lo = x[/* lo */1];
    if (numBits >= 32) {
      return /* record */[
              /* hi */(lo << (numBits - 32 | 0)),
              /* lo */0
            ];
    } else {
      var hi = (lo >>> (32 - numBits | 0)) | (x[/* hi */0] << numBits);
      return /* record */[
              /* hi */hi,
              /* lo */((lo << numBits) >>> 0)
            ];
    }
  } else {
    return x;
  }
}

function lsr_(x, numBits) {
  if (numBits) {
    var hi = x[/* hi */0];
    var offset = numBits - 32 | 0;
    if (offset) {
      if (offset > 0) {
        var lo = (hi >>> offset);
        return /* record */[
                /* hi */0,
                /* lo */(lo >>> 0)
              ];
      } else {
        var hi$1 = (hi >>> numBits);
        var lo$1 = (hi << (-offset | 0)) | (x[/* lo */1] >>> numBits);
        return /* record */[
                /* hi */hi$1,
                /* lo */(lo$1 >>> 0)
              ];
      }
    } else {
      return /* record */[
              /* hi */0,
              /* lo */(hi >>> 0)
            ];
    }
  } else {
    return x;
  }
}

function asr_(x, numBits) {
  if (numBits) {
    var hi = x[/* hi */0];
    if (numBits < 32) {
      var hi$1 = (hi >> numBits);
      var lo = (hi << (32 - numBits | 0)) | (x[/* lo */1] >>> numBits);
      return /* record */[
              /* hi */hi$1,
              /* lo */(lo >>> 0)
            ];
    } else {
      var lo$1 = (hi >> (numBits - 32 | 0));
      return /* record */[
              /* hi */hi >= 0 ? 0 : -1,
              /* lo */(lo$1 >>> 0)
            ];
    }
  } else {
    return x;
  }
}

function is_zero(param) {
  if (param[/* hi */0] !== 0 || param[/* lo */1] !== 0) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function mul(_this, _other) {
  while(true) {
    var other = _other;
    var $$this = _this;
    var exit = 0;
    var lo;
    var this_hi = $$this[/* hi */0];
    var exit$1 = 0;
    var exit$2 = 0;
    var exit$3 = 0;
    if (this_hi !== 0) {
      exit$3 = 4;
    } else if ($$this[/* lo */1] !== 0) {
      exit$3 = 4;
    } else {
      return zero;
    }
    if (exit$3 === 4) {
      if (other[/* hi */0] !== 0) {
        exit$2 = 3;
      } else if (other[/* lo */1] !== 0) {
        exit$2 = 3;
      } else {
        return zero;
      }
    }
    if (exit$2 === 3) {
      if (this_hi !== -2147483648) {
        exit$1 = 2;
      } else if ($$this[/* lo */1] !== 0) {
        exit$1 = 2;
      } else {
        lo = other[/* lo */1];
        exit = 1;
      }
    }
    if (exit$1 === 2) {
      var other_hi = other[/* hi */0];
      var lo$1 = $$this[/* lo */1];
      var exit$4 = 0;
      if (other_hi !== -2147483648) {
        exit$4 = 3;
      } else if (other[/* lo */1] !== 0) {
        exit$4 = 3;
      } else {
        lo = lo$1;
        exit = 1;
      }
      if (exit$4 === 3) {
        var other_lo = other[/* lo */1];
        if (this_hi < 0) {
          if (other_hi < 0) {
            _other = neg(other);
            _this = neg($$this);
            continue ;
            
          } else {
            return neg(mul(neg($$this), other));
          }
        } else if (other_hi < 0) {
          return neg(mul($$this, neg(other)));
        } else {
          var a48 = (this_hi >>> 16);
          var a32 = this_hi & 65535;
          var a16 = (lo$1 >>> 16);
          var a00 = lo$1 & 65535;
          var b48 = (other_hi >>> 16);
          var b32 = other_hi & 65535;
          var b16 = (other_lo >>> 16);
          var b00 = other_lo & 65535;
          var c48 = 0;
          var c32 = 0;
          var c16 = 0;
          var c00 = a00 * b00;
          c16 = (c00 >>> 16) + a16 * b00;
          c32 = (c16 >>> 16);
          c16 = (c16 & 65535) + a00 * b16;
          c32 = c32 + (c16 >>> 16) + a32 * b00;
          c48 = (c32 >>> 16);
          c32 = (c32 & 65535) + a16 * b16;
          c48 += (c32 >>> 16);
          c32 = (c32 & 65535) + a00 * b32;
          c48 += (c32 >>> 16);
          c32 = c32 & 65535;
          c48 = c48 + (a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48) & 65535;
          var hi = c32 | (c48 << 16);
          var lo$2 = c00 & 65535 | ((c16 & 65535) << 16);
          return /* record */[
                  /* hi */hi,
                  /* lo */(lo$2 >>> 0)
                ];
        }
      }
      
    }
    if (exit === 1) {
      if ((lo & 1) === 0) {
        return zero;
      } else {
        return min_int;
      }
    }
    
  };
}

function swap(param) {
  var hi = Caml_int32.caml_int32_bswap(param[/* lo */1]);
  var lo = Caml_int32.caml_int32_bswap(param[/* hi */0]);
  return /* record */[
          /* hi */hi,
          /* lo */(lo >>> 0)
        ];
}

function xor(param, param$1) {
  return /* record */[
          /* hi */param[/* hi */0] ^ param$1[/* hi */0],
          /* lo */((param[/* lo */1] ^ param$1[/* lo */1]) >>> 0)
        ];
}

function or_(param, param$1) {
  return /* record */[
          /* hi */param[/* hi */0] | param$1[/* hi */0],
          /* lo */((param[/* lo */1] | param$1[/* lo */1]) >>> 0)
        ];
}

function and_(param, param$1) {
  return /* record */[
          /* hi */param[/* hi */0] & param$1[/* hi */0],
          /* lo */((param[/* lo */1] & param$1[/* lo */1]) >>> 0)
        ];
}

function ge(param, param$1) {
  var other_hi = param$1[/* hi */0];
  var hi = param[/* hi */0];
  if (hi > other_hi) {
    return /* true */1;
  } else if (hi < other_hi) {
    return /* false */0;
  } else {
    return +(param[/* lo */1] >= param$1[/* lo */1]);
  }
}

function neq(x, y) {
  return 1 - eq(x, y);
}

function lt(x, y) {
  return 1 - ge(x, y);
}

function gt(x, y) {
  if (x[/* hi */0] > y[/* hi */0]) {
    return /* true */1;
  } else if (x[/* hi */0] < y[/* hi */0]) {
    return /* false */0;
  } else {
    return +(x[/* lo */1] > y[/* lo */1]);
  }
}

function le(x, y) {
  return 1 - gt(x, y);
}

function to_float(param) {
  return param[/* hi */0] * (0x100000000) + param[/* lo */1];
}

var two_ptr_32_dbl = Math.pow(2, 32);

var two_ptr_63_dbl = Math.pow(2, 63);

var neg_two_ptr_63 = -Math.pow(2, 63);

function of_float(x) {
  if (isNaN(x) || !isFinite(x)) {
    return zero;
  } else if (x <= neg_two_ptr_63) {
    return min_int;
  } else if (x + 1 >= two_ptr_63_dbl) {
    return max_int;
  } else if (x < 0) {
    return neg(of_float(-x));
  } else {
    var hi = x / two_ptr_32_dbl | 0;
    var lo = x % two_ptr_32_dbl | 0;
    return /* record */[
            /* hi */hi,
            /* lo */(lo >>> 0)
          ];
  }
}

function div(_self, _other) {
  while(true) {
    var other = _other;
    var self = _self;
    var self_hi = self[/* hi */0];
    var exit = 0;
    var exit$1 = 0;
    if (other[/* hi */0] !== 0) {
      exit$1 = 2;
    } else if (other[/* lo */1] !== 0) {
      exit$1 = 2;
    } else {
      throw Caml_builtin_exceptions.division_by_zero;
    }
    if (exit$1 === 2) {
      if (self_hi !== -2147483648) {
        if (self_hi !== 0) {
          exit = 1;
        } else if (self[/* lo */1] !== 0) {
          exit = 1;
        } else {
          return zero;
        }
      } else if (self[/* lo */1] !== 0) {
        exit = 1;
      } else if (eq(other, one) || eq(other, neg_one)) {
        return self;
      } else if (eq(other, min_int)) {
        return one;
      } else {
        var other_hi = other[/* hi */0];
        var half_this = asr_(self, 1);
        var approx = lsl_(div(half_this, other), 1);
        var exit$2 = 0;
        if (approx[/* hi */0] !== 0) {
          exit$2 = 3;
        } else if (approx[/* lo */1] !== 0) {
          exit$2 = 3;
        } else if (other_hi < 0) {
          return one;
        } else {
          return neg(one);
        }
        if (exit$2 === 3) {
          var y = mul(other, approx);
          var rem = add(self, neg(y));
          return add(approx, div(rem, other));
        }
        
      }
    }
    if (exit === 1) {
      var other_hi$1 = other[/* hi */0];
      var exit$3 = 0;
      if (other_hi$1 !== -2147483648) {
        exit$3 = 2;
      } else if (other[/* lo */1] !== 0) {
        exit$3 = 2;
      } else {
        return zero;
      }
      if (exit$3 === 2) {
        if (self_hi < 0) {
          if (other_hi$1 < 0) {
            _other = neg(other);
            _self = neg(self);
            continue ;
            
          } else {
            return neg(div(neg(self), other));
          }
        } else if (other_hi$1 < 0) {
          return neg(div(self, neg(other)));
        } else {
          var res = zero;
          var rem$1 = self;
          while(ge(rem$1, other)) {
            var approx$1 = Math.max(1, Math.floor(to_float(rem$1) / to_float(other)));
            var log2 = Math.ceil(Math.log(approx$1) / Math.LN2);
            var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
            var approxRes = of_float(approx$1);
            var approxRem = mul(approxRes, other);
            while(approxRem[/* hi */0] < 0 || gt(approxRem, rem$1)) {
              approx$1 -= delta;
              approxRes = of_float(approx$1);
              approxRem = mul(approxRes, other);
            };
            if (is_zero(approxRes)) {
              approxRes = one;
            }
            res = add(res, approxRes);
            rem$1 = add(rem$1, neg(approxRem));
          };
          return res;
        }
      }
      
    }
    
  };
}

function mod_(self, other) {
  var y = mul(div(self, other), other);
  return add(self, neg(y));
}

function div_mod(self, other) {
  var quotient = div(self, other);
  var y = mul(quotient, other);
  return /* tuple */[
          quotient,
          add(self, neg(y))
        ];
}

function compare(self, other) {
  var v = Caml_obj.caml_nativeint_compare(self[/* hi */0], other[/* hi */0]);
  if (v) {
    return v;
  } else {
    return Caml_obj.caml_nativeint_compare(self[/* lo */1], other[/* lo */1]);
  }
}

function of_int32(lo) {
  return /* record */[
          /* hi */lo < 0 ? -1 : 0,
          /* lo */(lo >>> 0)
        ];
}

function to_int32(x) {
  return x[/* lo */1] | 0;
}

function to_hex(x) {
  var aux = function (v) {
    return (v >>> 0).toString(16);
  };
  var match = x[/* hi */0];
  var match$1 = x[/* lo */1];
  var exit = 0;
  if (match !== 0) {
    exit = 1;
  } else if (match$1 !== 0) {
    exit = 1;
  } else {
    return "0";
  }
  if (exit === 1) {
    if (match$1 !== 0) {
      if (match !== 0) {
        var lo = aux(x[/* lo */1]);
        var pad = 8 - lo.length | 0;
        if (pad <= 0) {
          return aux(x[/* hi */0]) + lo;
        } else {
          return aux(x[/* hi */0]) + (Caml_utils.repeat(pad, "0") + lo);
        }
      } else {
        return aux(x[/* lo */1]);
      }
    } else {
      return aux(x[/* hi */0]) + "00000000";
    }
  }
  
}

function discard_sign(x) {
  return /* record */[
          /* hi */2147483647 & x[/* hi */0],
          /* lo */x[/* lo */1]
        ];
}

function float_of_bits(x) {
  var int32 = new Int32Array(/* array */[
        x[/* lo */1],
        x[/* hi */0]
      ]);
  return new Float64Array(int32.buffer)[0];
}

function bits_of_float(x) {
  var u = new Float64Array(/* float array */[x]);
  var int32 = new Int32Array(u.buffer);
  var x$1 = int32[1];
  var hi = x$1;
  var x$2 = int32[0];
  var lo = x$2;
  return /* record */[
          /* hi */hi,
          /* lo */(lo >>> 0)
        ];
}

function get64(s, i) {
  var hi = (s.charCodeAt(i + 4 | 0) << 32) | (s.charCodeAt(i + 5 | 0) << 40) | (s.charCodeAt(i + 6 | 0) << 48) | (s.charCodeAt(i + 7 | 0) << 56);
  var lo = s.charCodeAt(i) | (s.charCodeAt(i + 1 | 0) << 8) | (s.charCodeAt(i + 2 | 0) << 16) | (s.charCodeAt(i + 3 | 0) << 24);
  return /* record */[
          /* hi */hi,
          /* lo */(lo >>> 0)
        ];
}

exports.min_int       = min_int;
exports.max_int       = max_int;
exports.one           = one;
exports.zero          = zero;
exports.not           = not;
exports.of_int32      = of_int32;
exports.to_int32      = to_int32;
exports.add           = add;
exports.neg           = neg;
exports.sub           = sub;
exports.lsl_          = lsl_;
exports.lsr_          = lsr_;
exports.asr_          = asr_;
exports.is_zero       = is_zero;
exports.mul           = mul;
exports.xor           = xor;
exports.or_           = or_;
exports.and_          = and_;
exports.swap          = swap;
exports.ge            = ge;
exports.eq            = eq;
exports.neq           = neq;
exports.lt            = lt;
exports.gt            = gt;
exports.le            = le;
exports.to_float      = to_float;
exports.of_float      = of_float;
exports.div           = div;
exports.mod_          = mod_;
exports.div_mod       = div_mod;
exports.compare       = compare;
exports.to_hex        = to_hex;
exports.discard_sign  = discard_sign;
exports.float_of_bits = float_of_bits;
exports.bits_of_float = bits_of_float;
exports.get64         = get64;
/* two_ptr_32_dbl Not a pure module */

},{"./caml_builtin_exceptions.js":13,"./caml_int32.js":16,"./caml_obj.js":20,"./caml_utils.js":25}],18:[function(require,module,exports){
(function (process){
'use strict';

var Curry                   = require("./curry.js");
var Caml_builtin_exceptions = require("./caml_builtin_exceptions.js");

function $caret(prim, prim$1) {
  return prim + prim$1;
}

var stdin = undefined;

var stdout = /* record */[
  /* buffer */"",
  /* output */(function (_, s) {
      var v = s.length - 1 | 0;
      if (( (typeof process !== "undefined") && process.stdout && process.stdout.write)) {
        return ( process.stdout.write )(s);
      } else if (s[v] === "\n") {
        console.log(s.slice(0, v));
        return /* () */0;
      } else {
        console.log(s);
        return /* () */0;
      }
    })
];

var stderr = /* record */[
  /* buffer */"",
  /* output */(function (_, s) {
      var v = s.length - 1 | 0;
      if (s[v] === "\n") {
        console.log(s.slice(0, v));
        return /* () */0;
      } else {
        console.log(s);
        return /* () */0;
      }
    })
];

function caml_ml_open_descriptor_in() {
  throw [
        Caml_builtin_exceptions.failure,
        "caml_ml_open_descriptor_in not implemented"
      ];
}

function caml_ml_open_descriptor_out() {
  throw [
        Caml_builtin_exceptions.failure,
        "caml_ml_open_descriptor_out not implemented"
      ];
}

function caml_ml_flush(oc) {
  if (oc[/* buffer */0] !== "") {
    Curry._2(oc[/* output */1], oc, oc[/* buffer */0]);
    oc[/* buffer */0] = "";
    return /* () */0;
  } else {
    return 0;
  }
}

var node_std_output = (function (s){
   return (typeof process !== "undefined") && process.stdout && (process.stdout.write(s), true);
   }
);

function caml_ml_output(oc, str, offset, len) {
  var str$1 = offset === 0 && len === str.length ? str : str.slice(offset, len);
  if (( (typeof process !== "undefined") && process.stdout && process.stdout.write ) && oc === stdout) {
    return ( process.stdout.write )(str$1);
  } else {
    var id = str$1.lastIndexOf("\n");
    if (id < 0) {
      oc[/* buffer */0] = oc[/* buffer */0] + str$1;
      return /* () */0;
    } else {
      oc[/* buffer */0] = oc[/* buffer */0] + str$1.slice(0, id + 1 | 0);
      caml_ml_flush(oc);
      oc[/* buffer */0] = oc[/* buffer */0] + str$1.slice(id + 1 | 0);
      return /* () */0;
    }
  }
}

function caml_ml_output_char(oc, $$char) {
  return caml_ml_output(oc, String.fromCharCode($$char), 0, 1);
}

function caml_ml_input(_, _$1, _$2, _$3) {
  throw [
        Caml_builtin_exceptions.failure,
        "caml_ml_input ic not implemented"
      ];
}

function caml_ml_input_char() {
  throw [
        Caml_builtin_exceptions.failure,
        "caml_ml_input_char not implemnted"
      ];
}

function caml_ml_out_channels_list() {
  return /* :: */[
          stdout,
          /* :: */[
            stderr,
            /* [] */0
          ]
        ];
}

exports.$caret                      = $caret;
exports.stdin                       = stdin;
exports.stdout                      = stdout;
exports.stderr                      = stderr;
exports.caml_ml_open_descriptor_in  = caml_ml_open_descriptor_in;
exports.caml_ml_open_descriptor_out = caml_ml_open_descriptor_out;
exports.caml_ml_flush               = caml_ml_flush;
exports.node_std_output             = node_std_output;
exports.caml_ml_output              = caml_ml_output;
exports.caml_ml_output_char         = caml_ml_output_char;
exports.caml_ml_input               = caml_ml_input;
exports.caml_ml_input_char          = caml_ml_input_char;
exports.caml_ml_out_channels_list   = caml_ml_out_channels_list;
/* stdin Not a pure module */

}).call(this,require('_process'))
},{"./caml_builtin_exceptions.js":13,"./curry.js":30,"_process":46}],19:[function(require,module,exports){
'use strict';


var not_implemented = (function (s){ throw new Error(s)});

exports.not_implemented = not_implemented;
/* not_implemented Not a pure module */

},{}],20:[function(require,module,exports){
'use strict';

var Block                   = require("./block.js");
var Caml_builtin_exceptions = require("./caml_builtin_exceptions.js");

function caml_obj_dup(x) {
  var len = x.length | 0;
  var v = new Array(len);
  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
    v[i] = x[i];
  }
  v.tag = x.tag | 0;
  return v;
}

function caml_obj_truncate(x, new_size) {
  var len = x.length | 0;
  if (new_size <= 0 || new_size > len) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Obj.truncate"
        ];
  } else if (len !== new_size) {
    for(var i = new_size ,i_finish = len - 1 | 0; i <= i_finish; ++i){
      x[i] = 0;
    }
    x.length = new_size;
    return /* () */0;
  } else {
    return 0;
  }
}

function caml_lazy_make_forward(x) {
  return Block.__(250, [x]);
}

function caml_update_dummy(x, y) {
  var len = y.length | 0;
  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
    x[i] = y[i];
  }
  var y_tag = y.tag | 0;
  if (y_tag !== 0) {
    x.tag = y_tag;
    return /* () */0;
  } else {
    return 0;
  }
}

function caml_int_compare(x, y) {
  if (x < y) {
    return -1;
  } else if (x === y) {
    return 0;
  } else {
    return 1;
  }
}

function caml_compare(_a, _b) {
  while(true) {
    var b = _b;
    var a = _a;
    if (a === b) {
      return 0;
    } else {
      var a_type = typeof a;
      var b_type = typeof b;
      if (a_type === "string") {
        var x = a;
        var y = b;
        if (x < y) {
          return -1;
        } else if (x === y) {
          return 0;
        } else {
          return 1;
        }
      } else {
        var is_a_number = +(a_type === "number");
        var is_b_number = +(b_type === "number");
        if (is_a_number !== 0) {
          if (is_b_number !== 0) {
            return caml_int_compare(a, b);
          } else {
            return -1;
          }
        } else if (is_b_number !== 0) {
          return 1;
        } else if (a_type === "boolean" || a_type === "undefined" || a === null) {
          var x$1 = a;
          var y$1 = b;
          if (x$1 === y$1) {
            return 0;
          } else if (x$1 < y$1) {
            return -1;
          } else {
            return 1;
          }
        } else if (a_type === "function" || b_type === "function") {
          throw [
                Caml_builtin_exceptions.invalid_argument,
                "compare: functional value"
              ];
        } else {
          var tag_a = a.tag | 0;
          var tag_b = b.tag | 0;
          if (tag_a === 250) {
            _a = a[0];
            continue ;
            
          } else if (tag_b === 250) {
            _b = b[0];
            continue ;
            
          } else if (tag_a === 248) {
            return caml_int_compare(a[1], b[1]);
          } else if (tag_a === 251) {
            throw [
                  Caml_builtin_exceptions.invalid_argument,
                  "equal: abstract value"
                ];
          } else if (tag_a !== tag_b) {
            if (tag_a < tag_b) {
              return -1;
            } else {
              return 1;
            }
          } else {
            var len_a = a.length | 0;
            var len_b = b.length | 0;
            if (len_a === len_b) {
              var a$1 = a;
              var b$1 = b;
              var _i = 0;
              var same_length = len_a;
              while(true) {
                var i = _i;
                if (i === same_length) {
                  return 0;
                } else {
                  var res = caml_compare(a$1[i], b$1[i]);
                  if (res !== 0) {
                    return res;
                  } else {
                    _i = i + 1 | 0;
                    continue ;
                    
                  }
                }
              };
            } else if (len_a < len_b) {
              var a$2 = a;
              var b$2 = b;
              var _i$1 = 0;
              var short_length = len_a;
              while(true) {
                var i$1 = _i$1;
                if (i$1 === short_length) {
                  return -1;
                } else {
                  var res$1 = caml_compare(a$2[i$1], b$2[i$1]);
                  if (res$1 !== 0) {
                    return res$1;
                  } else {
                    _i$1 = i$1 + 1 | 0;
                    continue ;
                    
                  }
                }
              };
            } else {
              var a$3 = a;
              var b$3 = b;
              var _i$2 = 0;
              var short_length$1 = len_b;
              while(true) {
                var i$2 = _i$2;
                if (i$2 === short_length$1) {
                  return 1;
                } else {
                  var res$2 = caml_compare(a$3[i$2], b$3[i$2]);
                  if (res$2 !== 0) {
                    return res$2;
                  } else {
                    _i$2 = i$2 + 1 | 0;
                    continue ;
                    
                  }
                }
              };
            }
          }
        }
      }
    }
  };
}

function caml_equal(_a, _b) {
  while(true) {
    var b = _b;
    var a = _a;
    if (a === b) {
      return /* true */1;
    } else {
      var a_type = typeof a;
      if (a_type === "string" || a_type === "number" || a_type === "boolean" || a_type === "undefined" || a === null) {
        return /* false */0;
      } else {
        var b_type = typeof b;
        if (a_type === "function" || b_type === "function") {
          throw [
                Caml_builtin_exceptions.invalid_argument,
                "equal: functional value"
              ];
        } else if (b_type === "number" || b_type === "undefined" || b === null) {
          return /* false */0;
        } else {
          var tag_a = a.tag | 0;
          var tag_b = b.tag | 0;
          if (tag_a === 250) {
            _a = a[0];
            continue ;
            
          } else if (tag_b === 250) {
            _b = b[0];
            continue ;
            
          } else if (tag_a === 248) {
            return +(a[1] === b[1]);
          } else if (tag_a === 251) {
            throw [
                  Caml_builtin_exceptions.invalid_argument,
                  "equal: abstract value"
                ];
          } else if (tag_a !== tag_b) {
            return /* false */0;
          } else {
            var len_a = a.length | 0;
            var len_b = b.length | 0;
            if (len_a === len_b) {
              var a$1 = a;
              var b$1 = b;
              var _i = 0;
              var same_length = len_a;
              while(true) {
                var i = _i;
                if (i === same_length) {
                  return /* true */1;
                } else if (caml_equal(a$1[i], b$1[i])) {
                  _i = i + 1 | 0;
                  continue ;
                  
                } else {
                  return /* false */0;
                }
              };
            } else {
              return /* false */0;
            }
          }
        }
      }
    }
  };
}

function caml_notequal(a, b) {
  return 1 - caml_equal(a, b);
}

function caml_greaterequal(a, b) {
  return +(caml_compare(a, b) >= 0);
}

function caml_greaterthan(a, b) {
  return +(caml_compare(a, b) > 0);
}

function caml_lessequal(a, b) {
  return +(caml_compare(a, b) <= 0);
}

function caml_lessthan(a, b) {
  return +(caml_compare(a, b) < 0);
}

var caml_int32_compare = caml_int_compare;

var caml_nativeint_compare = caml_int_compare;

exports.caml_obj_dup           = caml_obj_dup;
exports.caml_obj_truncate      = caml_obj_truncate;
exports.caml_lazy_make_forward = caml_lazy_make_forward;
exports.caml_update_dummy      = caml_update_dummy;
exports.caml_int_compare       = caml_int_compare;
exports.caml_int32_compare     = caml_int32_compare;
exports.caml_nativeint_compare = caml_nativeint_compare;
exports.caml_compare           = caml_compare;
exports.caml_equal             = caml_equal;
exports.caml_notequal          = caml_notequal;
exports.caml_greaterequal      = caml_greaterequal;
exports.caml_greaterthan       = caml_greaterthan;
exports.caml_lessthan          = caml_lessthan;
exports.caml_lessequal         = caml_lessequal;
/* No side effect */

},{"./block.js":11,"./caml_builtin_exceptions.js":13}],21:[function(require,module,exports){
'use strict';

var Caml_array              = require("./caml_array.js");
var Caml_builtin_exceptions = require("./caml_builtin_exceptions.js");

var caml_methods_cache = Caml_array.caml_make_vect(1000, 0);

function caml_get_public_method(obj, tag, cacheid) {
  var meths = obj[0];
  var offs = caml_methods_cache[cacheid];
  if (meths[offs] === tag) {
    return meths[offs - 1 | 0];
  } else {
    var aux = function (_i) {
      while(true) {
        var i = _i;
        if (i < 3) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "caml_oo.ml",
                  59,
                  20
                ]
              ];
        } else if (meths[i] === tag) {
          caml_methods_cache[cacheid] = i;
          return i;
        } else {
          _i = i - 2 | 0;
          continue ;
          
        }
      };
    };
    return meths[aux((meths[0] << 1) + 1 | 0) - 1 | 0];
  }
}

exports.caml_get_public_method = caml_get_public_method;
/* No side effect */

},{"./caml_array.js":12,"./caml_builtin_exceptions.js":13}],22:[function(require,module,exports){
'use strict';

var Curry   = require("./curry.js");
var Caml_oo = require("./caml_oo.js");

function js(label, cacheid, obj, args) {
  var meth = Caml_oo.caml_get_public_method(obj, label, cacheid);
  return Curry.app(meth, args);
}

function js1(label, cacheid, a0) {
  return Curry._1(Caml_oo.caml_get_public_method(a0, label, cacheid), a0);
}

function js2(label, cacheid, a0, a1) {
  return Curry._2(Caml_oo.caml_get_public_method(a0, label, cacheid), a0, a1);
}

function js3(label, cacheid, a0, a1, a2) {
  return Curry._3(Caml_oo.caml_get_public_method(a0, label, cacheid), a0, a1, a2);
}

function js4(label, cacheid, a0, a1, a2, a3) {
  return Curry._4(Caml_oo.caml_get_public_method(a0, label, cacheid), a0, a1, a2, a3);
}

function js5(label, cacheid, a0, a1, a2, a3, a4) {
  return Curry._5(Caml_oo.caml_get_public_method(a0, label, cacheid), a0, a1, a2, a3, a4);
}

function js6(label, cacheid, a0, a1, a2, a3, a4, a5) {
  return Curry._6(Caml_oo.caml_get_public_method(a0, label, cacheid), a0, a1, a2, a3, a4, a5);
}

function js7(label, cacheid, a0, a1, a2, a3, a4, a5, a6) {
  return Curry._7(Caml_oo.caml_get_public_method(a0, label, cacheid), a0, a1, a2, a3, a4, a5, a6);
}

function js8(label, cacheid, a0, a1, a2, a3, a4, a5, a6, a7) {
  return Curry._8(Caml_oo.caml_get_public_method(a0, label, cacheid), a0, a1, a2, a3, a4, a5, a6, a7);
}

exports.js  = js;
exports.js1 = js1;
exports.js2 = js2;
exports.js3 = js3;
exports.js4 = js4;
exports.js5 = js5;
exports.js6 = js6;
exports.js7 = js7;
exports.js8 = js8;
/* No side effect */

},{"./caml_oo.js":21,"./curry.js":30}],23:[function(require,module,exports){
'use strict';

var Caml_builtin_exceptions = require("./caml_builtin_exceptions.js");

function string_of_char(prim) {
  return String.fromCharCode(prim);
}

function caml_string_get(s, i) {
  if (i >= s.length || i < 0) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "index out of bounds"
        ];
  } else {
    return s.charCodeAt(i);
  }
}

function caml_create_string(len) {
  if (len < 0) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "String.create"
        ];
  } else {
    return new Array(len);
  }
}

function caml_string_compare(s1, s2) {
  if (s1 === s2) {
    return 0;
  } else if (s1 < s2) {
    return -1;
  } else {
    return 1;
  }
}

function caml_fill_string(s, i, l, c) {
  if (l > 0) {
    for(var k = i ,k_finish = (l + i | 0) - 1 | 0; k <= k_finish; ++k){
      s[k] = c;
    }
    return /* () */0;
  } else {
    return 0;
  }
}

function caml_blit_string(s1, i1, s2, i2, len) {
  if (len > 0) {
    var off1 = s1.length - i1 | 0;
    if (len <= off1) {
      for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
        s2[i2 + i | 0] = s1.charCodeAt(i1 + i | 0);
      }
      return /* () */0;
    } else {
      for(var i$1 = 0 ,i_finish$1 = off1 - 1 | 0; i$1 <= i_finish$1; ++i$1){
        s2[i2 + i$1 | 0] = s1.charCodeAt(i1 + i$1 | 0);
      }
      for(var i$2 = off1 ,i_finish$2 = len - 1 | 0; i$2 <= i_finish$2; ++i$2){
        s2[i2 + i$2 | 0] = /* "\000" */0;
      }
      return /* () */0;
    }
  } else {
    return 0;
  }
}

function caml_blit_bytes(s1, i1, s2, i2, len) {
  if (len > 0) {
    if (s1 === s2) {
      var s1$1 = s1;
      var i1$1 = i1;
      var i2$1 = i2;
      var len$1 = len;
      if (i1$1 < i2$1) {
        var range_a = (s1$1.length - i2$1 | 0) - 1 | 0;
        var range_b = len$1 - 1 | 0;
        var range = range_a > range_b ? range_b : range_a;
        for(var j = range; j >= 0; --j){
          s1$1[i2$1 + j | 0] = s1$1[i1$1 + j | 0];
        }
        return /* () */0;
      } else if (i1$1 > i2$1) {
        var range_a$1 = (s1$1.length - i1$1 | 0) - 1 | 0;
        var range_b$1 = len$1 - 1 | 0;
        var range$1 = range_a$1 > range_b$1 ? range_b$1 : range_a$1;
        for(var k = 0; k <= range$1; ++k){
          s1$1[i2$1 + k | 0] = s1$1[i1$1 + k | 0];
        }
        return /* () */0;
      } else {
        return 0;
      }
    } else {
      var off1 = s1.length - i1 | 0;
      if (len <= off1) {
        for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
          s2[i2 + i | 0] = s1[i1 + i | 0];
        }
        return /* () */0;
      } else {
        for(var i$1 = 0 ,i_finish$1 = off1 - 1 | 0; i$1 <= i_finish$1; ++i$1){
          s2[i2 + i$1 | 0] = s1[i1 + i$1 | 0];
        }
        for(var i$2 = off1 ,i_finish$2 = len - 1 | 0; i$2 <= i_finish$2; ++i$2){
          s2[i2 + i$2 | 0] = /* "\000" */0;
        }
        return /* () */0;
      }
    }
  } else {
    return 0;
  }
}

function bytes_of_string(s) {
  var len = s.length;
  var res = new Array(len);
  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
    res[i] = s.charCodeAt(i);
  }
  return res;
}

function bytes_to_string(a) {
  var bytes = a;
  var i = 0;
  var len = a.length;
  var s = "";
  var s_len = len;
  if (i === 0 && len <= 4096 && len === bytes.length) {
    return String.fromCharCode.apply(null,bytes);
  } else {
    var offset = 0;
    while(s_len > 0) {
      var next = s_len < 1024 ? s_len : 1024;
      var tmp_bytes = new Array(next);
      caml_blit_bytes(bytes, offset, tmp_bytes, 0, next);
      s = s + String.fromCharCode.apply(null,tmp_bytes);
      s_len = s_len - next | 0;
      offset = offset + next | 0;
    };
    return s;
  }
}

function caml_string_of_char_array(chars) {
  var len = chars.length;
  var bytes = new Array(len);
  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
    bytes[i] = chars[i];
  }
  return bytes_to_string(bytes);
}

function caml_is_printable(c) {
  if (c > 31) {
    return +(c < 127);
  } else {
    return /* false */0;
  }
}

function caml_string_get16(s, i) {
  return s.charCodeAt(i) + (s.charCodeAt(i + 1 | 0) << 8) | 0;
}

function caml_string_get32(s, i) {
  return ((s.charCodeAt(i) + (s.charCodeAt(i + 1 | 0) << 8) | 0) + (s.charCodeAt(i + 2 | 0) << 16) | 0) + (s.charCodeAt(i + 3 | 0) << 24) | 0;
}

function get(s, i) {
  if (i < 0 || i >= s.length) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "index out of bounds"
        ];
  } else {
    return s.charCodeAt(i);
  }
}

exports.bytes_of_string           = bytes_of_string;
exports.bytes_to_string           = bytes_to_string;
exports.caml_is_printable         = caml_is_printable;
exports.caml_string_of_char_array = caml_string_of_char_array;
exports.caml_string_get           = caml_string_get;
exports.caml_string_compare       = caml_string_compare;
exports.caml_create_string        = caml_create_string;
exports.caml_fill_string          = caml_fill_string;
exports.caml_blit_string          = caml_blit_string;
exports.caml_blit_bytes           = caml_blit_bytes;
exports.caml_string_get16         = caml_string_get16;
exports.caml_string_get32         = caml_string_get32;
exports.string_of_char            = string_of_char;
exports.get                       = get;
/* No side effect */

},{"./caml_builtin_exceptions.js":13}],24:[function(require,module,exports){
(function (process){
'use strict';

var Caml_builtin_exceptions = require("./caml_builtin_exceptions.js");

function caml_sys_getenv(s) {
  var match = typeof (process) === "undefined" ? undefined : (process);
  if (match !== undefined) {
    var match$1 = match.env[s];
    if (match$1 !== undefined) {
      return match$1;
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function caml_sys_time() {
  var match = typeof (process) === "undefined" ? undefined : (process);
  if (match !== undefined) {
    return match.uptime();
  } else {
    return -1;
  }
}

function caml_sys_random_seed() {
  return /* array */[((Date.now() | 0) ^ 4294967295) * Math.random() | 0];
}

function caml_sys_system_command() {
  return 127;
}

function caml_sys_getcwd() {
  var match = typeof (process) === "undefined" ? undefined : (process);
  if (match !== undefined) {
    return match.cwd();
  } else {
    return "/";
  }
}

function caml_sys_get_argv() {
  var match = typeof (process) === "undefined" ? undefined : (process);
  if (match !== undefined) {
    if (match.argv == null) {
      return /* tuple */[
              "",
              /* array */[""]
            ];
    } else {
      return /* tuple */[
              match.argv[0],
              match.argv
            ];
    }
  } else {
    return /* tuple */[
            "",
            /* array */[""]
          ];
  }
}

function caml_sys_exit(exit_code) {
  var match = typeof (process) === "undefined" ? undefined : (process);
  if (match !== undefined) {
    return match.exit(exit_code);
  } else {
    return /* () */0;
  }
}

function caml_sys_is_directory() {
  throw [
        Caml_builtin_exceptions.failure,
        "caml_sys_is_directory not implemented"
      ];
}

function caml_sys_file_exists() {
  throw [
        Caml_builtin_exceptions.failure,
        "caml_sys_file_exists not implemented"
      ];
}

exports.caml_sys_getenv         = caml_sys_getenv;
exports.caml_sys_time           = caml_sys_time;
exports.caml_sys_random_seed    = caml_sys_random_seed;
exports.caml_sys_system_command = caml_sys_system_command;
exports.caml_sys_getcwd         = caml_sys_getcwd;
exports.caml_sys_get_argv       = caml_sys_get_argv;
exports.caml_sys_exit           = caml_sys_exit;
exports.caml_sys_is_directory   = caml_sys_is_directory;
exports.caml_sys_file_exists    = caml_sys_file_exists;
/* No side effect */

}).call(this,require('_process'))
},{"./caml_builtin_exceptions.js":13,"_process":46}],25:[function(require,module,exports){
'use strict';


var repeat = ( (String.prototype.repeat && function (count,self){return self.repeat(count)}) ||
                                                  function(count , self) {
        if (self.length == 0 || count == 0) {
            return '';
        }
        // Ensuring count is a 31-bit integer allows us to heavily optimize the
        // main part. But anyway, most current (August 2014) browsers can't handle
        // strings 1 << 28 chars or longer, so:
        if (self.length * count >= 1 << 28) {
            throw new RangeError('repeat count must not overflow maximum string size');
        }
        var rpt = '';
        for (;;) {
            if ((count & 1) == 1) {
                rpt += self;
            }
            count >>>= 1;
            if (count == 0) {
                break;
            }
            self += self;
        }
        return rpt;
    }
);

exports.repeat = repeat;
/* repeat Not a pure module */

},{}],26:[function(require,module,exports){
'use strict';

var Block = require("./block.js");

function erase_rel(param) {
  if (typeof param === "number") {
    return /* End_of_fmtty */0;
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return /* Char_ty */Block.__(0, [erase_rel(param[0])]);
      case 1 : 
          return /* String_ty */Block.__(1, [erase_rel(param[0])]);
      case 2 : 
          return /* Int_ty */Block.__(2, [erase_rel(param[0])]);
      case 3 : 
          return /* Int32_ty */Block.__(3, [erase_rel(param[0])]);
      case 4 : 
          return /* Nativeint_ty */Block.__(4, [erase_rel(param[0])]);
      case 5 : 
          return /* Int64_ty */Block.__(5, [erase_rel(param[0])]);
      case 6 : 
          return /* Float_ty */Block.__(6, [erase_rel(param[0])]);
      case 7 : 
          return /* Bool_ty */Block.__(7, [erase_rel(param[0])]);
      case 8 : 
          return /* Format_arg_ty */Block.__(8, [
                    param[0],
                    erase_rel(param[1])
                  ]);
      case 9 : 
          var ty1 = param[0];
          return /* Format_subst_ty */Block.__(9, [
                    ty1,
                    ty1,
                    erase_rel(param[2])
                  ]);
      case 10 : 
          return /* Alpha_ty */Block.__(10, [erase_rel(param[0])]);
      case 11 : 
          return /* Theta_ty */Block.__(11, [erase_rel(param[0])]);
      case 12 : 
          return /* Any_ty */Block.__(12, [erase_rel(param[0])]);
      case 13 : 
          return /* Reader_ty */Block.__(13, [erase_rel(param[0])]);
      case 14 : 
          return /* Ignored_reader_ty */Block.__(14, [erase_rel(param[0])]);
      
    }
  }
}

function concat_fmtty(fmtty1, fmtty2) {
  if (typeof fmtty1 === "number") {
    return fmtty2;
  } else {
    switch (fmtty1.tag | 0) {
      case 0 : 
          return /* Char_ty */Block.__(0, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 1 : 
          return /* String_ty */Block.__(1, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 2 : 
          return /* Int_ty */Block.__(2, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 3 : 
          return /* Int32_ty */Block.__(3, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 4 : 
          return /* Nativeint_ty */Block.__(4, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 5 : 
          return /* Int64_ty */Block.__(5, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 6 : 
          return /* Float_ty */Block.__(6, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 7 : 
          return /* Bool_ty */Block.__(7, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 8 : 
          return /* Format_arg_ty */Block.__(8, [
                    fmtty1[0],
                    concat_fmtty(fmtty1[1], fmtty2)
                  ]);
      case 9 : 
          return /* Format_subst_ty */Block.__(9, [
                    fmtty1[0],
                    fmtty1[1],
                    concat_fmtty(fmtty1[2], fmtty2)
                  ]);
      case 10 : 
          return /* Alpha_ty */Block.__(10, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 11 : 
          return /* Theta_ty */Block.__(11, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 12 : 
          return /* Any_ty */Block.__(12, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 13 : 
          return /* Reader_ty */Block.__(13, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 14 : 
          return /* Ignored_reader_ty */Block.__(14, [concat_fmtty(fmtty1[0], fmtty2)]);
      
    }
  }
}

function concat_fmt(fmt1, fmt2) {
  if (typeof fmt1 === "number") {
    return fmt2;
  } else {
    switch (fmt1.tag | 0) {
      case 0 : 
          return /* Char */Block.__(0, [concat_fmt(fmt1[0], fmt2)]);
      case 1 : 
          return /* Caml_char */Block.__(1, [concat_fmt(fmt1[0], fmt2)]);
      case 2 : 
          return /* String */Block.__(2, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case 3 : 
          return /* Caml_string */Block.__(3, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case 4 : 
          return /* Int */Block.__(4, [
                    fmt1[0],
                    fmt1[1],
                    fmt1[2],
                    concat_fmt(fmt1[3], fmt2)
                  ]);
      case 5 : 
          return /* Int32 */Block.__(5, [
                    fmt1[0],
                    fmt1[1],
                    fmt1[2],
                    concat_fmt(fmt1[3], fmt2)
                  ]);
      case 6 : 
          return /* Nativeint */Block.__(6, [
                    fmt1[0],
                    fmt1[1],
                    fmt1[2],
                    concat_fmt(fmt1[3], fmt2)
                  ]);
      case 7 : 
          return /* Int64 */Block.__(7, [
                    fmt1[0],
                    fmt1[1],
                    fmt1[2],
                    concat_fmt(fmt1[3], fmt2)
                  ]);
      case 8 : 
          return /* Float */Block.__(8, [
                    fmt1[0],
                    fmt1[1],
                    fmt1[2],
                    concat_fmt(fmt1[3], fmt2)
                  ]);
      case 9 : 
          return /* Bool */Block.__(9, [concat_fmt(fmt1[0], fmt2)]);
      case 10 : 
          return /* Flush */Block.__(10, [concat_fmt(fmt1[0], fmt2)]);
      case 11 : 
          return /* String_literal */Block.__(11, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case 12 : 
          return /* Char_literal */Block.__(12, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case 13 : 
          return /* Format_arg */Block.__(13, [
                    fmt1[0],
                    fmt1[1],
                    concat_fmt(fmt1[2], fmt2)
                  ]);
      case 14 : 
          return /* Format_subst */Block.__(14, [
                    fmt1[0],
                    fmt1[1],
                    concat_fmt(fmt1[2], fmt2)
                  ]);
      case 15 : 
          return /* Alpha */Block.__(15, [concat_fmt(fmt1[0], fmt2)]);
      case 16 : 
          return /* Theta */Block.__(16, [concat_fmt(fmt1[0], fmt2)]);
      case 17 : 
          return /* Formatting_lit */Block.__(17, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case 18 : 
          return /* Formatting_gen */Block.__(18, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case 19 : 
          return /* Reader */Block.__(19, [concat_fmt(fmt1[0], fmt2)]);
      case 20 : 
          return /* Scan_char_set */Block.__(20, [
                    fmt1[0],
                    fmt1[1],
                    concat_fmt(fmt1[2], fmt2)
                  ]);
      case 21 : 
          return /* Scan_get_counter */Block.__(21, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case 22 : 
          return /* Scan_next_char */Block.__(22, [concat_fmt(fmt1[0], fmt2)]);
      case 23 : 
          return /* Ignored_param */Block.__(23, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case 24 : 
          return /* Custom */Block.__(24, [
                    fmt1[0],
                    fmt1[1],
                    concat_fmt(fmt1[2], fmt2)
                  ]);
      
    }
  }
}

exports.concat_fmtty = concat_fmtty;
exports.erase_rel    = erase_rel;
exports.concat_fmt   = concat_fmt;
/* No side effect */

},{"./block.js":11}],27:[function(require,module,exports){
'use strict';

var Obj             = require("./obj.js");
var Curry           = require("./curry.js");
var Caml_exceptions = require("./caml_exceptions.js");

var Undefined = Caml_exceptions.create("CamlinternalLazy.Undefined");

function raise_undefined() {
  throw Undefined;
}

function force_lazy_block(blk) {
  var closure = blk[0];
  blk[0] = raise_undefined;
  try {
    var result = Curry._1(closure, /* () */0);
    blk[0] = result;
    blk.tag = Obj.forward_tag;
    return result;
  }
  catch (e){
    blk[0] = (function () {
        throw e;
      });
    throw e;
  }
}

function force_val_lazy_block(blk) {
  var closure = blk[0];
  blk[0] = raise_undefined;
  var result = Curry._1(closure, /* () */0);
  blk[0] = result;
  blk.tag = Obj.forward_tag;
  return result;
}

function force(lzv) {
  var t = lzv.tag | 0;
  if (t === Obj.forward_tag) {
    return lzv[0];
  } else if (t !== Obj.lazy_tag) {
    return lzv;
  } else {
    return force_lazy_block(lzv);
  }
}

function force_val(lzv) {
  var t = lzv.tag | 0;
  if (t === Obj.forward_tag) {
    return lzv[0];
  } else if (t !== Obj.lazy_tag) {
    return lzv;
  } else {
    return force_val_lazy_block(lzv);
  }
}

exports.Undefined            = Undefined;
exports.force_lazy_block     = force_lazy_block;
exports.force_val_lazy_block = force_val_lazy_block;
exports.force                = force;
exports.force_val            = force_val;
/* No side effect */

},{"./caml_exceptions.js":14,"./curry.js":30,"./obj.js":35}],28:[function(require,module,exports){
'use strict';

var Obj                     = require("./obj.js");
var List                    = require("./list.js");
var $$Array                 = require("./array.js");
var Curry                   = require("./curry.js");
var Caml_oo                 = require("./caml_oo.js");
var Caml_obj                = require("./caml_obj.js");
var Caml_array              = require("./caml_array.js");
var Caml_int32              = require("./caml_int32.js");
var Caml_string             = require("./caml_string.js");
var Caml_exceptions         = require("./caml_exceptions.js");
var Caml_builtin_exceptions = require("./caml_builtin_exceptions.js");

function copy(o) {
  return Caml_exceptions.caml_set_oo_id(Caml_obj.caml_obj_dup(o));
}

var params = /* record */[
  /* compact_table : true */1,
  /* copy_parent : true */1,
  /* clean_when_copying : true */1,
  /* retry_count */3,
  /* bucket_small_size */16
];

function public_method_label(s) {
  var accu = 0;
  for(var i = 0 ,i_finish = s.length - 1 | 0; i <= i_finish; ++i){
    accu = Caml_int32.imul(223, accu) + Caml_string.get(s, i) | 0;
  }
  accu = accu & 2147483647;
  if (accu > 1073741823) {
    return accu - -2147483648 | 0;
  } else {
    return accu;
  }
}

function height(param) {
  if (param) {
    return param[4];
  } else {
    return 0;
  }
}

function create(l, x, d, r) {
  var hl = height(l);
  var hr = height(r);
  return /* Node */[
          l,
          x,
          d,
          r,
          hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal(l, x, d, r) {
  var hl = l ? l[4] : 0;
  var hr = r ? r[4] : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      var lr = l[3];
      var ld = l[2];
      var lv = l[1];
      var ll = l[0];
      if (height(ll) >= height(lr)) {
        return create(ll, lv, ld, create(lr, x, d, r));
      } else if (lr) {
        return create(create(ll, lv, ld, lr[0]), lr[1], lr[2], create(lr[3], x, d, r));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
  } else if (hr > (hl + 2 | 0)) {
    if (r) {
      var rr = r[3];
      var rd = r[2];
      var rv = r[1];
      var rl = r[0];
      if (height(rr) >= height(rl)) {
        return create(create(l, x, d, rl), rv, rd, rr);
      } else if (rl) {
        return create(create(l, x, d, rl[0]), rl[1], rl[2], create(rl[3], rv, rd, rr));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
  } else {
    return /* Node */[
            l,
            x,
            d,
            r,
            hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          ];
  }
}

function add(x, data, param) {
  if (param) {
    var r = param[3];
    var d = param[2];
    var v = param[1];
    var l = param[0];
    var c = Caml_string.caml_string_compare(x, v);
    if (c) {
      if (c < 0) {
        return bal(add(x, data, l), v, d, r);
      } else {
        return bal(l, v, d, add(x, data, r));
      }
    } else {
      return /* Node */[
              l,
              x,
              data,
              r,
              param[4]
            ];
    }
  } else {
    return /* Node */[
            /* Empty */0,
            x,
            data,
            /* Empty */0,
            1
          ];
  }
}

function find(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var c = Caml_string.caml_string_compare(x, param[1]);
      if (c) {
        _param = c < 0 ? param[0] : param[3];
        continue ;
        
      } else {
        return param[2];
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function fold(f, _m, _accu) {
  while(true) {
    var accu = _accu;
    var m = _m;
    if (m) {
      _accu = Curry._3(f, m[1], m[2], fold(f, m[0], accu));
      _m = m[3];
      continue ;
      
    } else {
      return accu;
    }
  };
}

function height$1(param) {
  if (param) {
    return param[4];
  } else {
    return 0;
  }
}

function create$1(l, x, d, r) {
  var hl = height$1(l);
  var hr = height$1(r);
  return /* Node */[
          l,
          x,
          d,
          r,
          hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$1(l, x, d, r) {
  var hl = l ? l[4] : 0;
  var hr = r ? r[4] : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      var lr = l[3];
      var ld = l[2];
      var lv = l[1];
      var ll = l[0];
      if (height$1(ll) >= height$1(lr)) {
        return create$1(ll, lv, ld, create$1(lr, x, d, r));
      } else if (lr) {
        return create$1(create$1(ll, lv, ld, lr[0]), lr[1], lr[2], create$1(lr[3], x, d, r));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
  } else if (hr > (hl + 2 | 0)) {
    if (r) {
      var rr = r[3];
      var rd = r[2];
      var rv = r[1];
      var rl = r[0];
      if (height$1(rr) >= height$1(rl)) {
        return create$1(create$1(l, x, d, rl), rv, rd, rr);
      } else if (rl) {
        return create$1(create$1(l, x, d, rl[0]), rl[1], rl[2], create$1(rl[3], rv, rd, rr));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
  } else {
    return /* Node */[
            l,
            x,
            d,
            r,
            hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          ];
  }
}

function add$1(x, data, param) {
  if (param) {
    var r = param[3];
    var d = param[2];
    var v = param[1];
    var l = param[0];
    var c = Caml_string.caml_string_compare(x, v);
    if (c) {
      if (c < 0) {
        return bal$1(add$1(x, data, l), v, d, r);
      } else {
        return bal$1(l, v, d, add$1(x, data, r));
      }
    } else {
      return /* Node */[
              l,
              x,
              data,
              r,
              param[4]
            ];
    }
  } else {
    return /* Node */[
            /* Empty */0,
            x,
            data,
            /* Empty */0,
            1
          ];
  }
}

function height$2(param) {
  if (param) {
    return param[4];
  } else {
    return 0;
  }
}

function create$2(l, x, d, r) {
  var hl = height$2(l);
  var hr = height$2(r);
  return /* Node */[
          l,
          x,
          d,
          r,
          hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$2(l, x, d, r) {
  var hl = l ? l[4] : 0;
  var hr = r ? r[4] : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      var lr = l[3];
      var ld = l[2];
      var lv = l[1];
      var ll = l[0];
      if (height$2(ll) >= height$2(lr)) {
        return create$2(ll, lv, ld, create$2(lr, x, d, r));
      } else if (lr) {
        return create$2(create$2(ll, lv, ld, lr[0]), lr[1], lr[2], create$2(lr[3], x, d, r));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
  } else if (hr > (hl + 2 | 0)) {
    if (r) {
      var rr = r[3];
      var rd = r[2];
      var rv = r[1];
      var rl = r[0];
      if (height$2(rr) >= height$2(rl)) {
        return create$2(create$2(l, x, d, rl), rv, rd, rr);
      } else if (rl) {
        return create$2(create$2(l, x, d, rl[0]), rl[1], rl[2], create$2(rl[3], rv, rd, rr));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
  } else {
    return /* Node */[
            l,
            x,
            d,
            r,
            hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          ];
  }
}

function add$2(x, data, param) {
  if (param) {
    var r = param[3];
    var d = param[2];
    var v = param[1];
    var l = param[0];
    var c = Caml_obj.caml_int_compare(x, v);
    if (c) {
      if (c < 0) {
        return bal$2(add$2(x, data, l), v, d, r);
      } else {
        return bal$2(l, v, d, add$2(x, data, r));
      }
    } else {
      return /* Node */[
              l,
              x,
              data,
              r,
              param[4]
            ];
    }
  } else {
    return /* Node */[
            /* Empty */0,
            x,
            data,
            /* Empty */0,
            1
          ];
  }
}

function find$1(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var c = Caml_obj.caml_int_compare(x, param[1]);
      if (c) {
        _param = c < 0 ? param[0] : param[3];
        continue ;
        
      } else {
        return param[2];
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

var dummy_table = /* record */[
  /* size */0,
  /* methods : array */[/* () */0],
  /* methods_by_name : Empty */0,
  /* methods_by_label : Empty */0,
  /* previous_states : [] */0,
  /* hidden_meths : [] */0,
  /* vars : Empty */0,
  /* initializers : [] */0
];

var table_count = [0];

var dummy_met = [];

function fit_size(n) {
  if (n <= 2) {
    return n;
  } else {
    return (fit_size((n + 1 | 0) / 2 | 0) << 1);
  }
}

function new_table(pub_labels) {
  table_count[0] = table_count[0] + 1 | 0;
  var len = pub_labels.length;
  var methods = Caml_array.caml_make_vect((len << 1) + 2 | 0, dummy_met);
  Caml_array.caml_array_set(methods, 0, len);
  Caml_array.caml_array_set(methods, 1, ((fit_size(len) << 5) / 8 | 0) - 1 | 0);
  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
    Caml_array.caml_array_set(methods, (i << 1) + 3 | 0, Caml_array.caml_array_get(pub_labels, i));
  }
  return /* record */[
          /* size */2,
          /* methods */methods,
          /* methods_by_name : Empty */0,
          /* methods_by_label : Empty */0,
          /* previous_states : [] */0,
          /* hidden_meths : [] */0,
          /* vars : Empty */0,
          /* initializers : [] */0
        ];
}

function resize(array, new_size) {
  var old_size = array[/* methods */1].length;
  if (new_size > old_size) {
    var new_buck = Caml_array.caml_make_vect(new_size, dummy_met);
    $$Array.blit(array[/* methods */1], 0, new_buck, 0, old_size);
    array[/* methods */1] = new_buck;
    return /* () */0;
  } else {
    return 0;
  }
}

var method_count = [0];

var inst_var_count = [0];

function new_method(table) {
  var index = table[/* methods */1].length;
  resize(table, index + 1 | 0);
  return index;
}

function get_method_label(table, name) {
  try {
    var x = name;
    var _param = table[/* methods_by_name */2];
    while(true) {
      var param = _param;
      if (param) {
        var c = Caml_string.caml_string_compare(x, param[1]);
        if (c) {
          _param = c < 0 ? param[0] : param[3];
          continue ;
          
        } else {
          return param[2];
        }
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    };
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var label = new_method(table);
      table[/* methods_by_name */2] = add$1(name, label, table[/* methods_by_name */2]);
      table[/* methods_by_label */3] = add$2(label, /* true */1, table[/* methods_by_label */3]);
      return label;
    } else {
      throw exn;
    }
  }
}

function get_method_labels(table, names) {
  return $$Array.map((function (param) {
                return get_method_label(table, param);
              }), names);
}

function set_method(table, label, element) {
  method_count[0] = method_count[0] + 1 | 0;
  if (find$1(label, table[/* methods_by_label */3])) {
    var array = table;
    var label$1 = label;
    var element$1 = element;
    resize(array, label$1 + 1 | 0);
    return Caml_array.caml_array_set(array[/* methods */1], label$1, element$1);
  } else {
    table[/* hidden_meths */5] = /* :: */[
      /* tuple */[
        label,
        element
      ],
      table[/* hidden_meths */5]
    ];
    return /* () */0;
  }
}

function get_method(table, label) {
  try {
    return List.assoc(label, table[/* hidden_meths */5]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Caml_array.caml_array_get(table[/* methods */1], label);
    } else {
      throw exn;
    }
  }
}

function to_list(arr) {
  if (arr) {
    return $$Array.to_list(arr);
  } else {
    return /* [] */0;
  }
}

function narrow(table, vars, virt_meths, concr_meths) {
  var vars$1 = to_list(vars);
  var virt_meths$1 = to_list(virt_meths);
  var concr_meths$1 = to_list(concr_meths);
  var virt_meth_labs = List.map((function (param) {
          return get_method_label(table, param);
        }), virt_meths$1);
  var concr_meth_labs = List.map((function (param) {
          return get_method_label(table, param);
        }), concr_meths$1);
  table[/* previous_states */4] = /* :: */[
    /* tuple */[
      table[/* methods_by_name */2],
      table[/* methods_by_label */3],
      table[/* hidden_meths */5],
      table[/* vars */6],
      virt_meth_labs,
      vars$1
    ],
    table[/* previous_states */4]
  ];
  table[/* vars */6] = fold((function (lab, info, tvars) {
          if (List.mem(lab, vars$1)) {
            return add(lab, info, tvars);
          } else {
            return tvars;
          }
        }), table[/* vars */6], /* Empty */0);
  var by_name = [/* Empty */0];
  var by_label = [/* Empty */0];
  List.iter2((function (met, label) {
          by_name[0] = add$1(met, label, by_name[0]);
          var tmp;
          try {
            tmp = find$1(label, table[/* methods_by_label */3]);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              tmp = /* true */1;
            } else {
              throw exn;
            }
          }
          by_label[0] = add$2(label, tmp, by_label[0]);
          return /* () */0;
        }), concr_meths$1, concr_meth_labs);
  List.iter2((function (met, label) {
          by_name[0] = add$1(met, label, by_name[0]);
          by_label[0] = add$2(label, /* false */0, by_label[0]);
          return /* () */0;
        }), virt_meths$1, virt_meth_labs);
  table[/* methods_by_name */2] = by_name[0];
  table[/* methods_by_label */3] = by_label[0];
  table[/* hidden_meths */5] = List.fold_right((function (met, hm) {
          if (List.mem(met[0], virt_meth_labs)) {
            return hm;
          } else {
            return /* :: */[
                    met,
                    hm
                  ];
          }
        }), table[/* hidden_meths */5], /* [] */0);
  return /* () */0;
}

function widen(table) {
  var match = List.hd(table[/* previous_states */4]);
  var virt_meths = match[4];
  table[/* previous_states */4] = List.tl(table[/* previous_states */4]);
  table[/* vars */6] = List.fold_left((function (s, v) {
          return add(v, find(v, table[/* vars */6]), s);
        }), match[3], match[5]);
  table[/* methods_by_name */2] = match[0];
  table[/* methods_by_label */3] = match[1];
  table[/* hidden_meths */5] = List.fold_right((function (met, hm) {
          if (List.mem(met[0], virt_meths)) {
            return hm;
          } else {
            return /* :: */[
                    met,
                    hm
                  ];
          }
        }), table[/* hidden_meths */5], match[2]);
  return /* () */0;
}

function new_slot(table) {
  var index = table[/* size */0];
  table[/* size */0] = index + 1 | 0;
  return index;
}

function new_variable(table, name) {
  try {
    return find(name, table[/* vars */6]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var index = new_slot(table);
      if (name !== "") {
        table[/* vars */6] = add(name, index, table[/* vars */6]);
      }
      return index;
    } else {
      throw exn;
    }
  }
}

function to_array(arr) {
  if (Caml_obj.caml_equal(arr, 0)) {
    return /* array */[];
  } else {
    return arr;
  }
}

function new_methods_variables(table, meths, vals) {
  var meths$1 = to_array(meths);
  var nmeths = meths$1.length;
  var nvals = vals.length;
  var res = Caml_array.caml_make_vect(nmeths + nvals | 0, 0);
  for(var i = 0 ,i_finish = nmeths - 1 | 0; i <= i_finish; ++i){
    Caml_array.caml_array_set(res, i, get_method_label(table, Caml_array.caml_array_get(meths$1, i)));
  }
  for(var i$1 = 0 ,i_finish$1 = nvals - 1 | 0; i$1 <= i_finish$1; ++i$1){
    Caml_array.caml_array_set(res, i$1 + nmeths | 0, new_variable(table, Caml_array.caml_array_get(vals, i$1)));
  }
  return res;
}

function get_variable(table, name) {
  try {
    return find(name, table[/* vars */6]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "camlinternalOO.ml",
              285,
              50
            ]
          ];
    } else {
      throw exn;
    }
  }
}

function get_variables(table, names) {
  return $$Array.map((function (param) {
                return get_variable(table, param);
              }), names);
}

function add_initializer(table, f) {
  table[/* initializers */7] = /* :: */[
    f,
    table[/* initializers */7]
  ];
  return /* () */0;
}

function create_table(public_methods) {
  if (public_methods) {
    var tags = $$Array.map(public_method_label, public_methods);
    var table = new_table(tags);
    $$Array.iteri((function (i, met) {
            var lab = (i << 1) + 2 | 0;
            table[/* methods_by_name */2] = add$1(met, lab, table[/* methods_by_name */2]);
            table[/* methods_by_label */3] = add$2(lab, /* true */1, table[/* methods_by_label */3]);
            return /* () */0;
          }), public_methods);
    return table;
  } else {
    return new_table(/* array */[]);
  }
}

function init_class(table) {
  inst_var_count[0] = (inst_var_count[0] + table[/* size */0] | 0) - 1 | 0;
  table[/* initializers */7] = List.rev(table[/* initializers */7]);
  return resize(table, 3 + ((Caml_array.caml_array_get(table[/* methods */1], 1) << 4) / 32 | 0) | 0);
}

function inherits(cla, vals, virt_meths, concr_meths, param, top) {
  var $$super = param[1];
  narrow(cla, vals, virt_meths, concr_meths);
  var init = top ? Curry._2($$super, cla, param[3]) : Curry._1($$super, cla);
  widen(cla);
  return Caml_array.caml_array_concat(/* :: */[
              /* array */[init],
              /* :: */[
                $$Array.map((function (param) {
                        return get_variable(cla, param);
                      }), to_array(vals)),
                /* :: */[
                  $$Array.map((function (nm) {
                          return get_method(cla, get_method_label(cla, nm));
                        }), to_array(concr_meths)),
                  /* [] */0
                ]
              ]
            ]);
}

function make_class(pub_meths, class_init) {
  var table = create_table(pub_meths);
  var env_init = Curry._1(class_init, table);
  init_class(table);
  return /* tuple */[
          Curry._1(env_init, 0),
          class_init,
          env_init,
          0
        ];
}

function make_class_store(pub_meths, class_init, init_table) {
  var table = create_table(pub_meths);
  var env_init = Curry._1(class_init, table);
  init_class(table);
  init_table[/* class_init */1] = class_init;
  init_table[/* env_init */0] = env_init;
  return /* () */0;
}

function dummy_class(loc) {
  var undef = function () {
    throw [
          Caml_builtin_exceptions.undefined_recursive_module,
          loc
        ];
  };
  return /* tuple */[
          undef,
          undef,
          undef,
          0
        ];
}

function create_object(table) {
  var obj = {
    length: table[/* size */0],
    tag: Obj.object_tag
  };
  obj[0] = table[/* methods */1];
  return Caml_exceptions.caml_set_oo_id(obj);
}

function create_object_opt(obj_0, table) {
  if (obj_0) {
    return obj_0;
  } else {
    var obj = {
      length: table[/* size */0],
      tag: Obj.object_tag
    };
    obj[0] = table[/* methods */1];
    return Caml_exceptions.caml_set_oo_id(obj);
  }
}

function iter_f(obj, _param) {
  while(true) {
    var param = _param;
    if (param) {
      Curry._1(param[0], obj);
      _param = param[1];
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function run_initializers(obj, table) {
  var inits = table[/* initializers */7];
  if (inits !== /* [] */0) {
    return iter_f(obj, inits);
  } else {
    return 0;
  }
}

function run_initializers_opt(obj_0, obj, table) {
  if (obj_0) {
    return obj;
  } else {
    var inits = table[/* initializers */7];
    if (inits !== /* [] */0) {
      iter_f(obj, inits);
    }
    return obj;
  }
}

function create_object_and_run_initializers(obj_0, table) {
  if (obj_0) {
    return obj_0;
  } else {
    var obj = create_object(table);
    run_initializers(obj, table);
    return obj;
  }
}

function build_path(n, keys, tables) {
  var res = /* record */[
    /* key */0,
    /* data : Empty */0,
    /* next : Empty */0
  ];
  var r = res;
  for(var i = 0; i <= n; ++i){
    r = /* Cons */[
      Caml_array.caml_array_get(keys, i),
      r,
      /* Empty */0
    ];
  }
  tables[/* data */1] = r;
  return res;
}

function lookup_keys(i, keys, tables) {
  if (i < 0) {
    return tables;
  } else {
    var key = Caml_array.caml_array_get(keys, i);
    var _tables = tables;
    while(true) {
      var tables$1 = _tables;
      if (tables$1[/* key */0] === key) {
        return lookup_keys(i - 1 | 0, keys, tables$1[/* data */1]);
      } else if (tables$1[/* next */2] !== /* Empty */0) {
        _tables = tables$1[/* next */2];
        continue ;
        
      } else {
        var next = /* Cons */[
          key,
          /* Empty */0,
          /* Empty */0
        ];
        tables$1[/* next */2] = next;
        return build_path(i - 1 | 0, keys, next);
      }
    };
  }
}

function lookup_tables(root, keys) {
  if (root[/* data */1] !== /* Empty */0) {
    return lookup_keys(keys.length - 1 | 0, keys, root[/* data */1]);
  } else {
    return build_path(keys.length - 1 | 0, keys, root);
  }
}

function new_cache(table) {
  var n = new_method(table);
  var n$1 = n % 2 === 0 || n > (2 + ((Caml_array.caml_array_get(table[/* methods */1], 1) << 4) / 32 | 0) | 0) ? n : new_method(table);
  Caml_array.caml_array_set(table[/* methods */1], n$1, 0);
  return n$1;
}

function method_impl(table, i, arr) {
  var next = function () {
    i[0] = i[0] + 1 | 0;
    return Caml_array.caml_array_get(arr, i[0]);
  };
  var clo = next(/* () */0);
  if (typeof clo === "number") {
    switch (clo) {
      case 0 : 
          var x = next(/* () */0);
          return (function () {
              return x;
            });
      case 1 : 
          var n = next(/* () */0);
          return (function (obj) {
              return obj[n];
            });
      case 2 : 
          var e = next(/* () */0);
          var n$1 = next(/* () */0);
          var e$1 = e;
          var n$2 = n$1;
          return (function (obj) {
              return obj[e$1][n$2];
            });
      case 3 : 
          var n$3 = next(/* () */0);
          return (function (obj) {
              return Curry._1(obj[0][n$3], obj);
            });
      case 4 : 
          var n$4 = next(/* () */0);
          return (function (obj, x) {
              obj[n$4] = x;
              return /* () */0;
            });
      case 5 : 
          var f = next(/* () */0);
          var x$1 = next(/* () */0);
          return (function () {
              return Curry._1(f, x$1);
            });
      case 6 : 
          var f$1 = next(/* () */0);
          var n$5 = next(/* () */0);
          return (function (obj) {
              return Curry._1(f$1, obj[n$5]);
            });
      case 7 : 
          var f$2 = next(/* () */0);
          var e$2 = next(/* () */0);
          var n$6 = next(/* () */0);
          var f$3 = f$2;
          var e$3 = e$2;
          var n$7 = n$6;
          return (function (obj) {
              return Curry._1(f$3, obj[e$3][n$7]);
            });
      case 8 : 
          var f$4 = next(/* () */0);
          var n$8 = next(/* () */0);
          var f$5 = f$4;
          var n$9 = n$8;
          return (function (obj) {
              return Curry._1(f$5, Curry._1(obj[0][n$9], obj));
            });
      case 9 : 
          var f$6 = next(/* () */0);
          var x$2 = next(/* () */0);
          var y = next(/* () */0);
          return (function () {
              return Curry._2(f$6, x$2, y);
            });
      case 10 : 
          var f$7 = next(/* () */0);
          var x$3 = next(/* () */0);
          var n$10 = next(/* () */0);
          var f$8 = f$7;
          var x$4 = x$3;
          var n$11 = n$10;
          return (function (obj) {
              return Curry._2(f$8, x$4, obj[n$11]);
            });
      case 11 : 
          var f$9 = next(/* () */0);
          var x$5 = next(/* () */0);
          var e$4 = next(/* () */0);
          var n$12 = next(/* () */0);
          var f$10 = f$9;
          var x$6 = x$5;
          var e$5 = e$4;
          var n$13 = n$12;
          return (function (obj) {
              return Curry._2(f$10, x$6, obj[e$5][n$13]);
            });
      case 12 : 
          var f$11 = next(/* () */0);
          var x$7 = next(/* () */0);
          var n$14 = next(/* () */0);
          var f$12 = f$11;
          var x$8 = x$7;
          var n$15 = n$14;
          return (function (obj) {
              return Curry._2(f$12, x$8, Curry._1(obj[0][n$15], obj));
            });
      case 13 : 
          var f$13 = next(/* () */0);
          var n$16 = next(/* () */0);
          var x$9 = next(/* () */0);
          var f$14 = f$13;
          var n$17 = n$16;
          var x$10 = x$9;
          return (function (obj) {
              return Curry._2(f$14, obj[n$17], x$10);
            });
      case 14 : 
          var f$15 = next(/* () */0);
          var e$6 = next(/* () */0);
          var n$18 = next(/* () */0);
          var x$11 = next(/* () */0);
          var f$16 = f$15;
          var e$7 = e$6;
          var n$19 = n$18;
          var x$12 = x$11;
          return (function (obj) {
              return Curry._2(f$16, obj[e$7][n$19], x$12);
            });
      case 15 : 
          var f$17 = next(/* () */0);
          var n$20 = next(/* () */0);
          var x$13 = next(/* () */0);
          var f$18 = f$17;
          var n$21 = n$20;
          var x$14 = x$13;
          return (function (obj) {
              return Curry._2(f$18, Curry._1(obj[0][n$21], obj), x$14);
            });
      case 16 : 
          var n$22 = next(/* () */0);
          var x$15 = next(/* () */0);
          var n$23 = n$22;
          var x$16 = x$15;
          return (function (obj) {
              return Curry._2(obj[0][n$23], obj, x$16);
            });
      case 17 : 
          var n$24 = next(/* () */0);
          var m = next(/* () */0);
          var n$25 = n$24;
          var m$1 = m;
          return (function (obj) {
              return Curry._2(obj[0][n$25], obj, obj[m$1]);
            });
      case 18 : 
          var n$26 = next(/* () */0);
          var e$8 = next(/* () */0);
          var m$2 = next(/* () */0);
          var n$27 = n$26;
          var e$9 = e$8;
          var m$3 = m$2;
          return (function (obj) {
              return Curry._2(obj[0][n$27], obj, obj[e$9][m$3]);
            });
      case 19 : 
          var n$28 = next(/* () */0);
          var m$4 = next(/* () */0);
          var n$29 = n$28;
          var m$5 = m$4;
          return (function (obj) {
              return Curry._2(obj[0][n$29], obj, Curry._1(obj[0][m$5], obj));
            });
      case 20 : 
          var m$6 = next(/* () */0);
          var x$17 = next(/* () */0);
          var m$7 = m$6;
          var x$18 = x$17;
          new_cache(table);
          return (function () {
              return Curry._1(Curry._3(Caml_oo.caml_get_public_method, x$18, m$7, 1), x$18);
            });
      case 21 : 
          var m$8 = next(/* () */0);
          var n$30 = next(/* () */0);
          var m$9 = m$8;
          var n$31 = n$30;
          new_cache(table);
          return (function (obj) {
              var tmp = obj[n$31];
              return Curry._1(Curry._3(Caml_oo.caml_get_public_method, tmp, m$9, 2), tmp);
            });
      case 22 : 
          var m$10 = next(/* () */0);
          var e$10 = next(/* () */0);
          var n$32 = next(/* () */0);
          var m$11 = m$10;
          var e$11 = e$10;
          var n$33 = n$32;
          new_cache(table);
          return (function (obj) {
              var tmp = obj[e$11][n$33];
              return Curry._1(Curry._3(Caml_oo.caml_get_public_method, tmp, m$11, 3), tmp);
            });
      case 23 : 
          var m$12 = next(/* () */0);
          var n$34 = next(/* () */0);
          var m$13 = m$12;
          var n$35 = n$34;
          new_cache(table);
          return (function (obj) {
              var tmp = Curry._1(obj[0][n$35], obj);
              return Curry._1(Curry._3(Caml_oo.caml_get_public_method, tmp, m$13, 4), tmp);
            });
      
    }
  } else {
    return clo;
  }
}

function set_methods(table, methods) {
  var len = methods.length;
  var i = [0];
  while(i[0] < len) {
    var label = Caml_array.caml_array_get(methods, i[0]);
    var clo = method_impl(table, i, methods);
    set_method(table, label, clo);
    i[0] = i[0] + 1 | 0;
  };
  return /* () */0;
}

function stats() {
  return /* record */[
          /* classes */table_count[0],
          /* methods */method_count[0],
          /* inst_vars */inst_var_count[0]
        ];
}

exports.public_method_label                = public_method_label;
exports.new_method                         = new_method;
exports.new_variable                       = new_variable;
exports.new_methods_variables              = new_methods_variables;
exports.get_variable                       = get_variable;
exports.get_variables                      = get_variables;
exports.get_method_label                   = get_method_label;
exports.get_method_labels                  = get_method_labels;
exports.get_method                         = get_method;
exports.set_method                         = set_method;
exports.set_methods                        = set_methods;
exports.narrow                             = narrow;
exports.widen                              = widen;
exports.add_initializer                    = add_initializer;
exports.dummy_table                        = dummy_table;
exports.create_table                       = create_table;
exports.init_class                         = init_class;
exports.inherits                           = inherits;
exports.make_class                         = make_class;
exports.make_class_store                   = make_class_store;
exports.dummy_class                        = dummy_class;
exports.copy                               = copy;
exports.create_object                      = create_object;
exports.create_object_opt                  = create_object_opt;
exports.run_initializers                   = run_initializers;
exports.run_initializers_opt               = run_initializers_opt;
exports.create_object_and_run_initializers = create_object_and_run_initializers;
exports.lookup_tables                      = lookup_tables;
exports.params                             = params;
exports.stats                              = stats;
/* No side effect */

},{"./array.js":9,"./caml_array.js":12,"./caml_builtin_exceptions.js":13,"./caml_exceptions.js":14,"./caml_int32.js":16,"./caml_obj.js":20,"./caml_oo.js":21,"./caml_string.js":23,"./curry.js":30,"./list.js":33,"./obj.js":35}],29:[function(require,module,exports){
'use strict';

var Caml_string             = require("./caml_string.js");
var Caml_builtin_exceptions = require("./caml_builtin_exceptions.js");

function chr(n) {
  if (n < 0 || n > 255) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Char.chr"
        ];
  } else {
    return n;
  }
}

function escaped(c) {
  var exit = 0;
  if (c >= 40) {
    if (c !== 92) {
      exit = c >= 127 ? 1 : 2;
    } else {
      return "\\\\";
    }
  } else if (c >= 32) {
    if (c >= 39) {
      return "\\'";
    } else {
      exit = 2;
    }
  } else if (c >= 14) {
    exit = 1;
  } else {
    switch (c) {
      case 8 : 
          return "\\b";
      case 9 : 
          return "\\t";
      case 10 : 
          return "\\n";
      case 0 : 
      case 1 : 
      case 2 : 
      case 3 : 
      case 4 : 
      case 5 : 
      case 6 : 
      case 7 : 
      case 11 : 
      case 12 : 
          exit = 1;
          break;
      case 13 : 
          return "\\r";
      
    }
  }
  switch (exit) {
    case 1 : 
        var s = new Array(4);
        s[0] = /* "\\" */92;
        s[1] = 48 + (c / 100 | 0) | 0;
        s[2] = 48 + (c / 10 | 0) % 10 | 0;
        s[3] = 48 + c % 10 | 0;
        return Caml_string.bytes_to_string(s);
    case 2 : 
        var s$1 = new Array(1);
        s$1[0] = c;
        return Caml_string.bytes_to_string(s$1);
    
  }
}

function lowercase(c) {
  if (c >= /* "A" */65 && c <= /* "Z" */90 || c >= /* "\192" */192 && c <= /* "\214" */214 || c >= /* "\216" */216 && c <= /* "\222" */222) {
    return c + 32 | 0;
  } else {
    return c;
  }
}

function uppercase(c) {
  if (c >= /* "a" */97 && c <= /* "z" */122 || c >= /* "\224" */224 && c <= /* "\246" */246 || c >= /* "\248" */248 && c <= /* "\254" */254) {
    return c - 32 | 0;
  } else {
    return c;
  }
}

function compare(c1, c2) {
  return c1 - c2 | 0;
}

exports.chr       = chr;
exports.escaped   = escaped;
exports.lowercase = lowercase;
exports.uppercase = uppercase;
exports.compare   = compare;
/* No side effect */

},{"./caml_builtin_exceptions.js":13,"./caml_string.js":23}],30:[function(require,module,exports){
'use strict';

var Caml_array = require("./caml_array.js");

function app(_f, _args) {
  while(true) {
    var args = _args;
    var f = _f;
    var arity = f.length;
    var arity$1 = arity ? arity : 1;
    var len = args.length;
    var d = arity$1 - len | 0;
    if (d) {
      if (d < 0) {
        _args = Caml_array.caml_array_sub(args, arity$1, -d | 0);
        _f = f.apply(null, Caml_array.caml_array_sub(args, 0, arity$1));
        continue ;
        
      } else {
        return (function(f,args){
        return function (x) {
          return app(f, args.concat(/* array */[x]));
        }
        }(f,args));
      }
    } else {
      return f.apply(null, args);
    }
  };
}

function curry_1(o, a0, arity) {
  if (arity > 7 || arity < 0) {
    return app(o, /* array */[a0]);
  } else {
    switch (arity) {
      case 0 : 
      case 1 : 
          return o(a0);
      case 2 : 
          return (function (param) {
              return o(a0, param);
            });
      case 3 : 
          return (function (param, param$1) {
              return o(a0, param, param$1);
            });
      case 4 : 
          return (function (param, param$1, param$2) {
              return o(a0, param, param$1, param$2);
            });
      case 5 : 
          return (function (param, param$1, param$2, param$3) {
              return o(a0, param, param$1, param$2, param$3);
            });
      case 6 : 
          return (function (param, param$1, param$2, param$3, param$4) {
              return o(a0, param, param$1, param$2, param$3, param$4);
            });
      case 7 : 
          return (function (param, param$1, param$2, param$3, param$4, param$5) {
              return o(a0, param, param$1, param$2, param$3, param$4, param$5);
            });
      
    }
  }
}

function _1(o, a0) {
  var arity = o.length;
  if (arity === 1) {
    return o(a0);
  } else {
    return curry_1(o, a0, arity);
  }
}

function __1(o) {
  var arity = o.length;
  if (arity === 1) {
    return o;
  } else {
    return (function (a0) {
        return _1(o, a0);
      });
  }
}

function curry_2(o, a0, a1, arity) {
  if (arity > 7 || arity < 0) {
    return app(o, /* array */[
                a0,
                a1
              ]);
  } else {
    switch (arity) {
      case 0 : 
      case 1 : 
          return app(o(a0), /* array */[a1]);
      case 2 : 
          return o(a0, a1);
      case 3 : 
          return (function (param) {
              return o(a0, a1, param);
            });
      case 4 : 
          return (function (param, param$1) {
              return o(a0, a1, param, param$1);
            });
      case 5 : 
          return (function (param, param$1, param$2) {
              return o(a0, a1, param, param$1, param$2);
            });
      case 6 : 
          return (function (param, param$1, param$2, param$3) {
              return o(a0, a1, param, param$1, param$2, param$3);
            });
      case 7 : 
          return (function (param, param$1, param$2, param$3, param$4) {
              return o(a0, a1, param, param$1, param$2, param$3, param$4);
            });
      
    }
  }
}

function _2(o, a0, a1) {
  var arity = o.length;
  if (arity === 2) {
    return o(a0, a1);
  } else {
    return curry_2(o, a0, a1, arity);
  }
}

function __2(o) {
  var arity = o.length;
  if (arity === 2) {
    return o;
  } else {
    return (function (a0, a1) {
        return _2(o, a0, a1);
      });
  }
}

function curry_3(o, a0, a1, a2, arity) {
  var exit = 0;
  if (arity > 7 || arity < 0) {
    return app(o, /* array */[
                a0,
                a1,
                a2
              ]);
  } else {
    switch (arity) {
      case 0 : 
      case 1 : 
          exit = 1;
          break;
      case 2 : 
          return app(o(a0, a1), /* array */[a2]);
      case 3 : 
          return o(a0, a1, a2);
      case 4 : 
          return (function (param) {
              return o(a0, a1, a2, param);
            });
      case 5 : 
          return (function (param, param$1) {
              return o(a0, a1, a2, param, param$1);
            });
      case 6 : 
          return (function (param, param$1, param$2) {
              return o(a0, a1, a2, param, param$1, param$2);
            });
      case 7 : 
          return (function (param, param$1, param$2, param$3) {
              return o(a0, a1, a2, param, param$1, param$2, param$3);
            });
      
    }
  }
  if (exit === 1) {
    return app(o(a0), /* array */[
                a1,
                a2
              ]);
  }
  
}

function _3(o, a0, a1, a2) {
  var arity = o.length;
  if (arity === 3) {
    return o(a0, a1, a2);
  } else {
    return curry_3(o, a0, a1, a2, arity);
  }
}

function __3(o) {
  var arity = o.length;
  if (arity === 3) {
    return o;
  } else {
    return (function (a0, a1, a2) {
        return _3(o, a0, a1, a2);
      });
  }
}

function curry_4(o, a0, a1, a2, a3, arity) {
  var exit = 0;
  if (arity > 7 || arity < 0) {
    return app(o, /* array */[
                a0,
                a1,
                a2,
                a3
              ]);
  } else {
    switch (arity) {
      case 0 : 
      case 1 : 
          exit = 1;
          break;
      case 2 : 
          return app(o(a0, a1), /* array */[
                      a2,
                      a3
                    ]);
      case 3 : 
          return app(o(a0, a1, a2), /* array */[a3]);
      case 4 : 
          return o(a0, a1, a2, a3);
      case 5 : 
          return (function (param) {
              return o(a0, a1, a2, a3, param);
            });
      case 6 : 
          return (function (param, param$1) {
              return o(a0, a1, a2, a3, param, param$1);
            });
      case 7 : 
          return (function (param, param$1, param$2) {
              return o(a0, a1, a2, a3, param, param$1, param$2);
            });
      
    }
  }
  if (exit === 1) {
    return app(o(a0), /* array */[
                a1,
                a2,
                a3
              ]);
  }
  
}

function _4(o, a0, a1, a2, a3) {
  var arity = o.length;
  if (arity === 4) {
    return o(a0, a1, a2, a3);
  } else {
    return curry_4(o, a0, a1, a2, a3, arity);
  }
}

function __4(o) {
  var arity = o.length;
  if (arity === 4) {
    return o;
  } else {
    return (function (a0, a1, a2, a3) {
        return _4(o, a0, a1, a2, a3);
      });
  }
}

function curry_5(o, a0, a1, a2, a3, a4, arity) {
  var exit = 0;
  if (arity > 7 || arity < 0) {
    return app(o, /* array */[
                a0,
                a1,
                a2,
                a3,
                a4
              ]);
  } else {
    switch (arity) {
      case 0 : 
      case 1 : 
          exit = 1;
          break;
      case 2 : 
          return app(o(a0, a1), /* array */[
                      a2,
                      a3,
                      a4
                    ]);
      case 3 : 
          return app(o(a0, a1, a2), /* array */[
                      a3,
                      a4
                    ]);
      case 4 : 
          return app(o(a0, a1, a2, a3), /* array */[a4]);
      case 5 : 
          return o(a0, a1, a2, a3, a4);
      case 6 : 
          return (function (param) {
              return o(a0, a1, a2, a3, a4, param);
            });
      case 7 : 
          return (function (param, param$1) {
              return o(a0, a1, a2, a3, a4, param, param$1);
            });
      
    }
  }
  if (exit === 1) {
    return app(o(a0), /* array */[
                a1,
                a2,
                a3,
                a4
              ]);
  }
  
}

function _5(o, a0, a1, a2, a3, a4) {
  var arity = o.length;
  if (arity === 5) {
    return o(a0, a1, a2, a3, a4);
  } else {
    return curry_5(o, a0, a1, a2, a3, a4, arity);
  }
}

function __5(o) {
  var arity = o.length;
  if (arity === 5) {
    return o;
  } else {
    return (function (a0, a1, a2, a3, a4) {
        return _5(o, a0, a1, a2, a3, a4);
      });
  }
}

function curry_6(o, a0, a1, a2, a3, a4, a5, arity) {
  var exit = 0;
  if (arity > 7 || arity < 0) {
    return app(o, /* array */[
                a0,
                a1,
                a2,
                a3,
                a4,
                a5
              ]);
  } else {
    switch (arity) {
      case 0 : 
      case 1 : 
          exit = 1;
          break;
      case 2 : 
          return app(o(a0, a1), /* array */[
                      a2,
                      a3,
                      a4,
                      a5
                    ]);
      case 3 : 
          return app(o(a0, a1, a2), /* array */[
                      a3,
                      a4,
                      a5
                    ]);
      case 4 : 
          return app(o(a0, a1, a2, a3), /* array */[
                      a4,
                      a5
                    ]);
      case 5 : 
          return app(o(a0, a1, a2, a3, a4), /* array */[a5]);
      case 6 : 
          return o(a0, a1, a2, a3, a4, a5);
      case 7 : 
          return (function (param) {
              return o(a0, a1, a2, a3, a4, a5, param);
            });
      
    }
  }
  if (exit === 1) {
    return app(o(a0), /* array */[
                a1,
                a2,
                a3,
                a4,
                a5
              ]);
  }
  
}

function _6(o, a0, a1, a2, a3, a4, a5) {
  var arity = o.length;
  if (arity === 6) {
    return o(a0, a1, a2, a3, a4, a5);
  } else {
    return curry_6(o, a0, a1, a2, a3, a4, a5, arity);
  }
}

function __6(o) {
  var arity = o.length;
  if (arity === 6) {
    return o;
  } else {
    return (function (a0, a1, a2, a3, a4, a5) {
        return _6(o, a0, a1, a2, a3, a4, a5);
      });
  }
}

function curry_7(o, a0, a1, a2, a3, a4, a5, a6, arity) {
  var exit = 0;
  if (arity > 7 || arity < 0) {
    return app(o, /* array */[
                a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6
              ]);
  } else {
    switch (arity) {
      case 0 : 
      case 1 : 
          exit = 1;
          break;
      case 2 : 
          return app(o(a0, a1), /* array */[
                      a2,
                      a3,
                      a4,
                      a5,
                      a6
                    ]);
      case 3 : 
          return app(o(a0, a1, a2), /* array */[
                      a3,
                      a4,
                      a5,
                      a6
                    ]);
      case 4 : 
          return app(o(a0, a1, a2, a3), /* array */[
                      a4,
                      a5,
                      a6
                    ]);
      case 5 : 
          return app(o(a0, a1, a2, a3, a4), /* array */[
                      a5,
                      a6
                    ]);
      case 6 : 
          return app(o(a0, a1, a2, a3, a4, a5), /* array */[a6]);
      case 7 : 
          return o(a0, a1, a2, a3, a4, a5, a6);
      
    }
  }
  if (exit === 1) {
    return app(o(a0), /* array */[
                a1,
                a2,
                a3,
                a4,
                a5,
                a6
              ]);
  }
  
}

function _7(o, a0, a1, a2, a3, a4, a5, a6) {
  var arity = o.length;
  if (arity === 7) {
    return o(a0, a1, a2, a3, a4, a5, a6);
  } else {
    return curry_7(o, a0, a1, a2, a3, a4, a5, a6, arity);
  }
}

function __7(o) {
  var arity = o.length;
  if (arity === 7) {
    return o;
  } else {
    return (function (a0, a1, a2, a3, a4, a5, a6) {
        return _7(o, a0, a1, a2, a3, a4, a5, a6);
      });
  }
}

function curry_8(o, a0, a1, a2, a3, a4, a5, a6, a7, arity) {
  var exit = 0;
  if (arity > 7 || arity < 0) {
    return app(o, /* array */[
                a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7
              ]);
  } else {
    switch (arity) {
      case 0 : 
      case 1 : 
          exit = 1;
          break;
      case 2 : 
          return app(o(a0, a1), /* array */[
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7
                    ]);
      case 3 : 
          return app(o(a0, a1, a2), /* array */[
                      a3,
                      a4,
                      a5,
                      a6,
                      a7
                    ]);
      case 4 : 
          return app(o(a0, a1, a2, a3), /* array */[
                      a4,
                      a5,
                      a6,
                      a7
                    ]);
      case 5 : 
          return app(o(a0, a1, a2, a3, a4), /* array */[
                      a5,
                      a6,
                      a7
                    ]);
      case 6 : 
          return app(o(a0, a1, a2, a3, a4, a5), /* array */[
                      a6,
                      a7
                    ]);
      case 7 : 
          return app(o(a0, a1, a2, a3, a4, a5, a6), /* array */[a7]);
      
    }
  }
  if (exit === 1) {
    return app(o(a0), /* array */[
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7
              ]);
  }
  
}

function _8(o, a0, a1, a2, a3, a4, a5, a6, a7) {
  var arity = o.length;
  if (arity === 8) {
    return o(a0, a1, a2, a3, a4, a5, a6, a7);
  } else {
    return curry_8(o, a0, a1, a2, a3, a4, a5, a6, a7, arity);
  }
}

function __8(o) {
  var arity = o.length;
  if (arity === 8) {
    return o;
  } else {
    return (function (a0, a1, a2, a3, a4, a5, a6, a7) {
        return _8(o, a0, a1, a2, a3, a4, a5, a6, a7);
      });
  }
}

exports.app     = app;
exports.curry_1 = curry_1;
exports._1      = _1;
exports.__1     = __1;
exports.curry_2 = curry_2;
exports._2      = _2;
exports.__2     = __2;
exports.curry_3 = curry_3;
exports._3      = _3;
exports.__3     = __3;
exports.curry_4 = curry_4;
exports._4      = _4;
exports.__4     = __4;
exports.curry_5 = curry_5;
exports._5      = _5;
exports.__5     = __5;
exports.curry_6 = curry_6;
exports._6      = _6;
exports.__6     = __6;
exports.curry_7 = curry_7;
exports._7      = _7;
exports.__7     = __7;
exports.curry_8 = curry_8;
exports._8      = _8;
exports.__8     = __8;
/* No side effect */

},{"./caml_array.js":12}],31:[function(require,module,exports){
'use strict';

var Caml_exceptions = require("./caml_exceptions.js");

var $$Error = Caml_exceptions.create("Js_exn.Error");

function internalToOCamlException(e) {
  if (Caml_exceptions.isCamlExceptionOrOpenVariant(e)) {
    return e;
  } else {
    return [
            $$Error,
            e
          ];
  }
}

function raiseError(str) {
  throw new Error(str);
}

function raiseEvalError(str) {
  throw new EvalError(str);
}

function raiseRangeError(str) {
  throw new RangeError(str);
}

function raiseReferenceError(str) {
  throw new ReferenceError(str);
}

function raiseSyntaxError(str) {
  throw new SyntaxError(str);
}

function raiseTypeError(str) {
  throw new TypeError(str);
}

function raiseUriError(str) {
  throw new URIError(str);
}

exports.$$Error                  = $$Error;
exports.internalToOCamlException = internalToOCamlException;
exports.raiseError               = raiseError;
exports.raiseEvalError           = raiseEvalError;
exports.raiseRangeError          = raiseRangeError;
exports.raiseReferenceError      = raiseReferenceError;
exports.raiseSyntaxError         = raiseSyntaxError;
exports.raiseTypeError           = raiseTypeError;
exports.raiseUriError            = raiseUriError;
/* No side effect */

},{"./caml_exceptions.js":14}],32:[function(require,module,exports){
'use strict';


function is_nil_undef(x) {
  if (x === null) {
    return /* true */1;
  } else {
    return +(x === undefined);
  }
}

function null_undefined_to_opt(x) {
  if (x === null || x === undefined) {
    return /* None */0;
  } else {
    return /* Some */[x];
  }
}

function undefined_to_opt(x) {
  if (x === undefined) {
    return /* None */0;
  } else {
    return /* Some */[x];
  }
}

function null_to_opt(x) {
  if (x === null) {
    return /* None */0;
  } else {
    return /* Some */[x];
  }
}

function option_get(x) {
  if (x) {
    return x[0];
  } else {
    return undefined;
  }
}

function option_get_unwrap(x) {
  if (x) {
    return x[0][1];
  } else {
    return undefined;
  }
}

exports.is_nil_undef          = is_nil_undef;
exports.null_undefined_to_opt = null_undefined_to_opt;
exports.undefined_to_opt      = undefined_to_opt;
exports.null_to_opt           = null_to_opt;
exports.option_get            = option_get;
exports.option_get_unwrap     = option_get_unwrap;
/* No side effect */

},{}],33:[function(require,module,exports){
'use strict';

var Curry                   = require("./curry.js");
var Caml_obj                = require("./caml_obj.js");
var Pervasives              = require("./pervasives.js");
var Caml_builtin_exceptions = require("./caml_builtin_exceptions.js");

function length(l) {
  var _len = 0;
  var _param = l;
  while(true) {
    var param = _param;
    var len = _len;
    if (param) {
      _param = param[1];
      _len = len + 1 | 0;
      continue ;
      
    } else {
      return len;
    }
  };
}

function hd(param) {
  if (param) {
    return param[0];
  } else {
    throw [
          Caml_builtin_exceptions.failure,
          "hd"
        ];
  }
}

function tl(param) {
  if (param) {
    return param[1];
  } else {
    throw [
          Caml_builtin_exceptions.failure,
          "tl"
        ];
  }
}

function nth(l, n) {
  if (n < 0) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "List.nth"
        ];
  } else {
    var _l = l;
    var _n = n;
    while(true) {
      var n$1 = _n;
      var l$1 = _l;
      if (l$1) {
        if (n$1) {
          _n = n$1 - 1 | 0;
          _l = l$1[1];
          continue ;
          
        } else {
          return l$1[0];
        }
      } else {
        throw [
              Caml_builtin_exceptions.failure,
              "nth"
            ];
      }
    };
  }
}

function rev_append(_l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      _l2 = /* :: */[
        l1[0],
        l2
      ];
      _l1 = l1[1];
      continue ;
      
    } else {
      return l2;
    }
  };
}

function rev(l) {
  return rev_append(l, /* [] */0);
}

function flatten(param) {
  if (param) {
    return Pervasives.$at(param[0], flatten(param[1]));
  } else {
    return /* [] */0;
  }
}

function map(f, param) {
  if (param) {
    var r = Curry._1(f, param[0]);
    return /* :: */[
            r,
            map(f, param[1])
          ];
  } else {
    return /* [] */0;
  }
}

function mapi(i, f, param) {
  if (param) {
    var r = Curry._2(f, i, param[0]);
    return /* :: */[
            r,
            mapi(i + 1 | 0, f, param[1])
          ];
  } else {
    return /* [] */0;
  }
}

function mapi$1(f, l) {
  return mapi(0, f, l);
}

function rev_map(f, l) {
  var _accu = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var accu = _accu;
    if (param) {
      _param = param[1];
      _accu = /* :: */[
        Curry._1(f, param[0]),
        accu
      ];
      continue ;
      
    } else {
      return accu;
    }
  };
}

function iter(f, _param) {
  while(true) {
    var param = _param;
    if (param) {
      Curry._1(f, param[0]);
      _param = param[1];
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function iteri(f, l) {
  var _i = 0;
  var f$1 = f;
  var _param = l;
  while(true) {
    var param = _param;
    var i = _i;
    if (param) {
      Curry._2(f$1, i, param[0]);
      _param = param[1];
      _i = i + 1 | 0;
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function fold_left(f, _accu, _l) {
  while(true) {
    var l = _l;
    var accu = _accu;
    if (l) {
      _l = l[1];
      _accu = Curry._2(f, accu, l[0]);
      continue ;
      
    } else {
      return accu;
    }
  };
}

function fold_right(f, l, accu) {
  if (l) {
    return Curry._2(f, l[0], fold_right(f, l[1], accu));
  } else {
    return accu;
  }
}

function map2(f, l1, l2) {
  if (l1) {
    if (l2) {
      var r = Curry._2(f, l1[0], l2[0]);
      return /* :: */[
              r,
              map2(f, l1[1], l2[1])
            ];
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "List.map2"
          ];
    }
  } else if (l2) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "List.map2"
        ];
  } else {
    return /* [] */0;
  }
}

function rev_map2(f, l1, l2) {
  var _accu = /* [] */0;
  var _l1 = l1;
  var _l2 = l2;
  while(true) {
    var l2$1 = _l2;
    var l1$1 = _l1;
    var accu = _accu;
    if (l1$1) {
      if (l2$1) {
        _l2 = l2$1[1];
        _l1 = l1$1[1];
        _accu = /* :: */[
          Curry._2(f, l1$1[0], l2$1[0]),
          accu
        ];
        continue ;
        
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "List.rev_map2"
            ];
      }
    } else if (l2$1) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "List.rev_map2"
          ];
    } else {
      return accu;
    }
  };
}

function iter2(f, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2) {
        Curry._2(f, l1[0], l2[0]);
        _l2 = l2[1];
        _l1 = l1[1];
        continue ;
        
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "List.iter2"
            ];
      }
    } else if (l2) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "List.iter2"
          ];
    } else {
      return /* () */0;
    }
  };
}

function fold_left2(f, _accu, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    var accu = _accu;
    if (l1) {
      if (l2) {
        _l2 = l2[1];
        _l1 = l1[1];
        _accu = Curry._3(f, accu, l1[0], l2[0]);
        continue ;
        
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "List.fold_left2"
            ];
      }
    } else if (l2) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "List.fold_left2"
          ];
    } else {
      return accu;
    }
  };
}

function fold_right2(f, l1, l2, accu) {
  if (l1) {
    if (l2) {
      return Curry._3(f, l1[0], l2[0], fold_right2(f, l1[1], l2[1], accu));
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "List.fold_right2"
          ];
    }
  } else if (l2) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "List.fold_right2"
        ];
  } else {
    return accu;
  }
}

function for_all(p, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (Curry._1(p, param[0])) {
        _param = param[1];
        continue ;
        
      } else {
        return /* false */0;
      }
    } else {
      return /* true */1;
    }
  };
}

function exists(p, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (Curry._1(p, param[0])) {
        return /* true */1;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return /* false */0;
    }
  };
}

function for_all2(p, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2) {
        if (Curry._2(p, l1[0], l2[0])) {
          _l2 = l2[1];
          _l1 = l1[1];
          continue ;
          
        } else {
          return /* false */0;
        }
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "List.for_all2"
            ];
      }
    } else if (l2) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "List.for_all2"
          ];
    } else {
      return /* true */1;
    }
  };
}

function exists2(p, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2) {
        if (Curry._2(p, l1[0], l2[0])) {
          return /* true */1;
        } else {
          _l2 = l2[1];
          _l1 = l1[1];
          continue ;
          
        }
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "List.exists2"
            ];
      }
    } else if (l2) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "List.exists2"
          ];
    } else {
      return /* false */0;
    }
  };
}

function mem(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (Caml_obj.caml_compare(param[0], x)) {
        _param = param[1];
        continue ;
        
      } else {
        return /* true */1;
      }
    } else {
      return /* false */0;
    }
  };
}

function memq(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (param[0] === x) {
        return /* true */1;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return /* false */0;
    }
  };
}

function assoc(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      if (Caml_obj.caml_compare(match[0], x)) {
        _param = param[1];
        continue ;
        
      } else {
        return match[1];
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function assq(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      if (match[0] === x) {
        return match[1];
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function mem_assoc(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (Caml_obj.caml_compare(param[0][0], x)) {
        _param = param[1];
        continue ;
        
      } else {
        return /* true */1;
      }
    } else {
      return /* false */0;
    }
  };
}

function mem_assq(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (param[0][0] === x) {
        return /* true */1;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return /* false */0;
    }
  };
}

function remove_assoc(x, param) {
  if (param) {
    var l = param[1];
    var pair = param[0];
    if (Caml_obj.caml_compare(pair[0], x)) {
      return /* :: */[
              pair,
              remove_assoc(x, l)
            ];
    } else {
      return l;
    }
  } else {
    return /* [] */0;
  }
}

function remove_assq(x, param) {
  if (param) {
    var l = param[1];
    var pair = param[0];
    if (pair[0] === x) {
      return l;
    } else {
      return /* :: */[
              pair,
              remove_assq(x, l)
            ];
    }
  } else {
    return /* [] */0;
  }
}

function find(p, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var x = param[0];
      if (Curry._1(p, x)) {
        return x;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function find_all(p) {
  return (function (param) {
      var _accu = /* [] */0;
      var _param = param;
      while(true) {
        var param$1 = _param;
        var accu = _accu;
        if (param$1) {
          var l = param$1[1];
          var x = param$1[0];
          if (Curry._1(p, x)) {
            _param = l;
            _accu = /* :: */[
              x,
              accu
            ];
            continue ;
            
          } else {
            _param = l;
            continue ;
            
          }
        } else {
          return rev_append(accu, /* [] */0);
        }
      };
    });
}

function partition(p, l) {
  var _yes = /* [] */0;
  var _no = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var no = _no;
    var yes = _yes;
    if (param) {
      var l$1 = param[1];
      var x = param[0];
      if (Curry._1(p, x)) {
        _param = l$1;
        _yes = /* :: */[
          x,
          yes
        ];
        continue ;
        
      } else {
        _param = l$1;
        _no = /* :: */[
          x,
          no
        ];
        continue ;
        
      }
    } else {
      return /* tuple */[
              rev_append(yes, /* [] */0),
              rev_append(no, /* [] */0)
            ];
    }
  };
}

function split(param) {
  if (param) {
    var match = param[0];
    var match$1 = split(param[1]);
    return /* tuple */[
            /* :: */[
              match[0],
              match$1[0]
            ],
            /* :: */[
              match[1],
              match$1[1]
            ]
          ];
  } else {
    return /* tuple */[
            /* [] */0,
            /* [] */0
          ];
  }
}

function combine(l1, l2) {
  if (l1) {
    if (l2) {
      return /* :: */[
              /* tuple */[
                l1[0],
                l2[0]
              ],
              combine(l1[1], l2[1])
            ];
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "List.combine"
          ];
    }
  } else if (l2) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "List.combine"
        ];
  } else {
    return /* [] */0;
  }
}

function merge(cmp, l1, l2) {
  if (l1) {
    if (l2) {
      var h2 = l2[0];
      var h1 = l1[0];
      if (Curry._2(cmp, h1, h2) <= 0) {
        return /* :: */[
                h1,
                merge(cmp, l1[1], l2)
              ];
      } else {
        return /* :: */[
                h2,
                merge(cmp, l1, l2[1])
              ];
      }
    } else {
      return l1;
    }
  } else {
    return l2;
  }
}

function chop(_k, _l) {
  while(true) {
    var l = _l;
    var k = _k;
    if (k) {
      if (l) {
        _l = l[1];
        _k = k - 1 | 0;
        continue ;
        
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "list.ml",
                223,
                11
              ]
            ];
      }
    } else {
      return l;
    }
  };
}

function stable_sort(cmp, l) {
  var sort = function (n, l) {
    var exit = 0;
    if (n !== 2) {
      if (n !== 3) {
        exit = 1;
      } else if (l) {
        var match = l[1];
        if (match) {
          var match$1 = match[1];
          if (match$1) {
            var x3 = match$1[0];
            var x2 = match[0];
            var x1 = l[0];
            if (Curry._2(cmp, x1, x2) <= 0) {
              if (Curry._2(cmp, x2, x3) <= 0) {
                return /* :: */[
                        x1,
                        /* :: */[
                          x2,
                          /* :: */[
                            x3,
                            /* [] */0
                          ]
                        ]
                      ];
              } else if (Curry._2(cmp, x1, x3) <= 0) {
                return /* :: */[
                        x1,
                        /* :: */[
                          x3,
                          /* :: */[
                            x2,
                            /* [] */0
                          ]
                        ]
                      ];
              } else {
                return /* :: */[
                        x3,
                        /* :: */[
                          x1,
                          /* :: */[
                            x2,
                            /* [] */0
                          ]
                        ]
                      ];
              }
            } else if (Curry._2(cmp, x1, x3) <= 0) {
              return /* :: */[
                      x2,
                      /* :: */[
                        x1,
                        /* :: */[
                          x3,
                          /* [] */0
                        ]
                      ]
                    ];
            } else if (Curry._2(cmp, x2, x3) <= 0) {
              return /* :: */[
                      x2,
                      /* :: */[
                        x3,
                        /* :: */[
                          x1,
                          /* [] */0
                        ]
                      ]
                    ];
            } else {
              return /* :: */[
                      x3,
                      /* :: */[
                        x2,
                        /* :: */[
                          x1,
                          /* [] */0
                        ]
                      ]
                    ];
            }
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
    } else if (l) {
      var match$2 = l[1];
      if (match$2) {
        var x2$1 = match$2[0];
        var x1$1 = l[0];
        if (Curry._2(cmp, x1$1, x2$1) <= 0) {
          return /* :: */[
                  x1$1,
                  /* :: */[
                    x2$1,
                    /* [] */0
                  ]
                ];
        } else {
          return /* :: */[
                  x2$1,
                  /* :: */[
                    x1$1,
                    /* [] */0
                  ]
                ];
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var n1 = (n >> 1);
      var n2 = n - n1 | 0;
      var l2 = chop(n1, l);
      var s1 = rev_sort(n1, l);
      var s2 = rev_sort(n2, l2);
      var _l1 = s1;
      var _l2 = s2;
      var _accu = /* [] */0;
      while(true) {
        var accu = _accu;
        var l2$1 = _l2;
        var l1 = _l1;
        if (l1) {
          if (l2$1) {
            var h2 = l2$1[0];
            var h1 = l1[0];
            if (Curry._2(cmp, h1, h2) > 0) {
              _accu = /* :: */[
                h1,
                accu
              ];
              _l1 = l1[1];
              continue ;
              
            } else {
              _accu = /* :: */[
                h2,
                accu
              ];
              _l2 = l2$1[1];
              continue ;
              
            }
          } else {
            return rev_append(l1, accu);
          }
        } else {
          return rev_append(l2$1, accu);
        }
      };
    }
    
  };
  var rev_sort = function (n, l) {
    var exit = 0;
    if (n !== 2) {
      if (n !== 3) {
        exit = 1;
      } else if (l) {
        var match = l[1];
        if (match) {
          var match$1 = match[1];
          if (match$1) {
            var x3 = match$1[0];
            var x2 = match[0];
            var x1 = l[0];
            if (Curry._2(cmp, x1, x2) > 0) {
              if (Curry._2(cmp, x2, x3) > 0) {
                return /* :: */[
                        x1,
                        /* :: */[
                          x2,
                          /* :: */[
                            x3,
                            /* [] */0
                          ]
                        ]
                      ];
              } else if (Curry._2(cmp, x1, x3) > 0) {
                return /* :: */[
                        x1,
                        /* :: */[
                          x3,
                          /* :: */[
                            x2,
                            /* [] */0
                          ]
                        ]
                      ];
              } else {
                return /* :: */[
                        x3,
                        /* :: */[
                          x1,
                          /* :: */[
                            x2,
                            /* [] */0
                          ]
                        ]
                      ];
              }
            } else if (Curry._2(cmp, x1, x3) > 0) {
              return /* :: */[
                      x2,
                      /* :: */[
                        x1,
                        /* :: */[
                          x3,
                          /* [] */0
                        ]
                      ]
                    ];
            } else if (Curry._2(cmp, x2, x3) > 0) {
              return /* :: */[
                      x2,
                      /* :: */[
                        x3,
                        /* :: */[
                          x1,
                          /* [] */0
                        ]
                      ]
                    ];
            } else {
              return /* :: */[
                      x3,
                      /* :: */[
                        x2,
                        /* :: */[
                          x1,
                          /* [] */0
                        ]
                      ]
                    ];
            }
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
    } else if (l) {
      var match$2 = l[1];
      if (match$2) {
        var x2$1 = match$2[0];
        var x1$1 = l[0];
        if (Curry._2(cmp, x1$1, x2$1) > 0) {
          return /* :: */[
                  x1$1,
                  /* :: */[
                    x2$1,
                    /* [] */0
                  ]
                ];
        } else {
          return /* :: */[
                  x2$1,
                  /* :: */[
                    x1$1,
                    /* [] */0
                  ]
                ];
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var n1 = (n >> 1);
      var n2 = n - n1 | 0;
      var l2 = chop(n1, l);
      var s1 = sort(n1, l);
      var s2 = sort(n2, l2);
      var _l1 = s1;
      var _l2 = s2;
      var _accu = /* [] */0;
      while(true) {
        var accu = _accu;
        var l2$1 = _l2;
        var l1 = _l1;
        if (l1) {
          if (l2$1) {
            var h2 = l2$1[0];
            var h1 = l1[0];
            if (Curry._2(cmp, h1, h2) <= 0) {
              _accu = /* :: */[
                h1,
                accu
              ];
              _l1 = l1[1];
              continue ;
              
            } else {
              _accu = /* :: */[
                h2,
                accu
              ];
              _l2 = l2$1[1];
              continue ;
              
            }
          } else {
            return rev_append(l1, accu);
          }
        } else {
          return rev_append(l2$1, accu);
        }
      };
    }
    
  };
  var len = length(l);
  if (len < 2) {
    return l;
  } else {
    return sort(len, l);
  }
}

function sort_uniq(cmp, l) {
  var sort = function (n, l) {
    var exit = 0;
    if (n !== 2) {
      if (n !== 3) {
        exit = 1;
      } else if (l) {
        var match = l[1];
        if (match) {
          var match$1 = match[1];
          if (match$1) {
            var x3 = match$1[0];
            var x2 = match[0];
            var x1 = l[0];
            var c = Curry._2(cmp, x1, x2);
            if (c) {
              if (c < 0) {
                var c$1 = Curry._2(cmp, x2, x3);
                if (c$1) {
                  if (c$1 < 0) {
                    return /* :: */[
                            x1,
                            /* :: */[
                              x2,
                              /* :: */[
                                x3,
                                /* [] */0
                              ]
                            ]
                          ];
                  } else {
                    var c$2 = Curry._2(cmp, x1, x3);
                    if (c$2) {
                      if (c$2 < 0) {
                        return /* :: */[
                                x1,
                                /* :: */[
                                  x3,
                                  /* :: */[
                                    x2,
                                    /* [] */0
                                  ]
                                ]
                              ];
                      } else {
                        return /* :: */[
                                x3,
                                /* :: */[
                                  x1,
                                  /* :: */[
                                    x2,
                                    /* [] */0
                                  ]
                                ]
                              ];
                      }
                    } else {
                      return /* :: */[
                              x1,
                              /* :: */[
                                x2,
                                /* [] */0
                              ]
                            ];
                    }
                  }
                } else {
                  return /* :: */[
                          x1,
                          /* :: */[
                            x2,
                            /* [] */0
                          ]
                        ];
                }
              } else {
                var c$3 = Curry._2(cmp, x1, x3);
                if (c$3) {
                  if (c$3 < 0) {
                    return /* :: */[
                            x2,
                            /* :: */[
                              x1,
                              /* :: */[
                                x3,
                                /* [] */0
                              ]
                            ]
                          ];
                  } else {
                    var c$4 = Curry._2(cmp, x2, x3);
                    if (c$4) {
                      if (c$4 < 0) {
                        return /* :: */[
                                x2,
                                /* :: */[
                                  x3,
                                  /* :: */[
                                    x1,
                                    /* [] */0
                                  ]
                                ]
                              ];
                      } else {
                        return /* :: */[
                                x3,
                                /* :: */[
                                  x2,
                                  /* :: */[
                                    x1,
                                    /* [] */0
                                  ]
                                ]
                              ];
                      }
                    } else {
                      return /* :: */[
                              x2,
                              /* :: */[
                                x1,
                                /* [] */0
                              ]
                            ];
                    }
                  }
                } else {
                  return /* :: */[
                          x2,
                          /* :: */[
                            x1,
                            /* [] */0
                          ]
                        ];
                }
              }
            } else {
              var c$5 = Curry._2(cmp, x2, x3);
              if (c$5) {
                if (c$5 < 0) {
                  return /* :: */[
                          x2,
                          /* :: */[
                            x3,
                            /* [] */0
                          ]
                        ];
                } else {
                  return /* :: */[
                          x3,
                          /* :: */[
                            x2,
                            /* [] */0
                          ]
                        ];
                }
              } else {
                return /* :: */[
                        x2,
                        /* [] */0
                      ];
              }
            }
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
    } else if (l) {
      var match$2 = l[1];
      if (match$2) {
        var x2$1 = match$2[0];
        var x1$1 = l[0];
        var c$6 = Curry._2(cmp, x1$1, x2$1);
        if (c$6) {
          if (c$6 < 0) {
            return /* :: */[
                    x1$1,
                    /* :: */[
                      x2$1,
                      /* [] */0
                    ]
                  ];
          } else {
            return /* :: */[
                    x2$1,
                    /* :: */[
                      x1$1,
                      /* [] */0
                    ]
                  ];
          }
        } else {
          return /* :: */[
                  x1$1,
                  /* [] */0
                ];
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var n1 = (n >> 1);
      var n2 = n - n1 | 0;
      var l2 = chop(n1, l);
      var s1 = rev_sort(n1, l);
      var s2 = rev_sort(n2, l2);
      var _l1 = s1;
      var _l2 = s2;
      var _accu = /* [] */0;
      while(true) {
        var accu = _accu;
        var l2$1 = _l2;
        var l1 = _l1;
        if (l1) {
          if (l2$1) {
            var t2 = l2$1[1];
            var h2 = l2$1[0];
            var t1 = l1[1];
            var h1 = l1[0];
            var c$7 = Curry._2(cmp, h1, h2);
            if (c$7) {
              if (c$7 > 0) {
                _accu = /* :: */[
                  h1,
                  accu
                ];
                _l1 = t1;
                continue ;
                
              } else {
                _accu = /* :: */[
                  h2,
                  accu
                ];
                _l2 = t2;
                continue ;
                
              }
            } else {
              _accu = /* :: */[
                h1,
                accu
              ];
              _l2 = t2;
              _l1 = t1;
              continue ;
              
            }
          } else {
            return rev_append(l1, accu);
          }
        } else {
          return rev_append(l2$1, accu);
        }
      };
    }
    
  };
  var rev_sort = function (n, l) {
    var exit = 0;
    if (n !== 2) {
      if (n !== 3) {
        exit = 1;
      } else if (l) {
        var match = l[1];
        if (match) {
          var match$1 = match[1];
          if (match$1) {
            var x3 = match$1[0];
            var x2 = match[0];
            var x1 = l[0];
            var c = Curry._2(cmp, x1, x2);
            if (c) {
              if (c > 0) {
                var c$1 = Curry._2(cmp, x2, x3);
                if (c$1) {
                  if (c$1 > 0) {
                    return /* :: */[
                            x1,
                            /* :: */[
                              x2,
                              /* :: */[
                                x3,
                                /* [] */0
                              ]
                            ]
                          ];
                  } else {
                    var c$2 = Curry._2(cmp, x1, x3);
                    if (c$2) {
                      if (c$2 > 0) {
                        return /* :: */[
                                x1,
                                /* :: */[
                                  x3,
                                  /* :: */[
                                    x2,
                                    /* [] */0
                                  ]
                                ]
                              ];
                      } else {
                        return /* :: */[
                                x3,
                                /* :: */[
                                  x1,
                                  /* :: */[
                                    x2,
                                    /* [] */0
                                  ]
                                ]
                              ];
                      }
                    } else {
                      return /* :: */[
                              x1,
                              /* :: */[
                                x2,
                                /* [] */0
                              ]
                            ];
                    }
                  }
                } else {
                  return /* :: */[
                          x1,
                          /* :: */[
                            x2,
                            /* [] */0
                          ]
                        ];
                }
              } else {
                var c$3 = Curry._2(cmp, x1, x3);
                if (c$3) {
                  if (c$3 > 0) {
                    return /* :: */[
                            x2,
                            /* :: */[
                              x1,
                              /* :: */[
                                x3,
                                /* [] */0
                              ]
                            ]
                          ];
                  } else {
                    var c$4 = Curry._2(cmp, x2, x3);
                    if (c$4) {
                      if (c$4 > 0) {
                        return /* :: */[
                                x2,
                                /* :: */[
                                  x3,
                                  /* :: */[
                                    x1,
                                    /* [] */0
                                  ]
                                ]
                              ];
                      } else {
                        return /* :: */[
                                x3,
                                /* :: */[
                                  x2,
                                  /* :: */[
                                    x1,
                                    /* [] */0
                                  ]
                                ]
                              ];
                      }
                    } else {
                      return /* :: */[
                              x2,
                              /* :: */[
                                x1,
                                /* [] */0
                              ]
                            ];
                    }
                  }
                } else {
                  return /* :: */[
                          x2,
                          /* :: */[
                            x1,
                            /* [] */0
                          ]
                        ];
                }
              }
            } else {
              var c$5 = Curry._2(cmp, x2, x3);
              if (c$5) {
                if (c$5 > 0) {
                  return /* :: */[
                          x2,
                          /* :: */[
                            x3,
                            /* [] */0
                          ]
                        ];
                } else {
                  return /* :: */[
                          x3,
                          /* :: */[
                            x2,
                            /* [] */0
                          ]
                        ];
                }
              } else {
                return /* :: */[
                        x2,
                        /* [] */0
                      ];
              }
            }
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
    } else if (l) {
      var match$2 = l[1];
      if (match$2) {
        var x2$1 = match$2[0];
        var x1$1 = l[0];
        var c$6 = Curry._2(cmp, x1$1, x2$1);
        if (c$6) {
          if (c$6 > 0) {
            return /* :: */[
                    x1$1,
                    /* :: */[
                      x2$1,
                      /* [] */0
                    ]
                  ];
          } else {
            return /* :: */[
                    x2$1,
                    /* :: */[
                      x1$1,
                      /* [] */0
                    ]
                  ];
          }
        } else {
          return /* :: */[
                  x1$1,
                  /* [] */0
                ];
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var n1 = (n >> 1);
      var n2 = n - n1 | 0;
      var l2 = chop(n1, l);
      var s1 = sort(n1, l);
      var s2 = sort(n2, l2);
      var _l1 = s1;
      var _l2 = s2;
      var _accu = /* [] */0;
      while(true) {
        var accu = _accu;
        var l2$1 = _l2;
        var l1 = _l1;
        if (l1) {
          if (l2$1) {
            var t2 = l2$1[1];
            var h2 = l2$1[0];
            var t1 = l1[1];
            var h1 = l1[0];
            var c$7 = Curry._2(cmp, h1, h2);
            if (c$7) {
              if (c$7 < 0) {
                _accu = /* :: */[
                  h1,
                  accu
                ];
                _l1 = t1;
                continue ;
                
              } else {
                _accu = /* :: */[
                  h2,
                  accu
                ];
                _l2 = t2;
                continue ;
                
              }
            } else {
              _accu = /* :: */[
                h1,
                accu
              ];
              _l2 = t2;
              _l1 = t1;
              continue ;
              
            }
          } else {
            return rev_append(l1, accu);
          }
        } else {
          return rev_append(l2$1, accu);
        }
      };
    }
    
  };
  var len = length(l);
  if (len < 2) {
    return l;
  } else {
    return sort(len, l);
  }
}

var append = Pervasives.$at;

var concat = flatten;

var filter = find_all;

var sort = stable_sort;

var fast_sort = stable_sort;

exports.length       = length;
exports.hd           = hd;
exports.tl           = tl;
exports.nth          = nth;
exports.rev          = rev;
exports.append       = append;
exports.rev_append   = rev_append;
exports.concat       = concat;
exports.flatten      = flatten;
exports.iter         = iter;
exports.iteri        = iteri;
exports.map          = map;
exports.mapi         = mapi$1;
exports.rev_map      = rev_map;
exports.fold_left    = fold_left;
exports.fold_right   = fold_right;
exports.iter2        = iter2;
exports.map2         = map2;
exports.rev_map2     = rev_map2;
exports.fold_left2   = fold_left2;
exports.fold_right2  = fold_right2;
exports.for_all      = for_all;
exports.exists       = exists;
exports.for_all2     = for_all2;
exports.exists2      = exists2;
exports.mem          = mem;
exports.memq         = memq;
exports.find         = find;
exports.filter       = filter;
exports.find_all     = find_all;
exports.partition    = partition;
exports.assoc        = assoc;
exports.assq         = assq;
exports.mem_assoc    = mem_assoc;
exports.mem_assq     = mem_assq;
exports.remove_assoc = remove_assoc;
exports.remove_assq  = remove_assq;
exports.split        = split;
exports.combine      = combine;
exports.sort         = sort;
exports.stable_sort  = stable_sort;
exports.fast_sort    = fast_sort;
exports.sort_uniq    = sort_uniq;
exports.merge        = merge;
/* No side effect */

},{"./caml_builtin_exceptions.js":13,"./caml_obj.js":20,"./curry.js":30,"./pervasives.js":36}],34:[function(require,module,exports){
'use strict';

var Caml_string             = require("./caml_string.js");
var Caml_missing_polyfill   = require("./caml_missing_polyfill.js");
var Caml_builtin_exceptions = require("./caml_builtin_exceptions.js");

function to_buffer(buff, ofs, len, _, _$1) {
  if (ofs < 0 || len < 0 || ofs > (buff.length - len | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Marshal.to_buffer: substring out of bounds"
        ];
  } else {
    return Caml_missing_polyfill.not_implemented("caml_output_value_to_buffer not implemented by bucklescript yet\n");
  }
}

function data_size(buff, ofs) {
  if (ofs < 0 || ofs > (buff.length - 20 | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Marshal.data_size"
        ];
  } else {
    return Caml_missing_polyfill.not_implemented("caml_marshal_data_size not implemented by bucklescript yet\n");
  }
}

function total_size(buff, ofs) {
  return 20 + data_size(buff, ofs) | 0;
}

function from_bytes(buff, ofs) {
  if (ofs < 0 || ofs > (buff.length - 20 | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Marshal.from_bytes"
        ];
  } else {
    var len = Caml_missing_polyfill.not_implemented("caml_marshal_data_size not implemented by bucklescript yet\n");
    if (ofs > (buff.length - (20 + len | 0) | 0)) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Marshal.from_bytes"
          ];
    } else {
      return Caml_missing_polyfill.not_implemented("caml_input_value_from_string not implemented by bucklescript yet\n");
    }
  }
}

function from_string(buff, ofs) {
  return from_bytes(Caml_string.bytes_of_string(buff), ofs);
}

function to_channel(_, _$1, _$2) {
  return Caml_missing_polyfill.not_implemented("caml_output_value not implemented by bucklescript yet\n");
}

function from_channel() {
  return Caml_missing_polyfill.not_implemented("caml_input_value not implemented by bucklescript yet\n");
}

var header_size = 20;

exports.to_channel   = to_channel;
exports.to_buffer    = to_buffer;
exports.from_channel = from_channel;
exports.from_bytes   = from_bytes;
exports.from_string  = from_string;
exports.header_size  = header_size;
exports.data_size    = data_size;
exports.total_size   = total_size;
/* No side effect */

},{"./caml_builtin_exceptions.js":13,"./caml_missing_polyfill.js":19,"./caml_string.js":23}],35:[function(require,module,exports){
'use strict';

var Marshal                 = require("./marshal.js");
var Caml_array              = require("./caml_array.js");
var Caml_missing_polyfill   = require("./caml_missing_polyfill.js");
var Caml_builtin_exceptions = require("./caml_builtin_exceptions.js");

var double_field = Caml_array.caml_array_get;

var set_double_field = Caml_array.caml_array_set;

function marshal() {
  return Caml_missing_polyfill.not_implemented("caml_output_value_to_string not implemented by bucklescript yet\n");
}

function unmarshal(str, pos) {
  return /* tuple */[
          Marshal.from_bytes(str, pos),
          pos + Marshal.total_size(str, pos) | 0
        ];
}

function extension_slot(x) {
  var slot = x.length !== undefined && (x.tag | 0) !== 248 && x.length >= 1 ? x[0] : x;
  var name;
  if (slot.length !== undefined && slot.tag === 248) {
    name = slot[0];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
  if (name.tag === 252) {
    return slot;
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function extension_name(x) {
  try {
    var slot = extension_slot(x);
    return slot[0];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Obj.extension_name"
          ];
    } else {
      throw exn;
    }
  }
}

function extension_id(x) {
  try {
    var slot = extension_slot(x);
    return slot[1];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Obj.extension_id"
          ];
    } else {
      throw exn;
    }
  }
}

function extension_slot$1(x) {
  try {
    return extension_slot(x);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Obj.extension_slot"
          ];
    } else {
      throw exn;
    }
  }
}

var first_non_constant_constructor_tag = 0;

var last_non_constant_constructor_tag = 245;

var lazy_tag = 246;

var closure_tag = 247;

var object_tag = 248;

var infix_tag = 249;

var forward_tag = 250;

var no_scan_tag = 251;

var abstract_tag = 251;

var string_tag = 252;

var double_tag = 253;

var double_array_tag = 254;

var custom_tag = 255;

var final_tag = 255;

var int_tag = 1000;

var out_of_heap_tag = 1001;

var unaligned_tag = 1002;

exports.double_field                       = double_field;
exports.set_double_field                   = set_double_field;
exports.first_non_constant_constructor_tag = first_non_constant_constructor_tag;
exports.last_non_constant_constructor_tag  = last_non_constant_constructor_tag;
exports.lazy_tag                           = lazy_tag;
exports.closure_tag                        = closure_tag;
exports.object_tag                         = object_tag;
exports.infix_tag                          = infix_tag;
exports.forward_tag                        = forward_tag;
exports.no_scan_tag                        = no_scan_tag;
exports.abstract_tag                       = abstract_tag;
exports.string_tag                         = string_tag;
exports.double_tag                         = double_tag;
exports.double_array_tag                   = double_array_tag;
exports.custom_tag                         = custom_tag;
exports.final_tag                          = final_tag;
exports.int_tag                            = int_tag;
exports.out_of_heap_tag                    = out_of_heap_tag;
exports.unaligned_tag                      = unaligned_tag;
exports.extension_name                     = extension_name;
exports.extension_id                       = extension_id;
exports.extension_slot                     = extension_slot$1;
exports.marshal                            = marshal;
exports.unmarshal                          = unmarshal;
/* No side effect */

},{"./caml_array.js":12,"./caml_builtin_exceptions.js":13,"./caml_missing_polyfill.js":19,"./marshal.js":34}],36:[function(require,module,exports){
'use strict';

var Curry                    = require("./curry.js");
var Caml_io                  = require("./caml_io.js");
var Caml_obj                 = require("./caml_obj.js");
var Caml_sys                 = require("./caml_sys.js");
var Caml_format              = require("./caml_format.js");
var Caml_string              = require("./caml_string.js");
var Caml_exceptions          = require("./caml_exceptions.js");
var Caml_missing_polyfill    = require("./caml_missing_polyfill.js");
var Caml_builtin_exceptions  = require("./caml_builtin_exceptions.js");
var CamlinternalFormatBasics = require("./camlinternalFormatBasics.js");

function failwith(s) {
  throw [
        Caml_builtin_exceptions.failure,
        s
      ];
}

function invalid_arg(s) {
  throw [
        Caml_builtin_exceptions.invalid_argument,
        s
      ];
}

var Exit = Caml_exceptions.create("Pervasives.Exit");

function min(x, y) {
  if (Caml_obj.caml_lessequal(x, y)) {
    return x;
  } else {
    return y;
  }
}

function max(x, y) {
  if (Caml_obj.caml_greaterequal(x, y)) {
    return x;
  } else {
    return y;
  }
}

function abs(x) {
  if (x >= 0) {
    return x;
  } else {
    return -x | 0;
  }
}

function lnot(x) {
  return x ^ -1;
}

var min_int = -2147483648;

function $caret(a, b) {
  return a + b;
}

function char_of_int(n) {
  if (n < 0 || n > 255) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "char_of_int"
        ];
  } else {
    return n;
  }
}

function string_of_bool(b) {
  if (b) {
    return "true";
  } else {
    return "false";
  }
}

function bool_of_string(param) {
  switch (param) {
    case "false" : 
        return /* false */0;
    case "true" : 
        return /* true */1;
    default:
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "bool_of_string"
          ];
  }
}

function string_of_int(param) {
  return "" + param;
}

function valid_float_lexem(s) {
  var l = s.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i >= l) {
      return $caret(s, ".");
    } else {
      var match = Caml_string.get(s, i);
      if (match >= 48) {
        if (match >= 58) {
          return s;
        } else {
          _i = i + 1 | 0;
          continue ;
          
        }
      } else if (match !== 45) {
        return s;
      } else {
        _i = i + 1 | 0;
        continue ;
        
      }
    }
  };
}

function string_of_float(f) {
  return valid_float_lexem(Caml_format.caml_format_float("%.12g", f));
}

function $at(l1, l2) {
  if (l1) {
    return /* :: */[
            l1[0],
            $at(l1[1], l2)
          ];
  } else {
    return l2;
  }
}

var stdin = Caml_io.stdin;

var stdout = Caml_io.stdout;

var stderr = Caml_io.stderr;

function open_out_gen(_, _$1, _$2) {
  return Caml_io.caml_ml_open_descriptor_out(Caml_missing_polyfill.not_implemented("caml_sys_open not implemented by bucklescript yet\n"));
}

function open_out(name) {
  return open_out_gen(/* :: */[
              /* Open_wronly */1,
              /* :: */[
                /* Open_creat */3,
                /* :: */[
                  /* Open_trunc */4,
                  /* :: */[
                    /* Open_text */7,
                    /* [] */0
                  ]
                ]
              ]
            ], 438, name);
}

function open_out_bin(name) {
  return open_out_gen(/* :: */[
              /* Open_wronly */1,
              /* :: */[
                /* Open_creat */3,
                /* :: */[
                  /* Open_trunc */4,
                  /* :: */[
                    /* Open_binary */6,
                    /* [] */0
                  ]
                ]
              ]
            ], 438, name);
}

function flush_all() {
  var _param = Caml_io.caml_ml_out_channels_list(/* () */0);
  while(true) {
    var param = _param;
    if (param) {
      try {
        Caml_io.caml_ml_flush(param[0]);
      }
      catch (exn){
        
      }
      _param = param[1];
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function output_bytes(oc, s) {
  return Caml_io.caml_ml_output(oc, s, 0, s.length);
}

function output_string(oc, s) {
  return Caml_io.caml_ml_output(oc, s, 0, s.length);
}

function output(oc, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "output"
        ];
  } else {
    return Caml_io.caml_ml_output(oc, s, ofs, len);
  }
}

function output_substring(oc, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "output_substring"
        ];
  } else {
    return Caml_io.caml_ml_output(oc, s, ofs, len);
  }
}

function output_value(_, _$1) {
  return Caml_missing_polyfill.not_implemented("caml_output_value not implemented by bucklescript yet\n");
}

function close_out(oc) {
  Caml_io.caml_ml_flush(oc);
  return Caml_missing_polyfill.not_implemented("caml_ml_close_channel not implemented by bucklescript yet\n");
}

function close_out_noerr(oc) {
  try {
    Caml_io.caml_ml_flush(oc);
  }
  catch (exn){
    
  }
  try {
    return Caml_missing_polyfill.not_implemented("caml_ml_close_channel not implemented by bucklescript yet\n");
  }
  catch (exn$1){
    return /* () */0;
  }
}

function open_in_gen(_, _$1, _$2) {
  return Caml_io.caml_ml_open_descriptor_in(Caml_missing_polyfill.not_implemented("caml_sys_open not implemented by bucklescript yet\n"));
}

function open_in(name) {
  return open_in_gen(/* :: */[
              /* Open_rdonly */0,
              /* :: */[
                /* Open_text */7,
                /* [] */0
              ]
            ], 0, name);
}

function open_in_bin(name) {
  return open_in_gen(/* :: */[
              /* Open_rdonly */0,
              /* :: */[
                /* Open_binary */6,
                /* [] */0
              ]
            ], 0, name);
}

function input(_, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "input"
        ];
  } else {
    return Caml_missing_polyfill.not_implemented("caml_ml_input not implemented by bucklescript yet\n");
  }
}

function unsafe_really_input(_, _$1, _ofs, _len) {
  while(true) {
    var len = _len;
    var ofs = _ofs;
    if (len <= 0) {
      return /* () */0;
    } else {
      var r = Caml_missing_polyfill.not_implemented("caml_ml_input not implemented by bucklescript yet\n");
      if (r) {
        _len = len - r | 0;
        _ofs = ofs + r | 0;
        continue ;
        
      } else {
        throw Caml_builtin_exceptions.end_of_file;
      }
    }
  };
}

function really_input(ic, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "really_input"
        ];
  } else {
    return unsafe_really_input(ic, s, ofs, len);
  }
}

function really_input_string(ic, len) {
  var s = Caml_string.caml_create_string(len);
  really_input(ic, s, 0, len);
  return Caml_string.bytes_to_string(s);
}

function input_line(chan) {
  var build_result = function (buf, _pos, _param) {
    while(true) {
      var param = _param;
      var pos = _pos;
      if (param) {
        var hd = param[0];
        var len = hd.length;
        Caml_string.caml_blit_bytes(hd, 0, buf, pos - len | 0, len);
        _param = param[1];
        _pos = pos - len | 0;
        continue ;
        
      } else {
        return buf;
      }
    };
  };
  var scan = function (_accu, _len) {
    while(true) {
      var len = _len;
      var accu = _accu;
      var n = Caml_missing_polyfill.not_implemented("caml_ml_input_scan_line not implemented by bucklescript yet\n");
      if (n) {
        if (n > 0) {
          var res = Caml_string.caml_create_string(n - 1 | 0);
          Caml_missing_polyfill.not_implemented("caml_ml_input not implemented by bucklescript yet\n");
          Caml_io.caml_ml_input_char(chan);
          if (accu) {
            var len$1 = (len + n | 0) - 1 | 0;
            return build_result(Caml_string.caml_create_string(len$1), len$1, /* :: */[
                        res,
                        accu
                      ]);
          } else {
            return res;
          }
        } else {
          var beg = Caml_string.caml_create_string(-n | 0);
          Caml_missing_polyfill.not_implemented("caml_ml_input not implemented by bucklescript yet\n");
          _len = len - n | 0;
          _accu = /* :: */[
            beg,
            accu
          ];
          continue ;
          
        }
      } else if (accu) {
        return build_result(Caml_string.caml_create_string(len), len, accu);
      } else {
        throw Caml_builtin_exceptions.end_of_file;
      }
    };
  };
  return Caml_string.bytes_to_string(scan(/* [] */0, 0));
}

function close_in_noerr() {
  try {
    return Caml_missing_polyfill.not_implemented("caml_ml_close_channel not implemented by bucklescript yet\n");
  }
  catch (exn){
    return /* () */0;
  }
}

function print_char(c) {
  return Caml_io.caml_ml_output_char(stdout, c);
}

function print_string(s) {
  return output_string(stdout, s);
}

function print_bytes(s) {
  return output_bytes(stdout, s);
}

function print_int(i) {
  return output_string(stdout, "" + i);
}

function print_float(f) {
  return output_string(stdout, valid_float_lexem(Caml_format.caml_format_float("%.12g", f)));
}

function print_endline(param) {
  console.log(param);
  return 0;
}

function print_newline() {
  Caml_io.caml_ml_output_char(stdout, /* "\n" */10);
  return Caml_io.caml_ml_flush(stdout);
}

function prerr_char(c) {
  return Caml_io.caml_ml_output_char(stderr, c);
}

function prerr_string(s) {
  return output_string(stderr, s);
}

function prerr_bytes(s) {
  return output_bytes(stderr, s);
}

function prerr_int(i) {
  return output_string(stderr, "" + i);
}

function prerr_float(f) {
  return output_string(stderr, valid_float_lexem(Caml_format.caml_format_float("%.12g", f)));
}

function prerr_endline(param) {
  console.error(param);
  return 0;
}

function prerr_newline() {
  Caml_io.caml_ml_output_char(stderr, /* "\n" */10);
  return Caml_io.caml_ml_flush(stderr);
}

function read_line() {
  Caml_io.caml_ml_flush(stdout);
  return input_line(stdin);
}

function read_int() {
  return Caml_format.caml_int_of_string((Caml_io.caml_ml_flush(stdout), input_line(stdin)));
}

function read_float() {
  return Caml_format.caml_float_of_string((Caml_io.caml_ml_flush(stdout), input_line(stdin)));
}

function string_of_format(param) {
  return param[1];
}

function $caret$caret(param, param$1) {
  return /* Format */[
          CamlinternalFormatBasics.concat_fmt(param[0], param$1[0]),
          $caret(param[1], $caret("%,", param$1[1]))
        ];
}

var exit_function = [flush_all];

function at_exit(f) {
  var g = exit_function[0];
  exit_function[0] = (function () {
      Curry._1(f, /* () */0);
      return Curry._1(g, /* () */0);
    });
  return /* () */0;
}

function do_at_exit() {
  return Curry._1(exit_function[0], /* () */0);
}

function exit(retcode) {
  do_at_exit(/* () */0);
  return Caml_sys.caml_sys_exit(retcode);
}

var max_int = 2147483647;

var infinity = Infinity;

var neg_infinity = -Infinity;

var nan = NaN;

var max_float = Number.MAX_VALUE;

var min_float = Number.MIN_VALUE;

var epsilon_float = 2.220446049250313e-16;

var flush = Caml_io.caml_ml_flush;

var output_char = Caml_io.caml_ml_output_char;

var output_byte = Caml_io.caml_ml_output_char;

function output_binary_int(_, _$1) {
  return Caml_missing_polyfill.not_implemented("caml_ml_output_int not implemented by bucklescript yet\n");
}

function seek_out(_, _$1) {
  return Caml_missing_polyfill.not_implemented("caml_ml_seek_out not implemented by bucklescript yet\n");
}

function pos_out() {
  return Caml_missing_polyfill.not_implemented("caml_ml_pos_out not implemented by bucklescript yet\n");
}

function out_channel_length() {
  return Caml_missing_polyfill.not_implemented("caml_ml_channel_size not implemented by bucklescript yet\n");
}

function set_binary_mode_out(_, _$1) {
  return Caml_missing_polyfill.not_implemented("caml_ml_set_binary_mode not implemented by bucklescript yet\n");
}

var input_char = Caml_io.caml_ml_input_char;

var input_byte = Caml_io.caml_ml_input_char;

function input_binary_int() {
  return Caml_missing_polyfill.not_implemented("caml_ml_input_int not implemented by bucklescript yet\n");
}

function input_value() {
  return Caml_missing_polyfill.not_implemented("caml_input_value not implemented by bucklescript yet\n");
}

function seek_in(_, _$1) {
  return Caml_missing_polyfill.not_implemented("caml_ml_seek_in not implemented by bucklescript yet\n");
}

function pos_in() {
  return Caml_missing_polyfill.not_implemented("caml_ml_pos_in not implemented by bucklescript yet\n");
}

function in_channel_length() {
  return Caml_missing_polyfill.not_implemented("caml_ml_channel_size not implemented by bucklescript yet\n");
}

function close_in() {
  return Caml_missing_polyfill.not_implemented("caml_ml_close_channel not implemented by bucklescript yet\n");
}

function set_binary_mode_in(_, _$1) {
  return Caml_missing_polyfill.not_implemented("caml_ml_set_binary_mode not implemented by bucklescript yet\n");
}

function LargeFile_000(_, _$1) {
  return Caml_missing_polyfill.not_implemented("caml_ml_seek_out_64 not implemented by bucklescript yet\n");
}

function LargeFile_001() {
  return Caml_missing_polyfill.not_implemented("caml_ml_pos_out_64 not implemented by bucklescript yet\n");
}

function LargeFile_002() {
  return Caml_missing_polyfill.not_implemented("caml_ml_channel_size_64 not implemented by bucklescript yet\n");
}

function LargeFile_003(_, _$1) {
  return Caml_missing_polyfill.not_implemented("caml_ml_seek_in_64 not implemented by bucklescript yet\n");
}

function LargeFile_004() {
  return Caml_missing_polyfill.not_implemented("caml_ml_pos_in_64 not implemented by bucklescript yet\n");
}

function LargeFile_005() {
  return Caml_missing_polyfill.not_implemented("caml_ml_channel_size_64 not implemented by bucklescript yet\n");
}

var LargeFile = [
  LargeFile_000,
  LargeFile_001,
  LargeFile_002,
  LargeFile_003,
  LargeFile_004,
  LargeFile_005
];

exports.invalid_arg         = invalid_arg;
exports.failwith            = failwith;
exports.Exit                = Exit;
exports.min                 = min;
exports.max                 = max;
exports.abs                 = abs;
exports.max_int             = max_int;
exports.min_int             = min_int;
exports.lnot                = lnot;
exports.infinity            = infinity;
exports.neg_infinity        = neg_infinity;
exports.nan                 = nan;
exports.max_float           = max_float;
exports.min_float           = min_float;
exports.epsilon_float       = epsilon_float;
exports.$caret              = $caret;
exports.char_of_int         = char_of_int;
exports.string_of_bool      = string_of_bool;
exports.bool_of_string      = bool_of_string;
exports.string_of_int       = string_of_int;
exports.string_of_float     = string_of_float;
exports.$at                 = $at;
exports.stdin               = stdin;
exports.stdout              = stdout;
exports.stderr              = stderr;
exports.print_char          = print_char;
exports.print_string        = print_string;
exports.print_bytes         = print_bytes;
exports.print_int           = print_int;
exports.print_float         = print_float;
exports.print_endline       = print_endline;
exports.print_newline       = print_newline;
exports.prerr_char          = prerr_char;
exports.prerr_string        = prerr_string;
exports.prerr_bytes         = prerr_bytes;
exports.prerr_int           = prerr_int;
exports.prerr_float         = prerr_float;
exports.prerr_endline       = prerr_endline;
exports.prerr_newline       = prerr_newline;
exports.read_line           = read_line;
exports.read_int            = read_int;
exports.read_float          = read_float;
exports.open_out            = open_out;
exports.open_out_bin        = open_out_bin;
exports.open_out_gen        = open_out_gen;
exports.flush               = flush;
exports.flush_all           = flush_all;
exports.output_char         = output_char;
exports.output_string       = output_string;
exports.output_bytes        = output_bytes;
exports.output              = output;
exports.output_substring    = output_substring;
exports.output_byte         = output_byte;
exports.output_binary_int   = output_binary_int;
exports.output_value        = output_value;
exports.seek_out            = seek_out;
exports.pos_out             = pos_out;
exports.out_channel_length  = out_channel_length;
exports.close_out           = close_out;
exports.close_out_noerr     = close_out_noerr;
exports.set_binary_mode_out = set_binary_mode_out;
exports.open_in             = open_in;
exports.open_in_bin         = open_in_bin;
exports.open_in_gen         = open_in_gen;
exports.input_char          = input_char;
exports.input_line          = input_line;
exports.input               = input;
exports.really_input        = really_input;
exports.really_input_string = really_input_string;
exports.input_byte          = input_byte;
exports.input_binary_int    = input_binary_int;
exports.input_value         = input_value;
exports.seek_in             = seek_in;
exports.pos_in              = pos_in;
exports.in_channel_length   = in_channel_length;
exports.close_in            = close_in;
exports.close_in_noerr      = close_in_noerr;
exports.set_binary_mode_in  = set_binary_mode_in;
exports.LargeFile           = LargeFile;
exports.string_of_format    = string_of_format;
exports.$caret$caret        = $caret$caret;
exports.exit                = exit;
exports.at_exit             = at_exit;
exports.valid_float_lexem   = valid_float_lexem;
exports.unsafe_really_input = unsafe_really_input;
exports.do_at_exit          = do_at_exit;
/* No side effect */

},{"./caml_builtin_exceptions.js":13,"./caml_exceptions.js":14,"./caml_format.js":15,"./caml_io.js":18,"./caml_missing_polyfill.js":19,"./caml_obj.js":20,"./caml_string.js":23,"./caml_sys.js":24,"./camlinternalFormatBasics.js":26,"./curry.js":30}],37:[function(require,module,exports){
'use strict';

var Curry           = require("./curry.js");
var Caml_obj        = require("./caml_obj.js");
var Caml_exceptions = require("./caml_exceptions.js");

var Empty = Caml_exceptions.create("Queue.Empty");

function create() {
  return /* record */[
          /* length */0,
          /* tail : None */0
        ];
}

function clear(q) {
  q[/* length */0] = 0;
  q[/* tail */1] = /* None */0;
  return /* () */0;
}

function add(x, q) {
  if (q[/* length */0]) {
    var tail = q[/* tail */1];
    var head = tail[/* next */1];
    var cell = /* record */[
      /* content */x,
      /* next */head
    ];
    q[/* length */0] = q[/* length */0] + 1 | 0;
    tail[/* next */1] = cell;
    q[/* tail */1] = cell;
    return /* () */0;
  } else {
    var cell$1 = [];
    cell$1[0] = x;
    cell$1[1] = cell$1;
    q[/* length */0] = 1;
    q[/* tail */1] = cell$1;
    return /* () */0;
  }
}

function peek(q) {
  if (q[/* length */0]) {
    return q[/* tail */1][/* next */1][/* content */0];
  } else {
    throw Empty;
  }
}

function take(q) {
  if (!q[/* length */0]) {
    throw Empty;
  }
  q[/* length */0] = q[/* length */0] - 1 | 0;
  var tail = q[/* tail */1];
  var head = tail[/* next */1];
  if (head === tail) {
    q[/* tail */1] = /* None */0;
  } else {
    tail[/* next */1] = head[/* next */1];
  }
  return head[/* content */0];
}

function copy(q) {
  if (q[/* length */0]) {
    var tail = q[/* tail */1];
    var tail$prime = [];
    Caml_obj.caml_update_dummy(tail$prime, /* record */[
          /* content */tail[/* content */0],
          /* next */tail$prime
        ]);
    var copy$1 = function (_prev, _cell) {
      while(true) {
        var cell = _cell;
        var prev = _prev;
        if (cell !== tail) {
          var res = /* record */[
            /* content */cell[/* content */0],
            /* next */tail$prime
          ];
          prev[/* next */1] = res;
          _cell = cell[/* next */1];
          _prev = res;
          continue ;
          
        } else {
          return 0;
        }
      };
    };
    copy$1(tail$prime, tail[/* next */1]);
    return /* record */[
            /* length */q[/* length */0],
            /* tail */tail$prime
          ];
  } else {
    return /* record */[
            /* length */0,
            /* tail : None */0
          ];
  }
}

function is_empty(q) {
  return +(q[/* length */0] === 0);
}

function length(q) {
  return q[/* length */0];
}

function iter(f, q) {
  if (q[/* length */0] > 0) {
    var tail = q[/* tail */1];
    var _cell = tail[/* next */1];
    while(true) {
      var cell = _cell;
      Curry._1(f, cell[/* content */0]);
      if (cell !== tail) {
        _cell = cell[/* next */1];
        continue ;
        
      } else {
        return 0;
      }
    };
  } else {
    return 0;
  }
}

function fold(f, accu, q) {
  if (q[/* length */0]) {
    var tail = q[/* tail */1];
    var _accu = accu;
    var _cell = tail[/* next */1];
    while(true) {
      var cell = _cell;
      var accu$1 = _accu;
      var accu$2 = Curry._2(f, accu$1, cell[/* content */0]);
      if (cell === tail) {
        return accu$2;
      } else {
        _cell = cell[/* next */1];
        _accu = accu$2;
        continue ;
        
      }
    };
  } else {
    return accu;
  }
}

function transfer(q1, q2) {
  var length1 = q1[/* length */0];
  if (length1 > 0) {
    var tail1 = q1[/* tail */1];
    clear(q1);
    if (q2[/* length */0] > 0) {
      var tail2 = q2[/* tail */1];
      var head1 = tail1[/* next */1];
      var head2 = tail2[/* next */1];
      tail1[/* next */1] = head2;
      tail2[/* next */1] = head1;
    }
    q2[/* length */0] = q2[/* length */0] + length1 | 0;
    q2[/* tail */1] = tail1;
    return /* () */0;
  } else {
    return 0;
  }
}

var push = add;

var pop = take;

var top = peek;

exports.Empty    = Empty;
exports.create   = create;
exports.add      = add;
exports.push     = push;
exports.take     = take;
exports.pop      = pop;
exports.peek     = peek;
exports.top      = top;
exports.clear    = clear;
exports.copy     = copy;
exports.is_empty = is_empty;
exports.length   = length;
exports.iter     = iter;
exports.fold     = fold;
exports.transfer = transfer;
/* No side effect */

},{"./caml_exceptions.js":14,"./caml_obj.js":20,"./curry.js":30}],38:[function(require,module,exports){
'use strict';

var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function encodeCompareHow(param) {
  return param;
}

function decodeCompareResult(param) {
  var switcher = param + 1 | 0;
  if (switcher > 2 || switcher < 0) {
    return /* Unknown */3;
  } else {
    return switcher;
  }
}

function decodeCompatMode(param) {
  switch (param) {
    case "BackCompat" : 
        return /* BackCompat */0;
    case "CSS1Compat" : 
        return /* CSS1Compat */1;
    default:
      return /* Unknown */2;
  }
}

function encodeContentEditable(param) {
  switch (param) {
    case 0 : 
        return "true";
    case 1 : 
        return "false";
    case 2 : 
        return "inherit";
    case 3 : 
        return "";
    
  }
}

function decodeContentEditable(param) {
  switch (param) {
    case "false" : 
        return /* False */1;
    case "inherit" : 
        return /* Inherit */2;
    case "true" : 
        return /* True */0;
    default:
      return /* Unknown */3;
  }
}

function decodeDeltaMode(param) {
  if (param > 2 || param < 0) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "invalid deltaMode"
        ];
  } else {
    return param;
  }
}

function encodeDesignMode(param) {
  switch (param) {
    case 0 : 
        return "on";
    case 1 : 
        return "off";
    case 2 : 
        return "";
    
  }
}

function decodeDesignMode(param) {
  switch (param) {
    case "off" : 
        return /* Off */1;
    case "on" : 
        return /* On */0;
    default:
      return /* Unknown */2;
  }
}

function encodeDir(param) {
  switch (param) {
    case 0 : 
        return "ltr";
    case 1 : 
        return "rtl";
    case 2 : 
        return "";
    
  }
}

function decodeDir(param) {
  switch (param) {
    case "ltr" : 
        return /* Ltr */0;
    case "rtl" : 
        return /* Rtl */1;
    default:
      return /* Unknown */2;
  }
}

function decodeEventPhase(param) {
  if (param > 3 || param < 0) {
    return /* Unknown */4;
  } else {
    return param;
  }
}

function encodeFilterAction(param) {
  return param + 1 | 0;
}

function encodeInsertPosition(param) {
  switch (param) {
    case 0 : 
        return "beforebegin";
    case 1 : 
        return "afterbegin";
    case 2 : 
        return "beforeemd";
    case 3 : 
        return "afterend";
    
  }
}

function encodeModifierKey(param) {
  switch (param) {
    case 0 : 
        return "Alt";
    case 1 : 
        return "AltGraph";
    case 2 : 
        return "CapsLock";
    case 3 : 
        return "Control";
    case 4 : 
        return "Fn";
    case 5 : 
        return "FnLock";
    case 6 : 
        return "Hyper";
    case 7 : 
        return "Meta";
    case 8 : 
        return "NumLock";
    case 9 : 
        return "ScrollLock";
    case 10 : 
        return "Shift";
    case 11 : 
        return "Super";
    case 12 : 
        return "Symbol";
    case 13 : 
        return "SymbolLock";
    
  }
}

function decodeNodeType(param) {
  var switcher = param - 1 | 0;
  if (switcher > 11 || switcher < 0) {
    return /* Unknown */12;
  } else {
    return switcher;
  }
}

function decodePointerType(param) {
  switch (param) {
    case "mouse" : 
        return /* Mouse */0;
    case "pen" : 
        return /* Pen */1;
    case "touch|" : 
        return /* Touch */2;
    default:
      return /* Unknown */3;
  }
}

function decodeReadyState(param) {
  switch (param) {
    case "complete" : 
        return /* Complete */2;
    case "interactive" : 
        return /* Interactive */1;
    case "loading" : 
        return /* Loading */0;
    default:
      return /* Unknown */3;
  }
}

function decodeShadowRootMode(param) {
  switch (param) {
    case "closed" : 
        return /* Closed */1;
    case "open" : 
        return /* Open */0;
    default:
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Unknown shadowRootMode"
          ];
  }
}

function decodeVisibilityState(param) {
  switch (param) {
    case "hidden" : 
        return /* Hidden */1;
    case "prerender" : 
        return /* Prerender */2;
    case "unloaded" : 
        return /* Unloaded */3;
    case "visible" : 
        return /* Visible */0;
    default:
      return /* Unknown */4;
  }
}

function many(param) {
  if (param) {
    return param[0] | many(param[1]);
  } else {
    return 0;
  }
}

var WhatToShow = /* module */[
  /* _All */-1,
  /* _Element */1,
  /* _Attribute */2,
  /* _Text */4,
  /* _CDATASection */8,
  /* _EntityReference */16,
  /* _Entity */32,
  /* _ProcessingInstruction */64,
  /* _Comment */128,
  /* _Document */256,
  /* _DocumentType */512,
  /* _DocumentFragment */1024,
  /* _Notation */2048,
  /* many */many
];

exports.encodeCompareHow      = encodeCompareHow;
exports.decodeCompareResult   = decodeCompareResult;
exports.decodeCompatMode      = decodeCompatMode;
exports.encodeContentEditable = encodeContentEditable;
exports.decodeContentEditable = decodeContentEditable;
exports.decodeDeltaMode       = decodeDeltaMode;
exports.encodeDesignMode      = encodeDesignMode;
exports.decodeDesignMode      = decodeDesignMode;
exports.encodeDir             = encodeDir;
exports.decodeDir             = decodeDir;
exports.decodeEventPhase      = decodeEventPhase;
exports.encodeFilterAction    = encodeFilterAction;
exports.encodeInsertPosition  = encodeInsertPosition;
exports.encodeModifierKey     = encodeModifierKey;
exports.decodeNodeType        = decodeNodeType;
exports.decodePointerType     = decodePointerType;
exports.decodeReadyState      = decodeReadyState;
exports.decodeShadowRootMode  = decodeShadowRootMode;
exports.decodeVisibilityState = decodeVisibilityState;
exports.WhatToShow            = WhatToShow;
/* No side effect */

},{"bs-platform/lib/js/caml_builtin_exceptions.js":13}],39:[function(require,module,exports){
'use strict';


function Impl() {
  return /* module */[];
}

exports.Impl = Impl;
/* No side effect */

},{}],40:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39}],41:[function(require,module,exports){
'use strict';

var Curry                      = require("bs-platform/lib/js/curry.js");
var NodeRe                     = require("./NodeRe.js");
var DomTypesRe                 = require("../DomTypesRe.js");
var SlotableRe                 = require("./SlotableRe.js");
var ChildNodeRe                = require("./ChildNodeRe.js");
var Js_primitive               = require("bs-platform/lib/js/js_primitive.js");
var ParentNodeRe               = require("./ParentNodeRe.js");
var EventTargetRe              = require("../events/EventTargetRe.js");
var NonDocumentTypeChildNodeRe = require("./NonDocumentTypeChildNodeRe.js");

function ofNode(node) {
  var match = +(NodeRe.nodeType(node) === /* Element */0);
  if (match !== 0) {
    return /* Some */[node];
  } else {
    return /* None */0;
  }
}

function Impl() {
  var asHtmlElement = (
    function (element) {
      // BEWARE: Assumes "contentEditable" uniquely identifies an HTMLELement
      return element.contentEditable !== undefined ?  element : null;
    }
  );
  var asHtmlElement$1 = function (self) {
    return Js_primitive.null_to_opt(Curry._1(asHtmlElement, self));
  };
  var insertAdjacentElement = function (position, element, self) {
    self.insertAdjacentElement(DomTypesRe.encodeInsertPosition(position), element);
    return /* () */0;
  };
  var insertAdjacentHTML = function (position, text, self) {
    self.insertAdjacentHTML(DomTypesRe.encodeInsertPosition(position), text);
    return /* () */0;
  };
  var insertAdjacentText = function (position, text, self) {
    self.insertAdjacentText(DomTypesRe.encodeInsertPosition(position), text);
    return /* () */0;
  };
  return /* module */[
          /* asHtmlElement */asHtmlElement$1,
          /* ofNode */ofNode,
          /* insertAdjacentElement */insertAdjacentElement,
          /* insertAdjacentHTML */insertAdjacentHTML,
          /* insertAdjacentText */insertAdjacentText
        ];
}

EventTargetRe.Impl(/* module */[]);

var include = NodeRe.Impl(/* module */[]);

ParentNodeRe.Impl(/* module */[]);

NonDocumentTypeChildNodeRe.Impl(/* module */[]);

ChildNodeRe.Impl(/* module */[]);

SlotableRe.Impl(/* module */[]);

var asHtmlElement = (
    function (element) {
      // BEWARE: Assumes "contentEditable" uniquely identifies an HTMLELement
      return element.contentEditable !== undefined ?  element : null;
    }
  );

function asHtmlElement$1(self) {
  return Js_primitive.null_to_opt(Curry._1(asHtmlElement, self));
}

function insertAdjacentElement(position, element, self) {
  self.insertAdjacentElement(DomTypesRe.encodeInsertPosition(position), element);
  return /* () */0;
}

function insertAdjacentHTML(position, text, self) {
  self.insertAdjacentHTML(DomTypesRe.encodeInsertPosition(position), text);
  return /* () */0;
}

function insertAdjacentText(position, text, self) {
  self.insertAdjacentText(DomTypesRe.encodeInsertPosition(position), text);
  return /* () */0;
}

var nodeType = include[0];

exports.Impl                  = Impl;
exports.nodeType              = nodeType;
exports.asHtmlElement         = asHtmlElement$1;
exports.ofNode                = ofNode;
exports.insertAdjacentElement = insertAdjacentElement;
exports.insertAdjacentHTML    = insertAdjacentHTML;
exports.insertAdjacentText    = insertAdjacentText;
/*  Not a pure module */

},{"../DomTypesRe.js":38,"../events/EventTargetRe.js":39,"./ChildNodeRe.js":40,"./NodeRe.js":42,"./NonDocumentTypeChildNodeRe.js":43,"./ParentNodeRe.js":44,"./SlotableRe.js":45,"bs-platform/lib/js/curry.js":30,"bs-platform/lib/js/js_primitive.js":32}],42:[function(require,module,exports){
'use strict';

var DomTypesRe    = require("../DomTypesRe.js");
var EventTargetRe = require("../events/EventTargetRe.js");

function Impl() {
  var nodeType = function (self) {
    return DomTypesRe.decodeNodeType(self.nodeType);
  };
  return /* module */[/* nodeType */nodeType];
}

EventTargetRe.Impl(/* module */[]);

function nodeType(self) {
  return DomTypesRe.decodeNodeType(self.nodeType);
}

exports.Impl     = Impl;
exports.nodeType = nodeType;
/*  Not a pure module */

},{"../DomTypesRe.js":38,"../events/EventTargetRe.js":39}],43:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39}],44:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39}],45:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39}],46:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}]},{},[6]);
