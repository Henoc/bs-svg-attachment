// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var Vec2         = require("./vec2.bs.js");
var Curry        = require("bs-platform/lib/js/curry.js");
var Option       = require("bs-batteries/src/option.js");
var Natives      = require("./natives.bs.js");
var Pervasives   = require("bs-platform/lib/js/pervasives.js");
var Caml_format  = require("bs-platform/lib/js/caml_format.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");

function getAttr(t, name) {
  return Js_primitive.null_to_opt(t[/* elem */1].getAttribute(name));
}

function setAttr(t, name, value) {
  t.setAttribute(name, value);
  return /* () */0;
}

function changeAttr(t, name, valueTranslator) {
  var prev = getAttr(t, name);
  var match = Option.map(valueTranslator, prev);
  if (match) {
    t[/* elem */1].setAttribute(name, match[0]);
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function deleteAttr(t, name) {
  t[/* elem */1].setAttribute(name, ( null ));
  return /* () */0;
}

function move(t, delta) {
  var tx = function (prev) {
    return Pervasives.string_of_float(Caml_format.caml_float_of_string(prev) + delta[/* x */0]);
  };
  var ty = function (prev) {
    return Pervasives.string_of_float(Caml_format.caml_float_of_string(prev) + delta[/* y */1]);
  };
  var match = t[/* elem */1].tagName;
  var exit = 0;
  switch (match) {
    case "circle" : 
    case "ellipse" : 
        exit = 1;
        break;
    case "line" : 
        changeAttr(t, "x1", tx);
        changeAttr(t, "y1", ty);
        changeAttr(t, "x2", tx);
        return changeAttr(t, "y2", ty);
    case "polygon" : 
    case "polyline" : 
        return /* () */0;
    case "image" : 
    case "rect" : 
    case "text" : 
    case "use" : 
        exit = 2;
        break;
    default:
      return /* () */0;
  }
  switch (exit) {
    case 1 : 
        changeAttr(t, "cx", tx);
        return changeAttr(t, "cy", ty);
    case 2 : 
        changeAttr(t, "x", tx);
        return changeAttr(t, "y", ty);
    
  }
}

function getBBox(t) {
  return Curry._1(Natives.getBoundingClientRect, t[/* elem */1]);
}

function getRootLeftTop(t) {
  var rootBox = Curry._1(Natives.getBoundingClientRect, t[/* rootElem */0]);
  return /* float array */[
          rootBox[/* left */7],
          rootBox[/* top */4]
        ];
}

function getRootRightBottom(t) {
  var rootBox = Curry._1(Natives.getBoundingClientRect, t[/* rootElem */0]);
  return /* float array */[
          rootBox[/* right */5],
          rootBox[/* bottom */6]
        ];
}

function getRootCenter(t) {
  var rootBox = Curry._1(Natives.getBoundingClientRect, t[/* rootElem */0]);
  return /* float array */[
          (rootBox[/* left */7] + rootBox[/* right */5]) / 2.0,
          (rootBox[/* top */4] + rootBox[/* bottom */6]) / 2.0
        ];
}

function getLeftTop(t) {
  var box = Curry._1(Natives.getBoundingClientRect, t[/* elem */1]);
  var ground = getRootLeftTop(t);
  return Vec2.$neg$caret(/* float array */[
              box[/* left */7],
              box[/* top */4]
            ], ground);
}

function setLeftTop(t, vec2) {
  var prev = getLeftTop(t);
  var delta = Vec2.$neg$caret(vec2, prev);
  return move(t, delta);
}

function getRightBottom(t) {
  var box = Curry._1(Natives.getBoundingClientRect, t[/* elem */1]);
  var ground = getRootRightBottom(t);
  return Vec2.$neg$caret(/* float array */[
              box[/* right */5],
              box[/* bottom */6]
            ], ground);
}

function getCenter(t) {
  var box = Curry._1(Natives.getBoundingClientRect, t[/* elem */1]);
  var ground = getRootCenter(t);
  return Vec2.$neg$caret(/* float array */[
              (box[/* left */7] + box[/* right */5]) / 2.0,
              (box[/* top */4] + box[/* bottom */6]) / 2.0
            ], ground);
}

function setCenter(t, vec2) {
  var delta = Vec2.$neg$caret(vec2, getCenter(t));
  return move(t, delta);
}

function zoom(t, ratio) {
  var center = getCenter(t);
  var mulK = function (name, k) {
    return changeAttr(t, name, (function (prevStr) {
                  var prev = Number(prevStr);
                  return (prev * k).toString();
                }));
  };
  var match = t[/* elem */1].tagName;
  var exit = 0;
  switch (match) {
    case "circle" : 
        return mulK("r", ratio[/* x */0]);
    case "ellipse" : 
        mulK("rx", ratio[/* x */0]);
        return mulK("ry", ratio[/* y */1]);
    case "line" : 
        mulK("x2", ratio[/* x */0]);
        return mulK("y2", ratio[/* y */1]);
    case "path" : 
    case "polygon" : 
    case "polyline" : 
        return /* () */0;
    case "text" : 
        return mulK("font-size", ratio[/* x */0]);
    case "rect" : 
    case "use" : 
        exit = 1;
        break;
    default:
      return setCenter(t, center);
  }
  if (exit === 1) {
    mulK("width", ratio[/* x */0]);
    return mulK("height", ratio[/* y */1]);
  }
  
}

function getSize(t) {
  var box = Curry._1(Natives.getBoundingClientRect, t[/* elem */1]);
  return /* float array */[
          box[/* width */2],
          box[/* height */3]
        ];
}

function setSize(t, vec2) {
  return zoom(t, Vec2.$slash$caret(vec2, getSize(t)));
}

function getFillColor(t) {
  window.getComputedStyle(t[/* elem */1]);
  return /* () */0;
}

exports.getAttr            = getAttr;
exports.setAttr            = setAttr;
exports.changeAttr         = changeAttr;
exports.deleteAttr         = deleteAttr;
exports.move               = move;
exports.getBBox            = getBBox;
exports.getRootLeftTop     = getRootLeftTop;
exports.getRootRightBottom = getRootRightBottom;
exports.getRootCenter      = getRootCenter;
exports.getLeftTop         = getLeftTop;
exports.setLeftTop         = setLeftTop;
exports.getRightBottom     = getRightBottom;
exports.getCenter          = getCenter;
exports.setCenter          = setCenter;
exports.zoom               = zoom;
exports.getSize            = getSize;
exports.setSize            = setSize;
exports.getFillColor       = getFillColor;
/* Natives Not a pure module */
